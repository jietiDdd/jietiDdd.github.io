<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>missing semester笔记</title>
    <link href="/2025/06/08/missing-semester%E7%AC%94%E8%AE%B0/"/>
    <url>/2025/06/08/missing-semester%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="shell指令"><a href="#shell指令" class="headerlink" title="shell指令"></a>shell指令</h3><p>罗列一些常见的shell指令供翻阅与学习</p><h4 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h4><h5 id="–help和man-查阅帮助"><a href="#–help和man-查阅帮助" class="headerlink" title="–help和man: 查阅帮助"></a>–help和man: 查阅帮助</h5><p>使用man命令手册查阅命令的详细说明和参数，或者–help</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">man <span class="hljs-built_in">ls</span><br><span class="hljs-built_in">ls</span> --<span class="hljs-built_in">help</span><br></code></pre></td></tr></table></figure><h5 id="在程序间创建连接"><a href="#在程序间创建连接" class="headerlink" title="在程序间创建连接"></a>在程序间创建连接</h5><p>默认的输入流和输出流分别为键盘和显示屏，但是 <code>&lt; file</code> 和 <code>&gt; file</code> 可以将输入输出重定向到文件；如果要追加，使用 <code>&gt;&gt;</code> ；而使用 <code>|</code> 可以将一个程序的输出和另一个程序的输入连接起来</p><h5 id="命令分隔符"><a href="#命令分隔符" class="headerlink" title="命令分隔符"></a>命令分隔符</h5><ul><li><code>;</code>: 无论前面命令是否执行成功，都会执行后面的命令</li><li><code>&amp;&amp;</code>: 前面命令执行成功时才执行后面的命令</li><li><code>||</code>: 前面命令执行失败时才执行后面的命令</li></ul><h5 id="子命令"><a href="#子命令" class="headerlink" title="子命令"></a>子命令</h5><p>用于把一个命令的输出结果作为另一个命令的参数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;共有 <span class="hljs-subst">$(ls | wc -l)</span> 个文件&quot;</span><br><span class="hljs-built_in">cat</span> $(find . -name <span class="hljs-string">&quot;*.log&quot;</span>)           <span class="hljs-comment"># 把所有 .log 文件合并显示</span><br></code></pre></td></tr></table></figure><h5 id="执行文件"><a href="#执行文件" class="headerlink" title="执行文件"></a>执行文件</h5><p>使用 <code>./file</code> 即可</p><h5 id="相对路径和绝对路径"><a href="#相对路径和绝对路径" class="headerlink" title="相对路径和绝对路径"></a>相对路径和绝对路径</h5><p>注意 <code>/</code> 代表系统的根目录；某个路径以 <code>/</code> 开头，则为绝对路径，否则为相对路径； <code>.</code> 表示当前目录， <code>..</code> 则表示上级目录</p><h5 id="关于权限"><a href="#关于权限" class="headerlink" title="关于权限"></a>关于权限</h5><p>每个文件或目录都有三类用户的权限：</p><ul><li>u: 文件所有者</li><li>g: 文件所属组</li><li>o: 其他用户</li><li>a: 所有用户，即u+g+o</li></ul><p>每类用户用三个字母表示其权限：</p><ul><li>r: 读，查看内容</li><li>w: 写，修改内容</li><li>x: 执行文件或进入目录</li><li>-: 不具备此权限</li></ul><p>权限可以使用数字法表示，即三种权限代表的数字相加，三个数字分别对应三类用户，其中：</p><ul><li>r &#x3D; 4</li><li>w &#x3D; 2</li><li>x &#x3D; 1</li></ul><p>也可以使用字母符号法：</p><ul><li>+: 添加权限</li><li>-: 去除权限</li><li>&#x3D;: 设置为指定权限</li></ul><h4 id="常用的shell指令"><a href="#常用的shell指令" class="headerlink" title="常用的shell指令"></a>常用的shell指令</h4><h5 id="ls-列出目录内容，即里面的文件和文件夹"><a href="#ls-列出目录内容，即里面的文件和文件夹" class="headerlink" title="ls: 列出目录内容，即里面的文件和文件夹"></a>ls: 列出目录内容，即里面的文件和文件夹</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">ls</span>              <span class="hljs-comment"># 简单列出当前目录内容</span><br><span class="hljs-built_in">ls</span> -l           <span class="hljs-comment"># 详细信息（权限、大小、时间等）</span><br><span class="hljs-built_in">ls</span> -a           <span class="hljs-comment"># 显示所有文件，包括以 . 开头的隐藏文件</span><br><span class="hljs-built_in">ls</span> -lh          <span class="hljs-comment"># 详细信息并以可读单位显示文件大小</span><br><span class="hljs-built_in">ls</span> /path        <span class="hljs-comment"># 查看指定路径</span><br><span class="hljs-built_in">ls</span> --color=auto <span class="hljs-comment"># 彩色打印结果</span><br><span class="hljs-built_in">ls</span> -t           <span class="hljs-comment"># 以最近访问顺序排序</span><br></code></pre></td></tr></table></figure><h5 id="cd-切换目录"><a href="#cd-切换目录" class="headerlink" title="cd: 切换目录"></a>cd: 切换目录</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /home/user    <span class="hljs-comment"># 切换到指定目录</span><br><span class="hljs-built_in">cd</span> ~             <span class="hljs-comment"># 切换到当前用户主目录</span><br><span class="hljs-built_in">cd</span> ..            <span class="hljs-comment"># 返回上一级目录</span><br><span class="hljs-built_in">cd</span> -             <span class="hljs-comment"># 回到上一次所在目录</span><br></code></pre></td></tr></table></figure><h5 id="pwd-显示当前目录的完整路径"><a href="#pwd-显示当前目录的完整路径" class="headerlink" title="pwd: 显示当前目录的完整路径"></a>pwd: 显示当前目录的完整路径</h5><h5 id="mkdir-创建新目录"><a href="#mkdir-创建新目录" class="headerlink" title="mkdir: 创建新目录"></a>mkdir: 创建新目录</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> newdir                 <span class="hljs-comment"># 创建一个新目录</span><br><span class="hljs-built_in">mkdir</span> -p /tmp/dir1/dir2      <span class="hljs-comment"># 递归创建多级目录</span><br></code></pre></td></tr></table></figure><h5 id="rm-删除文件或目录"><a href="#rm-删除文件或目录" class="headerlink" title="rm: 删除文件或目录"></a>rm: 删除文件或目录</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">rm</span> file.txt                <span class="hljs-comment"># 删除文件</span><br><span class="hljs-built_in">rm</span> -r <span class="hljs-built_in">dir</span>                  <span class="hljs-comment"># 递归删除目录及其内容</span><br><span class="hljs-built_in">rm</span> -f file.txt             <span class="hljs-comment"># 强制删除，不提示</span><br><span class="hljs-built_in">rm</span> -rf <span class="hljs-built_in">dir</span>                 <span class="hljs-comment"># 递归强制删除目录</span><br></code></pre></td></tr></table></figure><h5 id="cp-复制文件或目录"><a href="#cp-复制文件或目录" class="headerlink" title="cp: 复制文件或目录"></a>cp: 复制文件或目录</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cp</span> source.txt dest.txt         <span class="hljs-comment"># 复制文件</span><br><span class="hljs-built_in">cp</span> -r dir1 dir2                <span class="hljs-comment"># 递归复制目录</span><br><span class="hljs-built_in">cp</span> file1 file2 /some/dir/      <span class="hljs-comment"># 复制多个文件到目录</span><br></code></pre></td></tr></table></figure><h5 id="mv-移动或重命名文件或目录"><a href="#mv-移动或重命名文件或目录" class="headerlink" title="mv: 移动或重命名文件或目录"></a>mv: 移动或重命名文件或目录</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mv</span> old.txt new.txt             <span class="hljs-comment"># 重命名文件</span><br><span class="hljs-built_in">mv</span> file.txt /new/dir/          <span class="hljs-comment"># 移动文件到新目录</span><br><span class="hljs-built_in">mv</span> dir1 dir2 /path/            <span class="hljs-comment"># 移动多个文件/目录</span><br></code></pre></td></tr></table></figure><h5 id="cat-查看文件内容、合并文件、快速创建文件"><a href="#cat-查看文件内容、合并文件、快速创建文件" class="headerlink" title="cat: 查看文件内容、合并文件、快速创建文件"></a>cat: 查看文件内容、合并文件、快速创建文件</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> file.txt                  <span class="hljs-comment"># 显示文件内容</span><br><span class="hljs-built_in">cat</span> file1 file2 &gt; merged.txt  <span class="hljs-comment"># 合并两个文件为一个新文件</span><br><span class="hljs-built_in">cat</span> &gt; newfile.txt             <span class="hljs-comment"># 创建新文件并输入内容（Ctrl+D结束）</span><br></code></pre></td></tr></table></figure><h5 id="more-less-分页显示文件内容"><a href="#more-less-分页显示文件内容" class="headerlink" title="more&#x2F;less: 分页显示文件内容"></a>more&#x2F;less: 分页显示文件内容</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">more file.txt<br>less file.txt<br></code></pre></td></tr></table></figure><h5 id="head-查看文件开头内容"><a href="#head-查看文件开头内容" class="headerlink" title="head: 查看文件开头内容"></a>head: 查看文件开头内容</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">head</span> file.txt           <span class="hljs-comment"># 默认显示前10行</span><br><span class="hljs-built_in">head</span> -n 20 file.txt     <span class="hljs-comment"># 显示前20行</span><br></code></pre></td></tr></table></figure><h5 id="tail-查看文件结尾内容"><a href="#tail-查看文件结尾内容" class="headerlink" title="tail: 查看文件结尾内容"></a>tail: 查看文件结尾内容</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">tail</span> file.txt           <span class="hljs-comment"># 默认显示后10行</span><br><span class="hljs-built_in">tail</span> -n 20 file.txt     <span class="hljs-comment"># 显示后20行</span><br><span class="hljs-built_in">tail</span> -f log.txt         <span class="hljs-comment"># 实时跟踪文件新增内容</span><br></code></pre></td></tr></table></figure><h5 id="touch-创建新的空文件，或者更新已存在文件的时间戳"><a href="#touch-创建新的空文件，或者更新已存在文件的时间戳" class="headerlink" title="touch: 创建新的空文件，或者更新已存在文件的时间戳"></a>touch: 创建新的空文件，或者更新已存在文件的时间戳</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">touch</span> file.txt            <span class="hljs-comment"># 创建空文件或更新时间戳</span><br><span class="hljs-built_in">touch</span> file1 file2         <span class="hljs-comment"># 同时创建/更新时间戳多个文件</span><br></code></pre></td></tr></table></figure><h5 id="echo-输出文本或变量的值"><a href="#echo-输出文本或变量的值" class="headerlink" title="echo: 输出文本或变量的值"></a>echo: 输出文本或变量的值</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Hello, world!&quot;</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$HOME</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;PATH is <span class="hljs-variable">$PATH</span>&quot;</span><br></code></pre></td></tr></table></figure><h5 id="grep-根据字符串或正则表达式搜索文本内容"><a href="#grep-根据字符串或正则表达式搜索文本内容" class="headerlink" title="grep: 根据字符串或正则表达式搜索文本内容"></a>grep: 根据字符串或正则表达式搜索文本内容</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">grep <span class="hljs-string">&quot;pattern&quot;</span> file.txt             <span class="hljs-comment"># 查找文件中包含&quot;pattern&quot;的行</span><br>grep -i <span class="hljs-string">&quot;pattern&quot;</span> file.txt          <span class="hljs-comment"># 忽略大小写</span><br>grep -r <span class="hljs-string">&quot;pattern&quot;</span> ./dir             <span class="hljs-comment"># 递归搜索目录</span><br>grep -n <span class="hljs-string">&quot;pattern&quot;</span> file.txt          <span class="hljs-comment"># 显示行号</span><br>grep -v <span class="hljs-string">&quot;pattern&quot;</span> file.txt           <span class="hljs-comment"># 反向匹配（不包含 pattern 的行）</span><br></code></pre></td></tr></table></figure><h5 id="sort-对文件每一行进行排序"><a href="#sort-对文件每一行进行排序" class="headerlink" title="sort: 对文件每一行进行排序"></a>sort: 对文件每一行进行排序</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sort</span> file.txt                        <span class="hljs-comment"># 按字母顺序排序</span><br><span class="hljs-built_in">sort</span> -n file.txt                     <span class="hljs-comment"># 按数字排序</span><br><span class="hljs-built_in">sort</span> -r file.txt                     <span class="hljs-comment"># 反向排序（降序）</span><br><span class="hljs-built_in">sort</span> -k 2 file.txt                   <span class="hljs-comment"># 按第2列排序（默认以空格/制表符分隔）</span><br><span class="hljs-built_in">sort</span> -u file.txt                     <span class="hljs-comment"># 排序后去重</span><br></code></pre></td></tr></table></figure><h5 id="uniq-删除重复行"><a href="#uniq-删除重复行" class="headerlink" title="uniq: 删除重复行"></a>uniq: 删除重复行</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">uniq</span> file.txt                        <span class="hljs-comment"># 去除重复行（需先排序）</span><br><span class="hljs-built_in">sort</span> file.txt | <span class="hljs-built_in">uniq</span>                 <span class="hljs-comment"># 先排序再去重</span><br><span class="hljs-built_in">uniq</span> -c file.txt                     <span class="hljs-comment"># 统计每个唯一行出现的次数</span><br><span class="hljs-built_in">uniq</span> -d file.txt                     <span class="hljs-comment"># 只显示重复的行</span><br></code></pre></td></tr></table></figure><h5 id="awk-功能多样"><a href="#awk-功能多样" class="headerlink" title="awk: 功能多样"></a>awk: 功能多样</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">awk <span class="hljs-string">&#x27;&#123;print $1&#125;&#x27;</span> file.txt            <span class="hljs-comment"># 打印第一列</span><br>awk -F <span class="hljs-string">&#x27;:&#x27;</span> <span class="hljs-string">&#x27;&#123;print $1, $3&#125;&#x27;</span> /etc/passwd  <span class="hljs-comment"># 指定分隔符</span><br>awk <span class="hljs-string">&#x27;$3 &gt; 1000 &#123;print $1&#125;&#x27;</span> /etc/passwd   <span class="hljs-comment"># 条件筛选</span><br>awk <span class="hljs-string">&#x27;&#123;sum += $2&#125; END &#123;print sum&#125;&#x27;</span> file.txt  <span class="hljs-comment"># 汇总第二列</span><br></code></pre></td></tr></table></figure><h5 id="cut-按列提取文本"><a href="#cut-按列提取文本" class="headerlink" title="cut: 按列提取文本"></a>cut: 按列提取文本</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cut</span> -d <span class="hljs-string">&#x27;:&#x27;</span> -f 1 /etc/passwd          <span class="hljs-comment"># 以 : 为分隔符，提取第1列</span><br><span class="hljs-built_in">cut</span> -c 1-5 file.txt                  <span class="hljs-comment"># 提取每行的第1至5个字符</span><br><span class="hljs-built_in">cut</span> -f2,4 -d<span class="hljs-string">&#x27;,&#x27;</span> data.csv             <span class="hljs-comment"># 以逗号为分隔符，提取第2和第4列</span><br></code></pre></td></tr></table></figure><h5 id="sed-流编辑器，批量处理文本内容"><a href="#sed-流编辑器，批量处理文本内容" class="headerlink" title="sed: 流编辑器，批量处理文本内容"></a>sed: 流编辑器，批量处理文本内容</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">sed <span class="hljs-string">&#x27;s/old/new/&#x27;</span> file.txt          <span class="hljs-comment"># 替换每行第一个old为new（s为替换）</span><br>sed <span class="hljs-string">&#x27;s/old/new/g&#x27;</span> file.txt         <span class="hljs-comment"># 替换每行所有old为new（s为替换，g为全局）</span><br>sed <span class="hljs-string">&#x27;2d&#x27;</span> file.txt                  <span class="hljs-comment"># 删除第二行</span><br>sed <span class="hljs-string">&#x27;2,4d&#x27;</span> file.txt                <span class="hljs-comment"># 删除第2到4行</span><br>sed -n <span class="hljs-string">&#x27;5,10p&#x27;</span> file.txt            <span class="hljs-comment"># 只显示第5到10行</span><br>sed <span class="hljs-string">&#x27;2i\插入内容&#x27;</span> file.txt         <span class="hljs-comment"># 在第二行前插入内容</span><br>sed <span class="hljs-string">&#x27;2a\追加内容&#x27;</span> file.txt         <span class="hljs-comment"># 在第二行后追加内容</span><br></code></pre></td></tr></table></figure><p>添加 <code>-e</code> 选项以支持多条指令， <code>-E</code> 选项以支持正则表达式</p><h5 id="wc-统计文件内容"><a href="#wc-统计文件内容" class="headerlink" title="wc: 统计文件内容"></a>wc: 统计文件内容</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">wc</span> -l file.txt         <span class="hljs-comment"># 行数</span><br><span class="hljs-built_in">wc</span> -w file.txt         <span class="hljs-comment"># 单词数</span><br><span class="hljs-built_in">wc</span> -c file.txt         <span class="hljs-comment"># 字节数</span><br></code></pre></td></tr></table></figure><h5 id="diff-cmp-比较文件差异"><a href="#diff-cmp-比较文件差异" class="headerlink" title="diff&#x2F;cmp: 比较文件差异"></a>diff&#x2F;cmp: 比较文件差异</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">diff file1.txt file2.txt<br>cmp file1.txt file2.txt<br></code></pre></td></tr></table></figure><h5 id="find-查找文件或目录"><a href="#find-查找文件或目录" class="headerlink" title="find: 查找文件或目录"></a>find: 查找文件或目录</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">find . -name <span class="hljs-string">&quot;*.txt&quot;</span>                <span class="hljs-comment"># 当前目录下查找所有txt文件</span><br>find /home -<span class="hljs-built_in">type</span> d -name <span class="hljs-string">&quot;test*&quot;</span>    <span class="hljs-comment"># 查找以test开头的目录</span><br>find . -size +10M                   <span class="hljs-comment"># 查找大于10M的文件</span><br></code></pre></td></tr></table></figure><h5 id="locate-在系统索引数据库中快速查找文件"><a href="#locate-在系统索引数据库中快速查找文件" class="headerlink" title="locate: 在系统索引数据库中快速查找文件"></a>locate: 在系统索引数据库中快速查找文件</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">locate bashrc<br></code></pre></td></tr></table></figure><p>使用 <code>updatedb</code> 定期更新数据库</p><h5 id="chmod-修改权限"><a href="#chmod-修改权限" class="headerlink" title="chmod: 修改权限"></a>chmod: 修改权限</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">chmod</span> 777 test.txt         <span class="hljs-comment"># 所有人全部权限</span><br><span class="hljs-built_in">chmod</span> 644 test.txt         <span class="hljs-comment"># 所有者rw，组/其他r</span><br><span class="hljs-built_in">chmod</span> 600 secret.txt       <span class="hljs-comment"># 只有所有者可读写</span><br><span class="hljs-built_in">chmod</span> +x run.sh            <span class="hljs-comment"># 给所有用户添加可执行权限</span><br><span class="hljs-built_in">chmod</span> -R 755 /path/dir     <span class="hljs-comment"># 递归更改目录及其内容权限</span><br><span class="hljs-built_in">chmod</span> u+x file.sh          <span class="hljs-comment"># 给所有者添加执行权限</span><br><span class="hljs-built_in">chmod</span> go-w file.txt        <span class="hljs-comment"># 移除组和其他用户的写权限</span><br><span class="hljs-built_in">chmod</span> a=r myfile           <span class="hljs-comment"># 所有人只有读权限</span><br><span class="hljs-built_in">chmod</span> u=rw,go=r data.txt   <span class="hljs-comment"># u:读写，g/o:只读</span><br></code></pre></td></tr></table></figure><h5 id="chown-修改所有者和所属组"><a href="#chown-修改所有者和所属组" class="headerlink" title="chown: 修改所有者和所属组"></a>chown: 修改所有者和所属组</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">chown</span> user file.txt<br><span class="hljs-built_in">chown</span> user:group file.txt<br></code></pre></td></tr></table></figure><h5 id="su-sudo-切换用户-以管理者身份执行命令"><a href="#su-sudo-切换用户-以管理者身份执行命令" class="headerlink" title="su&#x2F;sudo: 切换用户&#x2F;以管理者身份执行命令"></a>su&#x2F;sudo: 切换用户&#x2F;以管理者身份执行命令</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">su               <span class="hljs-comment"># 切换到root用户，需要输入root密码</span><br><span class="hljs-built_in">sudo</span> <span class="hljs-built_in">command</span>     <span class="hljs-comment"># 以root权限执行command</span><br></code></pre></td></tr></table></figure><h5 id="ps-查看进程"><a href="#ps-查看进程" class="headerlink" title="ps: 查看进程"></a>ps: 查看进程</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">ps                <span class="hljs-comment"># 查看当前shell的进程</span><br>ps aux            <span class="hljs-comment"># 查看所有进程</span><br>ps -ef            <span class="hljs-comment"># 另一种详细格式</span><br></code></pre></td></tr></table></figure><h5 id="top-htop-动态显示系统进程和资源占用情况"><a href="#top-htop-动态显示系统进程和资源占用情况" class="headerlink" title="top&#x2F;htop: 动态显示系统进程和资源占用情况"></a>top&#x2F;htop: 动态显示系统进程和资源占用情况</h5><h5 id="kill-终止进程"><a href="#kill-终止进程" class="headerlink" title="kill: 终止进程"></a>kill: 终止进程</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">kill</span> PID                <span class="hljs-comment"># 结束指定进程</span><br><span class="hljs-built_in">kill</span> -9 PID             <span class="hljs-comment"># 强制杀死进程</span><br></code></pre></td></tr></table></figure><h5 id="df-查看磁盘大小"><a href="#df-查看磁盘大小" class="headerlink" title="df: 查看磁盘大小"></a>df: 查看磁盘大小</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">df</span> -h                  <span class="hljs-comment"># 以可读单位显示磁盘使用情况</span><br></code></pre></td></tr></table></figure><h5 id="du-查看文件或目录大小"><a href="#du-查看文件或目录大小" class="headerlink" title="du: 查看文件或目录大小"></a>du: 查看文件或目录大小</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">du</span> -sh *               <span class="hljs-comment"># 显示当前目录下每个文件/目录的大小</span><br><span class="hljs-built_in">du</span> -h --max-depth=1    <span class="hljs-comment"># 只显示一级子目录大小</span><br></code></pre></td></tr></table></figure><h5 id="free-查看内存使用"><a href="#free-查看内存使用" class="headerlink" title="free: 查看内存使用"></a>free: 查看内存使用</h5><h5 id="uname-显示系统信息"><a href="#uname-显示系统信息" class="headerlink" title="uname: 显示系统信息"></a>uname: 显示系统信息</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">uname</span> -a                <span class="hljs-comment"># 显示全部信息</span><br><span class="hljs-built_in">uname</span> -r                <span class="hljs-comment"># 显示内核版本</span><br></code></pre></td></tr></table></figure><h5 id="ping-测试主机之间的网络连接"><a href="#ping-测试主机之间的网络连接" class="headerlink" title="ping: 测试主机之间的网络连接"></a>ping: 测试主机之间的网络连接</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">ping www.baidu.com<br>ping -c 4 www.baidu.com   <span class="hljs-comment"># 只ping 4次</span><br></code></pre></td></tr></table></figure><h5 id="ifconfig-ip-显示或配置网络接口信息"><a href="#ifconfig-ip-显示或配置网络接口信息" class="headerlink" title="ifconfig&#x2F;ip: 显示或配置网络接口信息"></a>ifconfig&#x2F;ip: 显示或配置网络接口信息</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ip a<br></code></pre></td></tr></table></figure><h5 id="curl-wget-从网络获取文件或数据"><a href="#curl-wget-从网络获取文件或数据" class="headerlink" title="curl&#x2F;wget: 从网络获取文件或数据"></a>curl&#x2F;wget: 从网络获取文件或数据</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl http://example.com<br>wget http://example.com/file.txt<br></code></pre></td></tr></table></figure><h5 id="history-查看历史命令"><a href="#history-查看历史命令" class="headerlink" title="history: 查看历史命令"></a>history: 查看历史命令</h5><h5 id="date-显示或设置系统时间"><a href="#date-显示或设置系统时间" class="headerlink" title="date: 显示或设置系统时间"></a>date: 显示或设置系统时间</h5><h5 id="clear-清屏"><a href="#clear-清屏" class="headerlink" title="clear: 清屏"></a>clear: 清屏</h5><h3 id="shell脚本"><a href="#shell脚本" class="headerlink" title="shell脚本"></a>shell脚本</h3><h4 id="脚本开头：shebang"><a href="#脚本开头：shebang" class="headerlink" title="脚本开头：shebang"></a>脚本开头：shebang</h4><p>用于指定解释器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br></code></pre></td></tr></table></figure><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><p>使用变量时前面加上 <code>$</code> ；赋值时等号左右不能有空格，否则视为参数；分隔符 <code>&#39;</code> 中的变量不会被转义，而 <code>&quot;</code> 会将变量值进行替换；<code>$(CMD)</code> 实现命令替换，即用命令的输出进行替换；<code>&lt;(CMD)</code> 则会执行命令并将结果输出到一个临时文件中</p><h4 id="获取脚本参数"><a href="#获取脚本参数" class="headerlink" title="获取脚本参数"></a>获取脚本参数</h4><ul><li><code>$0</code>: 脚本名</li><li><code>$1</code>: 脚本的第一个参数</li><li><code>$@</code>: 所有参数（分开）</li><li><code>$*</code>: 所有参数（整体）</li><li><code>$#</code>: 参数个数</li><li><code>$?</code>: 前一个命令的返回值（退出状态）</li><li><code>$$</code>: 当前脚本的进程识别码</li><li><code>!!</code>: 完整的上一条命令（含参数）</li><li><code>$_</code>: 上一条命令的最后一个参数</li></ul><h4 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">if</span> [ condition ]; <span class="hljs-keyword">then</span><br>  command1<br><span class="hljs-keyword">elif</span> [ condition2 ]; <span class="hljs-keyword">then</span><br>  command2<br><span class="hljs-keyword">else</span><br>  command3<br><span class="hljs-keyword">fi</span><br></code></pre></td></tr></table></figure><p>常见条件运算符（整数）：</p><ul><li><code>-eq</code>: 等于</li><li><code>-ne</code>: 不等于</li><li><code>-gt</code>: 大于</li><li><code>-lt</code>: 小于</li><li><code>-ge</code>: 大于等于</li><li><code>-le</code>: 小于等于</li></ul><p>字符串判断：</p><ul><li><code>-z</code>: 字符串为空</li><li><code>-n</code>: 字符串非空</li></ul><p>文件判断：</p><ul><li><code>-e file</code>: 文件存在</li><li><code>-f file</code>: 普通文件</li><li><code>-d file</code>: 目录</li></ul><h4 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># for循环</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> 1 2 3; <span class="hljs-keyword">do</span><br>  <span class="hljs-built_in">echo</span> <span class="hljs-variable">$i</span><br><span class="hljs-keyword">done</span><br><br><span class="hljs-keyword">for</span> file <span class="hljs-keyword">in</span> *.txt; <span class="hljs-keyword">do</span><br>  <span class="hljs-built_in">echo</span> <span class="hljs-variable">$file</span><br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># while循环</span><br>count=1<br><span class="hljs-keyword">while</span> [ <span class="hljs-variable">$count</span> -le 5 ]; <span class="hljs-keyword">do</span><br>  <span class="hljs-built_in">echo</span> <span class="hljs-variable">$count</span><br>  count=$((count+<span class="hljs-number">1</span>))<br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-function"><span class="hljs-title">myfunc</span></span>() &#123;<br>  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;参数1：<span class="hljs-variable">$1</span>&quot;</span><br>&#125;<br>myfunc <span class="hljs-string">&quot;hello&quot;</span><br></code></pre></td></tr></table></figure><p>使用 <code>source</code> 指令加载函数</p><h3 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h3><p>懒得看了，待补充，参考指令 <code>vimtutor</code> ，或者<a href="https://github.com/HanielF/VimTutor">vimtutor中文版</a></p><h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><p>参考<a href="https://deerchao.cn/tutorials/regex/regex.htm">正则表达式30分钟入门教程</a></p><h4 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h4><ul><li><code>.</code>: 匹配除换行符以外的任意字符，在Singleline模式也会匹配换行符；如果是想查找 <code>.</code> 这个字符本身，请使用转义 <code>\.</code></li><li><code>\w</code>: 匹配字母或数字或下划线，等效于 <code>[A-Za-z0-9_]</code></li><li><code>\s</code>: 匹配任何空白符</li><li><code>\d</code>: 匹配数字</li><li><code>\b</code>: 匹配单词开头或结束，如 <code>\bhi\b</code> 精确匹配单词hi</li><li><code>^</code>: 匹配字符串的开始，在Multiline模式匹配行首</li><li><code>$</code>: 匹配字符串的结束</li></ul><h4 id="限定符"><a href="#限定符" class="headerlink" title="限定符"></a>限定符</h4><ul><li><code>*</code>: 重复零次或更多次</li><li><code>+</code>: 重复一次或更多次</li><li><code>?</code>: 重复零次或一次</li><li><code>&#123;n&#125;</code>: 重复n次</li><li><code>&#123;n,&#125;</code>: 重复n次或更多次</li><li><code>&#123;n,m&#125;</code>: 重复n到m次</li></ul><p>注意限定符默认贪婪，即匹配尽可能多的字符，如 <code>a.*b</code> 匹配最长的a开始b结束的字符串；为了懒惰，即匹配尽可能少的字符，在限定符后加上 <code>?</code> 即可</p><h4 id="字符类"><a href="#字符类" class="headerlink" title="字符类"></a>字符类</h4><p>使用方括号，如 <code>[aeiou]</code> 匹配任意一个元音字母， <code>[0-9]</code> 等效于 <code>\d</code></p><h4 id="分枝条件"><a href="#分枝条件" class="headerlink" title="分枝条件"></a>分枝条件</h4><p>使用 <code>|</code> 匹配多个规则，类似于or，因此也要注意条件顺序</p><h4 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h4><p>使用圆括号来分组，从而匹配括号里的子表达式，并可以使用限定符约束；在这样做时实现了捕获，正则表达式从左到右为每个分组分配一个组号，后续使用 <code>\1</code> 可以代表分组1的文本（而分组0代表整个正则表达式）</p><h5 id="捕获"><a href="#捕获" class="headerlink" title="捕获"></a>捕获</h5><ul><li><code>(exp)</code>: 匹配exp，并捕获文本到自动命名的组里</li><li><code>(?&lt;name&gt;exp)</code>: 匹配exp，并捕获文本到名称为name的组里，也可以写成 <code>(?&#39;name&#39;exp)</code></li><li><code>(?:exp)</code>: 匹配exp，不捕获匹配的文本，也不给此分组分配组号</li></ul><h5 id="零宽断言"><a href="#零宽断言" class="headerlink" title="零宽断言"></a>零宽断言</h5><p>如 <code>(?=exp)</code> 断言自身出现的位置的后面能匹配表达式exp，如 <code>\b\w+(?=ing\b)</code> 匹配以ing结尾的单词的前面的部分（除了ing以外的部分）</p><ul><li><code>(?=exp)</code>: 匹配exp前面的位置</li><li><code>(?&lt;=exp)</code>: 匹配exp后面的位置</li><li><code>(?!exp)</code>: 匹配后面跟的不是exp的位置</li><li><code>(?&lt;!exp)</code>: 匹配前面不是exp的位置</li></ul><h5 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h5><p>使用 <code>(?#comment)</code> 写注释</p><h4 id="反义"><a href="#反义" class="headerlink" title="反义"></a>反义</h4><ul><li><code>\W</code>: 匹配任意不是字母，数字，下划线的字符</li><li><code>\S</code>: 匹配任意不是空白符的字符</li><li><code>\D</code>: 匹配任意非数字的字符</li><li><code>\B</code>: 匹配不是单词开头或结束的位置</li><li><code>[^x]</code>: 匹配除了x以外的任意字符</li></ul><h4 id="递归匹配"><a href="#递归匹配" class="headerlink" title="递归匹配"></a>递归匹配</h4><p>用于判定括号匹配等等，使用了栈的思想</p><ul><li><code>(?&#39;group&#39;)</code>: 把捕获的内容命名为group，并压入堆栈</li><li><code>(?&#39;-group&#39;)</code>: 从堆栈上弹出最后压入堆栈的名为group的捕获内容，如果堆栈本来为空，则本分组的匹配失败</li><li><code>(?(group)yes|no)</code>: 如果堆栈上存在以名为group的捕获内容的话，继续匹配yes部分的表达式，否则继续匹配no部分</li><li><code>(?!)</code>: 零宽负向先行断言，由于没有后缀表达式，试图匹配总是失败</li></ul><h3 id="命令行环境"><a href="#命令行环境" class="headerlink" title="命令行环境"></a>命令行环境</h3><h4 id="终端多路复用"><a href="#终端多路复用" class="headerlink" title="终端多路复用"></a>终端多路复用</h4><p>使用 <code>tmux</code> 实现基于面板和标签分割出多个终端窗口，从而同时与多个 shell 会话进行交互</p><h5 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">tmux                     <span class="hljs-comment"># 启动 tmux 并进入默认 session</span><br>tmux new -s mysession    <span class="hljs-comment"># 新建并命名一个 session</span><br>tmux <span class="hljs-built_in">ls</span>                  <span class="hljs-comment"># 列出所有 session</span><br>tmux attach -t mysession <span class="hljs-comment"># 连接/恢复到指定 session</span><br>tmux kill-session -t mysession  <span class="hljs-comment"># 关闭指定 session</span><br>tmux detach              <span class="hljs-comment"># 分离当前session保持后台运行，也可以使用Ctrl-b d</span><br></code></pre></td></tr></table></figure><h5 id="窗口"><a href="#窗口" class="headerlink" title="窗口"></a>窗口</h5><ul><li><code>Ctrl+b c</code>: 新建窗口</li><li><code>Ctrl+b n</code>: 下一个窗口</li><li><code>Ctrl+b p</code>: 上一个窗口</li><li><code>Ctrl+b w</code> 列出窗口列表</li><li><code>Ctrl+b ,</code>: 重命名当前窗口</li></ul><h5 id="面板"><a href="#面板" class="headerlink" title="面板"></a>面板</h5><ul><li><code>Ctrl+b %</code>: 横向分屏（左右）</li><li><code>Ctrl+b &quot;</code>: 纵向分屏（上下）</li><li><code>Ctrl+b o</code>: 在各面板之间切换</li><li><code>Ctrl+b x</code>: 关闭当前面板</li><li><code>Ctrl+b ;</code>: 返回上一个面板</li></ul><h4 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h4><p>使用 <code>alias</code> 指令取个简短的新名字</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">alias</span> alias_name=<span class="hljs-string">&quot;command_to_alias arg1 arg2&quot;</span><br></code></pre></td></tr></table></figure><h4 id="远端设备"><a href="#远端设备" class="headerlink" title="远端设备"></a>远端设备</h4><p>使用 <code>ssh</code> 指令连接到其他服务器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh [user@]hostname [<span class="hljs-built_in">command</span>]<br>ssh -p 2222 user@host         <span class="hljs-comment"># 连接到2222端口</span><br>ssh -i ~/.ssh/id_rsa user@host <span class="hljs-comment"># 用指定私钥认证</span><br>ssh -L 8080:localhost:80 user@host <span class="hljs-comment"># 本地8080转发到远程80端口</span><br>ssh -R 2022:localhost:22 user@host <span class="hljs-comment"># 远程端口转发</span><br></code></pre></td></tr></table></figure><h5 id="公钥认证"><a href="#公钥认证" class="headerlink" title="公钥认证"></a>公钥认证</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh-keygen -t rsa       <span class="hljs-comment"># 生成密钥对</span><br>ssh-copy-id user@host   <span class="hljs-comment"># 将公钥上传到远程主机</span><br></code></pre></td></tr></table></figure><h5 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h5><p>即设置 <code>~/.ssh/config</code> 来简化指令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs config">Host myserver<br>    HostName server.com<br>    User alice<br>    Port 2222<br>    IdentityFile ~/.ssh/id_rsa<br></code></pre></td></tr></table></figure><h5 id="相关指令"><a href="#相关指令" class="headerlink" title="相关指令"></a>相关指令</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">scp file.txt user@host:/tmp/    <span class="hljs-comment"># 基于ssh的拷贝</span><br><span class="hljs-built_in">tee</span>         <span class="hljs-comment"># 将标准输出写入到一个文件，可以配合ssh使用</span><br></code></pre></td></tr></table></figure><h3 id="git"><a href="#git" class="headerlink" title="git"></a>git</h3><p>一些常用指令</p><h4 id="日常同步和获取代码"><a href="#日常同步和获取代码" class="headerlink" title="日常同步和获取代码"></a>日常同步和获取代码</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> &lt;address&gt;     <span class="hljs-comment"># 第一次获取项目代码到本地</span><br>git pull                <span class="hljs-comment"># 同步远程仓库最新提交到本地当前分支</span><br></code></pre></td></tr></table></figure><h4 id="代码变更管理"><a href="#代码变更管理" class="headerlink" title="代码变更管理"></a>代码变更管理</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">git status              <span class="hljs-comment"># 查看哪些文件发生了变化、哪些文件已暂存、哪些未提交</span><br>git add &lt;file name&gt;<br>git add .               <span class="hljs-comment"># 把更改加入到下次提交的“暂存区”，. 表示全部添加</span><br>git commit -m <span class="hljs-string">&quot;message&quot;</span> <span class="hljs-comment"># 把暂存区的更改保存为一次提交</span><br></code></pre></td></tr></table></figure><h4 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">git branch                  <span class="hljs-comment"># 列出所有本地分支</span><br>git checkout -b &lt;feature&gt;   <span class="hljs-comment"># 新建并切换分支</span><br>git checkout &lt;feature&gt;      <span class="hljs-comment"># 切换分支</span><br>git merge &lt;feature&gt;         <span class="hljs-comment"># 把指定分支的更改合并到当前分支</span><br>git branch -d &lt;feature&gt;     <span class="hljs-comment"># 删除已合并或不用的分支</span><br></code></pre></td></tr></table></figure><h4 id="推送与协作"><a href="#推送与协作" class="headerlink" title="推送与协作"></a>推送与协作</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git push                        <span class="hljs-comment"># 把本地提交同步到远程仓库</span><br>git push -u origin &lt;feature&gt;    <span class="hljs-comment"># 推送新分支到远程，第一次把新分支推送到远程时常用</span><br></code></pre></td></tr></table></figure><h4 id="历史与排查"><a href="#历史与排查" class="headerlink" title="历史与排查"></a>历史与排查</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">log</span>                 <span class="hljs-comment"># 查看项目的提交记录</span><br>git <span class="hljs-built_in">log</span> &lt;file name&gt;     <span class="hljs-comment"># 排查某文件的历史修改</span><br>git diff                <span class="hljs-comment"># 比较未提交的更改、分支差异等</span><br>git stash               <span class="hljs-comment"># 临时保存未提交的更改，切换分支后可恢复</span><br></code></pre></td></tr></table></figure><h4 id="场景举例"><a href="#场景举例" class="headerlink" title="场景举例"></a>场景举例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">git pull                        <span class="hljs-comment"># 拉取最新代码</span><br>git checkout -b &lt;feature&gt;       <span class="hljs-comment"># 新建分支</span><br>git add .<br>git commit -m &lt;message&gt;         <span class="hljs-comment"># 提交</span><br>git push -u origin &lt;feature&gt;    <span class="hljs-comment"># 推送分支</span><br><span class="hljs-comment"># pr</span><br>git checkout main               <span class="hljs-comment"># 切回主分支</span><br>git pull                        <span class="hljs-comment"># 同步</span><br>git branch -d &lt;feature&gt;         <span class="hljs-comment"># 删除用完的本地分支</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>计算机学习</category>
      
      <category>csdiy</category>
      
      <category>missing semester</category>
      
    </categories>
    
    
    <tags>
      
      <tag>csdiy</tag>
      
      <tag>missing semester</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>代码随想录之双指针、链表、二叉树、栈与队列</title>
    <link href="/2025/06/03/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E4%B9%8B%E5%8F%8C%E6%8C%87%E9%92%88%E3%80%81%E9%93%BE%E8%A1%A8%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91%E3%80%81%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"/>
    <url>/2025/06/03/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E4%B9%8B%E5%8F%8C%E6%8C%87%E9%92%88%E3%80%81%E9%93%BE%E8%A1%A8%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91%E3%80%81%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><h4 id="移除元素——双指针法"><a href="#移除元素——双指针法" class="headerlink" title="移除元素——双指针法"></a>移除元素——双指针法</h4><blockquote><p>给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。<br>不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并原地修改输入数组。<br>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。<br>示例 1: 给定 nums &#x3D; [3,2,2,3], val &#x3D; 3, 函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。 你不需要考虑数组中超出新长度后面的元素。<br>示例 2: 给定 nums &#x3D; [0,1,2,2,3,0,4,2], val &#x3D; 2, 函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。<br>你不需要考虑数组中超出新长度后面的元素。</p></blockquote><p>使用双指针的思路，定义快慢指针，快指针：寻找新数组的元素，新数组就是不含有目标元素的数组；慢指针：指向更新新数组下标的位置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">removeElement</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, slow = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// fast用于检查是否等于val，slow用于计算不等于val的数目</span><br>        <span class="hljs-keyword">while</span>(fast != nums.length)&#123;<br>            <span class="hljs-keyword">if</span>(val != nums[fast])&#123;<br>                nums[slow] = nums[fast];<br>                slow++;<br>                fast++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                fast++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> slow;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="类似的双指针法（滑动窗口）——长度最小的子数组"><a href="#类似的双指针法（滑动窗口）——长度最小的子数组" class="headerlink" title="类似的双指针法（滑动窗口）——长度最小的子数组"></a>类似的双指针法（滑动窗口）——长度最小的子数组</h5><blockquote><p>给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组，并返回其长度。如果不存在符合条件的子数组，返回 0。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minSubArrayLen</span><span class="hljs-params">(<span class="hljs-type">int</span> target, <span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, slow = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// slow指向子数组的头一个元素</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> target;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> nums.length + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(fast &lt; nums.length)&#123;<br>            <span class="hljs-keyword">if</span>(nums[fast] &lt; sum)&#123;<br>                sum -= nums[fast];<br>                fast++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span>(len &gt; fast - slow + <span class="hljs-number">1</span>)&#123;<br>                    len = fast - slow + <span class="hljs-number">1</span>;<br>                &#125;<br>                sum += nums[slow];<br>                slow++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> len == nums.length + <span class="hljs-number">1</span> ? <span class="hljs-number">0</span> : len;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="滑动窗口和哈希表结合——水果成篮"><a href="#滑动窗口和哈希表结合——水果成篮" class="headerlink" title="滑动窗口和哈希表结合——水果成篮"></a>滑动窗口和哈希表结合——水果成篮</h5><blockquote><p>你正在探访一家农场，农场从左到右种植了一排果树。这些树用一个整数数组 fruits 表示，其中 fruits[i] 是第 i 棵树上的水果 种类 。<br>你想要尽可能多地收集水果。然而，农场的主人设定了一些严格的规矩，你必须按照要求采摘水果：<br>你只有 两个 篮子，并且每个篮子只能装 单一类型 的水果。每个篮子能够装的水果总量没有限制。<br>你可以选择任意一棵树开始采摘，你必须从 每棵 树（包括开始采摘的树）上 恰好摘一个水果 。采摘的水果应当符合篮子中的水果类型。每采摘一次，你将会向右移动到下一棵树，并继续采摘。<br>一旦你走到某棵树前，但水果不符合篮子的水果类型，那么就必须停止采摘。<br>给你一个整数数组 fruits ，返回你可以收集的水果的 最大 数目。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">totalFruit</span><span class="hljs-params">(<span class="hljs-type">int</span>[] fruits)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, fast = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">total</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span>[] count = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[fruits.length];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(fast &lt; fruits.length)&#123;<br>            count[fruits[fast]]++;<br>            <span class="hljs-keyword">if</span>(count[fruits[fast]] == <span class="hljs-number">1</span>)&#123;<br>                total++;<br>            &#125;<br>            <span class="hljs-keyword">while</span>(total &gt; <span class="hljs-number">2</span>)&#123;<br>                count[fruits[slow]]--;<br>                <span class="hljs-keyword">if</span>(count[fruits[slow]] == <span class="hljs-number">0</span>)&#123;<br>                    total--;<br>                &#125;<br>                slow++;<br>            &#125;<br>            fast++;<br>            <span class="hljs-keyword">if</span>(len &lt; fast - slow)&#123;<br>                len = fast - slow;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> len;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="升级版滑动窗口和哈希表——无重复字符的最长字串"><a href="#升级版滑动窗口和哈希表——无重复字符的最长字串" class="headerlink" title="升级版滑动窗口和哈希表——无重复字符的最长字串"></a>升级版滑动窗口和哈希表——无重复字符的最长字串</h5><blockquote><p>给定一个字符串 s ，请你找出其中不含有重复字符的 最长 子串 的长度。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lengthOfLongestSubstring</span><span class="hljs-params">(String s)</span> &#123;<br>        Set&lt;Character&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; slow &lt; s.length(); slow++)&#123;<br>            <span class="hljs-keyword">if</span>(slow != <span class="hljs-number">0</span>)&#123;<br>                set.remove(s.charAt(slow - <span class="hljs-number">1</span>));<br>            &#125;<br>            <span class="hljs-keyword">while</span>(fast != s.length() &amp;&amp; !set.contains(s.charAt(fast)))&#123;<br>                set.add(s.charAt(fast));<br>                fast++;<br>            &#125;<br>            res = Math.max(res, fast - slow);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="找到字符串中所有字母异位词"><a href="#找到字符串中所有字母异位词" class="headerlink" title="找到字符串中所有字母异位词"></a>找到字符串中所有字母异位词</h5><blockquote><p>给定两个字符串 s 和 p，找到 s 中所有 p 的 异位词 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。</p></blockquote><p>这里利用小写字母特性，只使用26位哈希表（数组），节约空间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">findAnagrams</span><span class="hljs-params">(String s, String p)</span> &#123;<br>        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">if</span>(s.length() &lt; p.length())&#123;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br>        <span class="hljs-type">int</span>[] sCount = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">26</span>];<br>        <span class="hljs-type">int</span>[] pCount = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">26</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; p.length(); i++)&#123; <span class="hljs-comment">// 先看前p位</span><br>            pCount[p.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>            sCount[s.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(Arrays.equals(sCount, pCount))&#123;<br>            res.add(<span class="hljs-number">0</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> p.length(); i &lt; s.length(); i++)&#123; <span class="hljs-comment">// 看后面的位数</span><br>            --sCount[s.charAt(i - p.length()) - <span class="hljs-string">&#x27;a&#x27;</span>]; <span class="hljs-comment">// 滑动窗口，失去一个得到一个</span><br>            ++sCount[s.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>];<br>            <span class="hljs-keyword">if</span>(Arrays.equals(sCount, pCount))&#123;<br>                res.add(i - p.length() + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="双指针收缩——盛最多水的容器"><a href="#双指针收缩——盛最多水的容器" class="headerlink" title="双指针收缩——盛最多水的容器"></a>双指针收缩——盛最多水的容器</h5><blockquote><p>给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。<br>找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。<br>返回容器可以储存的最大水量。<br>说明：你不能倾斜容器。</p></blockquote><p>使用双指针收缩容器，注意比较left和right来判断收缩哪边</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxArea</span><span class="hljs-params">(<span class="hljs-type">int</span>[] height)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = height.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, area;<br>        <span class="hljs-keyword">while</span>(left &lt; right)&#123;<br>            area = Math.min(height[left], height[right]) * (right - left);<br>            max = Math.max(max, area);<br>            <span class="hljs-keyword">if</span>(height[left] &lt; height[right])&#123;<br>                left++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                right--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> max;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="接雨水"><a href="#接雨水" class="headerlink" title="接雨水"></a>接雨水</h5><blockquote><p>给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">trap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] height)</span> &#123;<br>        <span class="hljs-comment">// 下标i处的雨水由leftMax和rightMax决定</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = height.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">leftMax</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, rightMax = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(left &lt; right)&#123;<br>            leftMax = Math.max(leftMax, height[left]);<br>            rightMax = Math.max(rightMax, height[right]);<br>            <span class="hljs-keyword">if</span>(height[left] &lt; height[right])&#123;<br>                sum += leftMax - height[left];<br>                left++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                sum += rightMax - height[right];<br>                right--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="螺旋矩阵"><a href="#螺旋矩阵" class="headerlink" title="螺旋矩阵"></a>螺旋矩阵</h4><blockquote><p>给定一个正整数 n，生成一个包含 1 到 n^2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。<br>示例:<br>输入: 3 输出: [ [ 1, 2, 3 ], [ 8, 9, 4 ], [ 7, 6, 5 ] ]</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[][] generateMatrix(<span class="hljs-type">int</span> n) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, r = n - <span class="hljs-number">1</span>, t = <span class="hljs-number">0</span>, b = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span>[][] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][n];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> l; i &lt;= r; i++) res[t][i] = k++;<br>            <span class="hljs-keyword">if</span>(++t &gt; b) <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> t; i &lt;= b; i++) res[i][r] = k++;<br>            <span class="hljs-keyword">if</span>(--r &lt; l) <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> r; i &gt;= l; i--) res[b][i] = k++;<br>            <span class="hljs-keyword">if</span>(--b &lt; t) <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> b; i &gt;= t; i--) res[i][l] = k++;<br>            <span class="hljs-keyword">if</span>(++l &gt; r) <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><h4 id="链表的基本操作"><a href="#链表的基本操作" class="headerlink" title="链表的基本操作"></a>链表的基本操作</h4><h5 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a>移除元素</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">removeElements</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-comment">// 哨兵结点，对开始的结点分类讨论</span><br>        <span class="hljs-keyword">while</span>(head != <span class="hljs-literal">null</span> &amp;&amp; head.val == val)&#123;<br>            head = head.next;<br>        &#125;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">while</span>(cur != <span class="hljs-literal">null</span> &amp;&amp; cur.next != <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">if</span>(cur.next.val == val)&#123;<br>                cur.next = cur.next.next;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                cur = cur.next;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">reverseList</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head;<br>        ListNode temp, prev = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">while</span>(cur != <span class="hljs-literal">null</span>)&#123;<br>            temp = cur.next;<br>            cur.next = prev;<br>            prev = cur;<br>            cur = temp;<br>        &#125;<br>        <span class="hljs-keyword">return</span> prev;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="两两交换链表中的节点"><a href="#两两交换链表中的节点" class="headerlink" title="两两交换链表中的节点"></a>两两交换链表中的节点</h5><blockquote><p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。<br>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p></blockquote><p>使用递归算法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">swapPairs</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">if</span>(head.next == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> head;<br>        <span class="hljs-comment">// 递归</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> head.next;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">newNode</span> <span class="hljs-operator">=</span> swapPairs(head.next.next);<br>        next.next = head;<br>        head.next = newNode;<br>        <span class="hljs-keyword">return</span> next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="删除链表的倒数第N个节点"><a href="#删除链表的倒数第N个节点" class="headerlink" title="删除链表的倒数第N个节点"></a>删除链表的倒数第N个节点</h5><p>使用双指针</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">removeNthFromEnd</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">dum</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>, head);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> head, slow = dum;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            fast = fast.next;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(fast != <span class="hljs-literal">null</span>)&#123;<br>            fast = fast.next;<br>            slow = slow.next;<br>        &#125;<br>        slow.next = slow.next.next;<br>        <span class="hljs-keyword">return</span> dum.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="链表相交"><a href="#链表相交" class="headerlink" title="链表相交"></a>链表相交</h4><blockquote><p>给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。</p></blockquote><p>先遍历一遍得到长度，再对齐两个链表的指针，最后一起移动检查节点是否相等</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode(int x) &#123;</span><br><span class="hljs-comment"> *         val = x;</span><br><span class="hljs-comment"> *         next = null;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">getIntersectionNode</span><span class="hljs-params">(ListNode headA, ListNode headB)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">lenA</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, lenB = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">curA</span> <span class="hljs-operator">=</span> headA, curB = headB;<br>        <span class="hljs-keyword">while</span>(curA != <span class="hljs-literal">null</span>)&#123;<br>            curA = curA.next;<br>            lenA++;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(curB != <span class="hljs-literal">null</span>)&#123;<br>            curB = curB.next;<br>            lenB++;<br>        &#125;<br><br>        curA = headA; curB = headB;<br>        <span class="hljs-keyword">if</span>(lenA &gt; lenB)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; lenA - lenB; i++)&#123;<br>                curA = curA.next;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; lenB - lenA; i++)&#123;<br>                curB = curB.next;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">while</span>(curA != <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">if</span>(curA == curB)&#123;<br>                <span class="hljs-keyword">return</span> curA;<br>            &#125;<br>            curA = curA.next;<br>            curB = curB.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="环形链表"><a href="#环形链表" class="headerlink" title="环形链表"></a>环形链表</h4><blockquote><p>题意： 给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。<br>为了表示给定链表中的环，使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。<br>说明：不允许修改给定的链表。</p></blockquote><p>一个数学问题，双指针先双倍移动以判断环，再单倍移动以得到起始位置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode(int x) &#123;</span><br><span class="hljs-comment"> *         val = x;</span><br><span class="hljs-comment"> *         next = null;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">detectCycle</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> head, slow = head;<br>        <span class="hljs-keyword">while</span>(fast != <span class="hljs-literal">null</span> &amp;&amp; fast.next != <span class="hljs-literal">null</span>)&#123;<br>            fast = fast.next.next;<br>            slow = slow.next;<br>            <span class="hljs-keyword">if</span>(fast == slow)&#123;<br>                slow = head;<br>                <span class="hljs-keyword">while</span>(fast != slow)&#123;<br>                    fast = fast.next;<br>                    slow = slow.next;<br>                &#125;<br>                <span class="hljs-keyword">return</span> slow;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><h4 id="字母异位词分组"><a href="#字母异位词分组" class="headerlink" title="字母异位词分组"></a>字母异位词分组</h4><blockquote><p>给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。<br>字母异位词 是由重新排列源单词的所有字母得到的一个新单词。<br>示例:<br>输入: strs &#x3D; [“eat”, “tea”, “tan”, “ate”, “nat”, “bat”]<br>输出: [[“bat”],[“nat”,”tan”],[“ate”,”eat”,”tea”]]</p></blockquote><p>使用HashMap，键为排序后的str，值为str数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="hljs-title function_">groupAnagrams</span><span class="hljs-params">(String[] strs)</span> &#123;<br>        Map&lt;String, List&lt;String&gt;&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(String str : strs)&#123;<br>            <span class="hljs-type">char</span>[] s = str.toCharArray();<br>            Arrays.sort(s);<br>            <span class="hljs-comment">// 如果 Map 中没有键 new String(s)，则创建一个新的 ArrayList 并将其与键关联</span><br>            map.computeIfAbsent(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(s), k -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;()).add(str);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(map.values());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h4><blockquote><p>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。<br>你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。<br>你可以按任意顺序返回答案。</p></blockquote><p>使用HashMap记录差值和索引的键值对</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] twoSum(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target) &#123;<br>        Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++)&#123;<br>            <span class="hljs-keyword">if</span>(map.containsKey(nums[i]))&#123;<br>                res[<span class="hljs-number">0</span>] = map.get(nums[i]);<br>                res[<span class="hljs-number">1</span>] = i;<br>                <span class="hljs-keyword">return</span> res;<br>            &#125;<br>            map.put(target - nums[i], i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="四数相加"><a href="#四数相加" class="headerlink" title="四数相加"></a>四数相加</h5><blockquote><p>给你四个整数数组 nums1、nums2、nums3 和 nums4 ，数组长度都是 n ，请你计算有多少个元组 (i, j, k, l) 能满足：<br>0 &lt;&#x3D; i, j, k, l &lt; n<br>nums1[i] + nums2[j] + nums3[k] + nums4[l] &#x3D;&#x3D; 0</p></blockquote><p>类似于两数之和，将nums1和nums2视为一组，nums3和nums4视为一组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">fourSumCount</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span>[] nums2, <span class="hljs-type">int</span>[] nums3, <span class="hljs-type">int</span>[] nums4)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-comment">// nums1和nums2一组，nums3和nums4一组</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i : nums1)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j : nums2)&#123;<br>                map.put(i + j, map.getOrDefault(i + j, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i : nums3)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j : nums4)&#123;<br>                <span class="hljs-keyword">if</span>(map.containsKey(<span class="hljs-number">0</span> - i - j))&#123;<br>                    res += map.get(<span class="hljs-number">0</span> - i - j);<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a>三数之和</h5><blockquote><p>给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i !&#x3D; j、i !&#x3D; k 且 j !&#x3D; k ，同时还满足 nums[i] + nums[j] + nums[k] &#x3D;&#x3D; 0 。请你返回所有和为 0 且不重复的三元组。<br>注意：答案中不可以包含重复的三元组。</p></blockquote><p>使用双指针法更简单，先进行排序，再遍历数组，并使用left和right指向剩下的两个数字，注意题干中的去重<br>对于四数之和，直接两层循环，剩下两个数就可以用双指针了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">threeSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-comment">// 先排序，以使用双指针</span><br>        Arrays.sort(nums);<br><br>        <span class="hljs-type">int</span> left, right, sum;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i] &gt; <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">return</span> res;<br>            &#125;<br><br>            <span class="hljs-comment">// 去除重复三元组</span><br>            <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i - <span class="hljs-number">1</span>] == nums[i])&#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            left = i + <span class="hljs-number">1</span>;<br>            right = nums.length - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span>(left &lt; right)&#123;<br>                sum = nums[i] + nums[left] + nums[right];<br>                <span class="hljs-keyword">if</span>(sum &gt; <span class="hljs-number">0</span>)&#123;<br>                    right--;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sum &lt; <span class="hljs-number">0</span>)&#123;<br>                    left++;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    res.add(Arrays.asList(nums[i], nums[left], nums[right]));<br>                    <span class="hljs-comment">// 去重</span><br>                    <span class="hljs-keyword">while</span>(left &lt; right &amp;&amp; nums[left] == nums[left + <span class="hljs-number">1</span>])&#123;<br>                        left++;<br>                    &#125;<br>                    <span class="hljs-keyword">while</span>(left &lt; right &amp;&amp; nums[right] == nums[right - <span class="hljs-number">1</span>])&#123;<br>                        right--;<br>                    &#125;<br>                    left++;<br>                    right--;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><h4 id="翻转字符串里的单词"><a href="#翻转字符串里的单词" class="headerlink" title="翻转字符串里的单词"></a>翻转字符串里的单词</h4><blockquote><p>给定一个字符串，逐个翻转字符串中的每个单词。<br>示例 1：<br>输入: “the sky is blue”<br>输出: “blue is sky the”<br>示例 2：<br>输入: “  hello world!  “<br>输出: “world! hello”<br>解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。<br>示例 3：<br>输入: “a good   example”<br>输出: “example good a”<br>解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</p></blockquote><p>借助StringBuilder移除多余空格，将整个字符串反转，将每个单词反转</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">reverseWords</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> removeSpace(s);<br>        reverseString(sb, <span class="hljs-number">0</span>, sb.length() - <span class="hljs-number">1</span>);<br>        reverseEachWord(sb);<br>        <span class="hljs-keyword">return</span> sb.toString();<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> StringBuilder <span class="hljs-title function_">removeSpace</span><span class="hljs-params">(String s)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> s.length() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(s.charAt(start) == <span class="hljs-string">&#x27; &#x27;</span>) start++;<br>        <span class="hljs-keyword">while</span>(s.charAt(end) == <span class="hljs-string">&#x27; &#x27;</span>) end--;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-keyword">while</span>(start &lt;= end)&#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> s.charAt(start);<br>            <span class="hljs-keyword">if</span>(c != <span class="hljs-string">&#x27; &#x27;</span> || sb.charAt(sb.length() - <span class="hljs-number">1</span>) != <span class="hljs-string">&#x27; &#x27;</span>)&#123; <span class="hljs-comment">// 去除单词间的多余空格</span><br>                sb.append(c);<br>            &#125;<br>            start++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sb;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reverseString</span><span class="hljs-params">(StringBuilder sb, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span>&#123;<br>        <span class="hljs-keyword">while</span>(start &lt; end)&#123; <span class="hljs-comment">// 头尾交换</span><br>            <span class="hljs-type">char</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> sb.charAt(start);<br>            sb.setCharAt(start, sb.charAt(end));<br>            sb.setCharAt(end, temp);<br>            start++;<br>            end--;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reverseEachWord</span><span class="hljs-params">(StringBuilder sb)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; <span class="hljs-comment">// 双指针找到单词</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> sb.length();<br>        <span class="hljs-keyword">while</span>(start &lt; n)&#123;<br>            <span class="hljs-keyword">while</span>(end &lt; n &amp;&amp; sb.charAt(end) != <span class="hljs-string">&#x27; &#x27;</span>)&#123;<br>                end++;<br>            &#125;<br>            reverseString(sb, start, end - <span class="hljs-number">1</span>);<br>            start = end + <span class="hljs-number">1</span>;<br>            end = start + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="KMP算法——实现strStr"><a href="#KMP算法——实现strStr" class="headerlink" title="KMP算法——实现strStr()"></a>KMP算法——实现strStr()</h4><blockquote><p>实现 strStr() 函数。<br>给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回  -1。</p></blockquote><p>使用KMP算法，先根据回文计算next数组，再双指针，needle指针用于回溯</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">strStr</span><span class="hljs-params">(String haystack, String needle)</span> &#123;<br>        <span class="hljs-type">int</span>[] next = next(needle);<br>        <span class="hljs-comment">// 双指针分别指向两个字符串的匹配位，needle用于回溯，handle始终保持前移</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> haystack.length(), n = needle.length();<br>        <span class="hljs-keyword">while</span>((m - i) &gt;= (n - j))&#123;<br>            <span class="hljs-keyword">if</span>(haystack.charAt(i) == needle.charAt(j))&#123;<br>                i++; j++;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (j != <span class="hljs-number">0</span>)&#123;<br>                j = next[j - <span class="hljs-number">1</span>];<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                i++;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(j == n) &#123;<br>                <span class="hljs-keyword">return</span> i - j;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] next(String needle)&#123;<br>        <span class="hljs-type">int</span>[] next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[needle.length()];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">while</span>(j != needle.length())&#123;<br>            <span class="hljs-keyword">if</span>(needle.charAt(i) == needle.charAt(j))&#123;<br>                i++;<br>                next[j] = i; <span class="hljs-comment">// 回文有多少字符，而数组从0开始</span><br>                j++;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(i != <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-comment">// 回溯到已检查字符串的回文的下一位，进行检查匹配</span><br>                i = next[i - <span class="hljs-number">1</span>];<br>            &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 无法回溯，为默认值0</span><br>                j++;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="栈与队列"><a href="#栈与队列" class="headerlink" title="栈与队列"></a>栈与队列</h3><h4 id="用队列表示栈"><a href="#用队列表示栈" class="headerlink" title="用队列表示栈"></a>用队列表示栈</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyStack</span> &#123;<br>    Queue&lt;Integer&gt; q1;<br>    Queue&lt;Integer&gt; q2;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyStack</span><span class="hljs-params">()</span> &#123;<br>        q1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        q2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        <span class="hljs-comment">// 放在辅助队列使新加元素位于头部</span><br>        q2.offer(x);<br>        <span class="hljs-keyword">while</span>(!q1.isEmpty())&#123;<br>            q2.offer(q1.poll());<br>        &#125;<br>        <span class="hljs-comment">// 交换两队列的满空状态</span><br>        Queue&lt;Integer&gt; queueTemp;<br>        queueTemp = q1;<br>        q1 = q2;<br>        q2 = queueTemp;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> q1.poll();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">top</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> q1.peek();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">empty</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> q1.isEmpty();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MyStack object will be instantiated and called as such:</span><br><span class="hljs-comment"> * MyStack obj = new MyStack();</span><br><span class="hljs-comment"> * obj.push(x);</span><br><span class="hljs-comment"> * int param_2 = obj.pop();</span><br><span class="hljs-comment"> * int param_3 = obj.top();</span><br><span class="hljs-comment"> * boolean param_4 = obj.empty();</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h4 id="栈的应用——有效的括号"><a href="#栈的应用——有效的括号" class="headerlink" title="栈的应用——有效的括号"></a>栈的应用——有效的括号</h4><blockquote><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。<br>有效字符串需满足：<br>左括号必须用相同类型的右括号闭合。<br>左括号必须以正确的顺序闭合。<br>注意空字符串可被认为是有效字符串。</p></blockquote><p>使用栈匹配</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(String s)</span> &#123;<br>        Stack&lt;Character&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c : s.toCharArray())&#123;<br>            <span class="hljs-keyword">if</span>(c == <span class="hljs-string">&#x27;)&#x27;</span> &amp;&amp; !stack.isEmpty() &amp;&amp; stack.peek() == <span class="hljs-string">&#x27;(&#x27;</span>)&#123;<br>                stack.pop();<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(c == <span class="hljs-string">&#x27;]&#x27;</span> &amp;&amp; !stack.isEmpty() &amp;&amp; stack.peek() == <span class="hljs-string">&#x27;[&#x27;</span>)&#123;<br>                stack.pop();<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(c == <span class="hljs-string">&#x27;&#125;&#x27;</span> &amp;&amp; !stack.isEmpty() &amp;&amp; stack.peek() == <span class="hljs-string">&#x27;&#123;&#x27;</span>)&#123;<br>                stack.pop();<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                stack.push(c);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> stack.isEmpty();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="队列的应用——滑动窗口最大值"><a href="#队列的应用——滑动窗口最大值" class="headerlink" title="队列的应用——滑动窗口最大值"></a>队列的应用——滑动窗口最大值</h4><blockquote><p>给定一个数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。<br>返回滑动窗口中的最大值。</p></blockquote><p>实现一个单调递减的队列来peek最大值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyQueue</span> &#123; <span class="hljs-comment">// 该队列应当保证单调递减</span><br>    Deque&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">poll</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span>&#123; <span class="hljs-comment">// 只弹出最大值，其余值会自动消亡</span><br>        <span class="hljs-keyword">if</span>(!queue.isEmpty() &amp;&amp; val == queue.peek())&#123;<br>            queue.poll();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span>&#123;<br>        <span class="hljs-keyword">while</span>(!queue.isEmpty() &amp;&amp; val &gt; queue.getLast())&#123;<br>            queue.removeLast(); <span class="hljs-comment">// 抹除更小值保证单调递减</span><br>        &#125;<br>        queue.add(val);<br>    &#125;<br><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">peek</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> queue.peek();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] maxSlidingWindow(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k) &#123;<br>        <span class="hljs-keyword">if</span>(nums.length == <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> nums;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> nums.length - k + <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> res[] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[len];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">MyQueue</span> <span class="hljs-variable">queue</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyQueue</span>();<br>        <span class="hljs-comment">// 此时队列只有最大值及其后面的次大值，以此类推</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; k; i++)&#123;<br>            queue.add(nums[i]);<br>        &#125;<br>        res[num++] = queue.peek();<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> k; i &lt; nums.length; i++)&#123;<br>            queue.poll(nums[i - k]);<br>            queue.add(nums[i]);<br>            res[num++] = queue.peek();<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="优先级队列——前K个高级元素"><a href="#优先级队列——前K个高级元素" class="headerlink" title="优先级队列——前K个高级元素"></a>优先级队列——前K个高级元素</h4><blockquote><p>给定一个非空的整数数组，返回其中出现频率前 k 高的元素。</p></blockquote><p>先用HashMap记录键值对，再用优先级队列排序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] topKFrequent(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k) &#123;<br>        Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> num : nums)&#123;<br>            map.put(num, map.getOrDefault(num, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-comment">// 一个大顶堆</span><br>        PriorityQueue&lt;<span class="hljs-type">int</span>[]&gt; pq = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;((pair1, pair2) -&gt; pair2[<span class="hljs-number">1</span>] - pair1[<span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">for</span>(Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet())&#123;<br>            pq.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;entry.getKey(), entry.getValue()&#125;);<br>        &#125;<br><br>        <span class="hljs-type">int</span>[] ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[k];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; k; i++)&#123;<br>            ans[i] = pq.poll()[<span class="hljs-number">0</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><h4 id="二叉树的基本操作"><a href="#二叉树的基本操作" class="headerlink" title="二叉树的基本操作"></a>二叉树的基本操作</h4><h5 id="二叉树的非递归遍历"><a href="#二叉树的非递归遍历" class="headerlink" title="二叉树的非递归遍历"></a>二叉树的非递归遍历</h5><p>以后序遍历为例，使用栈来辅助</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">postorderTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br><br>        Stack&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        stack.push(root);<br>        <span class="hljs-keyword">while</span>(!stack.isEmpty())&#123;<br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> stack.pop();<br>            res.add(cur.val);<br>            <span class="hljs-keyword">if</span>(cur.left != <span class="hljs-literal">null</span>)&#123;<br>                stack.push(cur.left);<br>            &#125;<br>            <span class="hljs-keyword">if</span>(cur.right != <span class="hljs-literal">null</span>)&#123;<br>                stack.push(cur.right);<br>            &#125;<br>        &#125;<br>        Collections.reverse(res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="二叉树的层序遍历"><a href="#二叉树的层序遍历" class="headerlink" title="二叉树的层序遍历"></a>二叉树的层序遍历</h5><p>递归或借助队列实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();<br><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">levelOrder</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-comment">// bfs(root);</span><br>        recursive(root, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-comment">// 递归</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">recursive</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> depth)</span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br>        depth++;<br><br>        <span class="hljs-keyword">if</span>(res.size() &lt; depth)&#123;<br>            List&lt;Integer&gt; item = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>            res.add(item);<br>        &#125;<br>        res.get(depth - <span class="hljs-number">1</span>).add(root.val);<br>        <br>        recursive(root.left, depth);<br>        recursive(root.right, depth);<br>    &#125;<br><br>    <span class="hljs-comment">// 借助队列</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">bfs</span><span class="hljs-params">(TreeNode root)</span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br>        Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;TreeNode&gt;();<br>        queue.offer(root);<br><br>        <span class="hljs-keyword">while</span>(!queue.isEmpty())&#123;<br>            List&lt;Integer&gt; item = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> queue.size();<br><br>            <span class="hljs-keyword">while</span>(len &gt; <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-type">TreeNode</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> queue.poll();<br>                item.add(temp.val);<br><br>                <span class="hljs-keyword">if</span>(temp.left != <span class="hljs-literal">null</span>)&#123;<br>                    queue.offer(temp.left);<br>                &#125;<br>                <span class="hljs-keyword">if</span>(temp.right != <span class="hljs-literal">null</span>)&#123;<br>                    queue.offer(temp.right);<br>                &#125;<br><br>                len--;<br>            &#125;<br><br>            res.add(item);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="翻转二叉树"><a href="#翻转二叉树" class="headerlink" title="翻转二叉树"></a>翻转二叉树</h5><p>递归交换左右孩子即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">invertTree</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        invertTree(root.left);<br>        invertTree(root.right);<br>        swapChildren(root);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swapChildren</span><span class="hljs-params">(TreeNode root)</span>&#123;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> root.left;<br>        root.left = root.right;<br>        root.right = temp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="二叉树的所有路径"><a href="#二叉树的所有路径" class="headerlink" title="二叉树的所有路径"></a>二叉树的所有路径</h5><blockquote><p>给定一个二叉树，返回所有从根节点到叶子节点的路径。</p></blockquote><p>递归时同时带上path用于记录到达当前节点的路径</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;String&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">binaryTreePaths</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-comment">// recursive(root, &quot;&quot;);</span><br>        byStack(root);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-comment">// 递归法</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">recursive</span><span class="hljs-params">(TreeNode root, String path)</span>&#123; <span class="hljs-comment">// path表示到达该节点的路径</span><br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span>(root.left == <span class="hljs-literal">null</span> &amp;&amp; root.right == <span class="hljs-literal">null</span>)&#123; <span class="hljs-comment">// 叶子节点</span><br>            res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(path).append(root.val).toString());<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">newPath</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(path).append(root.val).append(<span class="hljs-string">&quot;-&gt;&quot;</span>).toString();<br>        recursive(root.left, newPath);<br>        recursive(root.right, newPath);<br>    &#125;<br><br>    <span class="hljs-comment">// 迭代法</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">byStack</span><span class="hljs-params">(TreeNode root)</span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br>        Stack&lt;Object&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        <span class="hljs-comment">// 节点和路径同时入栈</span><br>        stack.push(root);<br>        stack.push(root.val + <span class="hljs-string">&quot;&quot;</span>);<br>        <span class="hljs-keyword">while</span>(!stack.isEmpty())&#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> (String) stack.pop();<br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> (TreeNode) stack.pop();<br>            <span class="hljs-keyword">if</span>(cur.left == <span class="hljs-literal">null</span> &amp;&amp; cur.right == <span class="hljs-literal">null</span>)&#123;<br>                <span class="hljs-comment">// 叶子节点</span><br>                res.add(path);<br>            &#125;<br>            <span class="hljs-keyword">if</span>(cur.left != <span class="hljs-literal">null</span>)&#123;<br>                stack.push(cur.left);<br>                stack.push(path + <span class="hljs-string">&quot;-&gt;&quot;</span> + cur.left.val);<br>            &#125;<br>            <span class="hljs-keyword">if</span>(cur.right != <span class="hljs-literal">null</span>)&#123;<br>                stack.push(cur.right);<br>                stack.push(path + <span class="hljs-string">&quot;-&gt;&quot;</span> + cur.right.val);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="从中序遍历与后序遍历序列构造二叉树"><a href="#从中序遍历与后序遍历序列构造二叉树" class="headerlink" title="从中序遍历与后序遍历序列构造二叉树"></a>从中序遍历与后序遍历序列构造二叉树</h5><blockquote><p>给定两个整数数组 inorder 和 postorder ，其中 inorder 是二叉树的中序遍历， postorder 是同一棵树的后序遍历，请你构造并返回这颗 二叉树 。</p></blockquote><p>root在后序遍历最后一个节点，以此切割中序序列（用map记录键值对来查找），再根据左右子树的长度切割后序序列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    Map&lt;Integer, Integer&gt; map;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">buildTree</span><span class="hljs-params">(<span class="hljs-type">int</span>[] inorder, <span class="hljs-type">int</span>[] postorder)</span> &#123;<br>        map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; inorder.length; i++)&#123;<br>            map.put(inorder[i], i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> findNode(inorder, <span class="hljs-number">0</span>, inorder.length - <span class="hljs-number">1</span>, postorder, <span class="hljs-number">0</span>, postorder.length - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 表示下标范围</span><br>    <span class="hljs-keyword">private</span> TreeNode <span class="hljs-title function_">findNode</span><span class="hljs-params">(<span class="hljs-type">int</span>[] inorder, <span class="hljs-type">int</span> inLeft, <span class="hljs-type">int</span> inRight, <span class="hljs-type">int</span>[] postorder, <span class="hljs-type">int</span> postLeft, <span class="hljs-type">int</span> postRight)</span>&#123;<br>        <span class="hljs-keyword">if</span>(inLeft &gt; inRight || postLeft &gt; postRight) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-comment">// 找到后序遍历最后一个元素在中序遍历位置</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">rootIndex</span> <span class="hljs-operator">=</span> map.get(postorder[postRight]);<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(inorder[rootIndex]);<br>        <span class="hljs-comment">// 在中序遍历和后序遍历中，左子树是等长的</span><br>        <span class="hljs-comment">// 使用root下表切割中序序列</span><br>        root.left = findNode(inorder, inLeft, rootIndex - <span class="hljs-number">1</span>, postorder, postLeft, postLeft + rootIndex - <span class="hljs-number">1</span> - inLeft);<br>        root.right = findNode(inorder, rootIndex + <span class="hljs-number">1</span>, inRight, postorder, postLeft + rootIndex - inLeft, postRight - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="二叉树的最近公共祖先"><a href="#二叉树的最近公共祖先" class="headerlink" title="二叉树的最近公共祖先"></a>二叉树的最近公共祖先</h5><blockquote><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。<br>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">lowestCommonAncestor</span><span class="hljs-params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;<br>        <span class="hljs-comment">// 使用后序遍历实现自底向上</span><br>        <span class="hljs-comment">// 只返回p,q或者null,或者二者的公共祖先</span><br>        <span class="hljs-keyword">if</span>(root == p || root == q || root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> root;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> lowestCommonAncestor(root.left, p, q);<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> lowestCommonAncestor(root.right, p, q);<br>        <span class="hljs-comment">// 左右分别有p,q,说明为公共祖先，返回自己</span><br>        <span class="hljs-keyword">if</span>(left != <span class="hljs-literal">null</span> &amp;&amp; right != <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> root;<br>        <span class="hljs-comment">// 只有左边不为null,说明要么p,q没有都找到，要么left为公共祖先，返回left</span><br>        <span class="hljs-keyword">if</span>(left != <span class="hljs-literal">null</span> &amp;&amp; right == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> left;<br>        <span class="hljs-keyword">if</span>(left == <span class="hljs-literal">null</span> &amp;&amp; right != <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> right;<br>        <span class="hljs-comment">//p,q都没找到，返回null</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h4><h5 id="验证二叉搜索树"><a href="#验证二叉搜索树" class="headerlink" title="验证二叉搜索树"></a>验证二叉搜索树</h5><blockquote><p>给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。<br>有效 二叉搜索树定义如下：<br>节点的左子树只包含 小于 当前节点的数。<br>节点的右子树只包含 大于 当前节点的数。<br>所有左子树和右子树自身必须也是二叉搜索树。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">TreeNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">// 记录中序遍历的前一个节点，从而得到左子树的最大值</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValidBST</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-comment">// 中序遍历</span><br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> isValidBST(root.left);<br>        <span class="hljs-keyword">if</span>(pre != <span class="hljs-literal">null</span> &amp;&amp; pre.val &gt;= root.val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        pre = root;<br>        <span class="hljs-keyword">return</span> left &amp;&amp; isValidBST(root.right);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="二叉搜索树中的插入操作"><a href="#二叉搜索树中的插入操作" class="headerlink" title="二叉搜索树中的插入操作"></a>二叉搜索树中的插入操作</h5><blockquote><p>给定二叉搜索树（BST）的根节点 root 和要插入树中的值 value ，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据 保证 ，新值和原始二叉搜索树中的任意节点值都不同。<br>注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回 任意有效的结果 。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">TreeNode</span> <span class="hljs-variable">parent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">insertIntoBST</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) root = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(val);<br>        recursive(root, val);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">recursive</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> val)</span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-comment">// 落到底部，可以插入</span><br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(val);<br>            <span class="hljs-keyword">if</span>(val &lt; parent.val) parent.left = cur;<br>            <span class="hljs-keyword">else</span> parent.right = cur;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        parent = root;<br>        <span class="hljs-keyword">if</span>(val &lt; root.val) recursive(root.left, val);<br>        <span class="hljs-keyword">if</span>(val &gt; root.val) recursive(root.right, val);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="删除二叉搜索树中的节点"><a href="#删除二叉搜索树中的节点" class="headerlink" title="删除二叉搜索树中的节点"></a>删除二叉搜索树中的节点</h5><blockquote><p>给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。</p></blockquote><p>分情况讨论</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">deleteNode</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> key)</span> &#123;<br>        <span class="hljs-comment">// 1.没找到节点，返回null</span><br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> root;<br>        <br>        <span class="hljs-keyword">if</span>(root.val == key)&#123;<br>            <span class="hljs-comment">// 2.左右子树都为空，直接删除</span><br>            <span class="hljs-keyword">if</span>(root.left == <span class="hljs-literal">null</span> &amp;&amp; root.right == <span class="hljs-literal">null</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            &#125;<br>            <span class="hljs-comment">// 3.左子树为空，将右子树拉上来拼接</span><br>            <span class="hljs-keyword">if</span>(root.left == <span class="hljs-literal">null</span>)&#123;<br>                <span class="hljs-keyword">return</span> root.right;<br>            &#125;<br>            <span class="hljs-comment">// 4.右子树为空，类似</span><br>            <span class="hljs-keyword">if</span>(root.right == <span class="hljs-literal">null</span>)&#123;<br>                <span class="hljs-keyword">return</span> root.left;<br>            &#125;<br>            <span class="hljs-comment">// 5.左右子树都不为空，将左子树拼接到右子树最左边节点的左孩子上</span><br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> root.right;<br>            <span class="hljs-keyword">while</span>(cur.left != <span class="hljs-literal">null</span>)&#123;<br>                cur = cur.left;<br>            &#125;<br>            cur.left = root.left;<br>            root = root.right;<br>            <span class="hljs-keyword">return</span> root;<br>        &#125;<br>        <span class="hljs-comment">// 拼接与回溯</span><br>        <span class="hljs-keyword">if</span>(key &lt; root.val) root.left = deleteNode(root.left, key);<br>        <span class="hljs-keyword">if</span>(key &gt; root.val) root.right = deleteNode(root.right, key);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
      <category>代码随想录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>试着发布第一个帖子</title>
    <link href="/2025/05/26/%E8%AF%95%E7%9D%80%E5%8F%91%E5%B8%83%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%B8%96%E5%AD%90/"/>
    <url>/2025/05/26/%E8%AF%95%E7%9D%80%E5%8F%91%E5%B8%83%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%B8%96%E5%AD%90/</url>
    
    <content type="html"><![CDATA[<p>这是我的第一个博客，我的博客会记录以下内容：</p><ul><li>魔禁读后感</li><li>csdiy学习记录</li><li>一些生活记录贴</li></ul><p>欢迎访问本博客的大家交流呀！</p>]]></content>
    
    
    <categories>
      
      <category>吹水</category>
      
    </categories>
    
    
    <tags>
      
      <tag>water</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2025/05/26/hello-world/"/>
    <url>/2025/05/26/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
