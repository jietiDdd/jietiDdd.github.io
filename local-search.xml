<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>CSE_lecture27:Distributed Training</title>
    <link href="/2026/01/01/CSE-lecture27-Distributed-Training/"/>
    <url>/2026/01/01/CSE-lecture27-Distributed-Training/</url>
    
    <content type="html"><![CDATA[<h2 id="Distributed-Computing-frameworks-MapReduce-computation-graph-Distributed-training"><a href="#Distributed-Computing-frameworks-MapReduce-computation-graph-Distributed-training" class="headerlink" title="Distributed Computing frameworks: MapReduce, computation graph &amp; Distributed training"></a>Distributed Computing frameworks: MapReduce, computation graph &amp; Distributed training</h2><p>MapReduce也有其局限性：</p><ul><li>单个MapReduce难以实现排序等应用，因此使用多个MapReduce并串联在一起</li><li>chaining multiple MapReduce tasks并不是好的解决方法，因为需要拆分，同时容错难度上升，且在任务之前存在反复写入GFS的开销</li></ul><h3 id="from-MapReduce-to-DAG-computation-graph"><a href="#from-MapReduce-to-DAG-computation-graph" class="headerlink" title="from MapReduce to DAG(computation graph)"></a>from MapReduce to DAG(computation graph)</h3><p>计算图相当于将任务和数据抽象成节点，构成有向无环图，此时Reducer知道哪些节点需要它的output，因此只需要放在内存即可，不用访问GFS，减小开销</p><img src="/2026/01/01/CSE-lecture27-Distributed-Training/1af6d7b66a8677357c192dc4f7c0dcb4.png" class="" title="DAG"><p>不存在依赖关系的节点可以并行计算</p><p>DAG的容错更加复杂，需要级联的恢复。对于小型计算任务，优先使用re-execution；对于大型计算任务，优先使用checkpoint</p><p>DAG看似比MapReduce更通用，但不同应用的并行度不一样，怎么生成高并行度的DAG也不一样</p><h4 id="how-to-express-AI-program-to-distributed-framework-dataflow-graph"><a href="#how-to-express-AI-program-to-distributed-framework-dataflow-graph" class="headerlink" title="how to express AI program to distributed framework? dataflow graph"></a>how to express AI program to distributed framework? dataflow graph</h4>]]></content>
    
    
    <categories>
      
      <category>计算机学习</category>
      
      <category>se专业课</category>
      
      <category>cse</category>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>se</tag>
      
      <tag>cse</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSE_lecture26:GPUs and MapReduce</title>
    <link href="/2026/01/01/CSE-lecture26-GPUs-and-MapReduce/"/>
    <url>/2026/01/01/CSE-lecture26-GPUs-and-MapReduce/</url>
    
    <content type="html"><![CDATA[<h2 id="The-distributed-and-parallel-programming-on-a-single-device-MapReduce"><a href="#The-distributed-and-parallel-programming-on-a-single-device-MapReduce" class="headerlink" title="The distributed (and parallel) programming on a single device &amp; MapReduce"></a>The distributed (and parallel) programming on a single device &amp; MapReduce</h2><h3 id="from-single-device-to-a-distributed-computing"><a href="#from-single-device-to-a-distributed-computing" class="headerlink" title="from single device to a distributed computing"></a>from single device to a distributed computing</h3><p>单芯片的性能增长已经非常有限，因此引入分布式计算，使用很多张卡。但分布式计算在编程时需要考虑更多情况，因此使用分布式计算框架，让算法工程师不用自行考虑分布式计算的细节问题</p><p>对于数据中心，为了统计网站访问量，需要记录巨大的log，现在的任务是找到其中最热的网页推荐给用户。对于单机系统，使用单线程的命令行指令即可找到；而对于海量的log entry只能使用分布式，使用RPC分区并将计算分发给多台设备。难点在于：怎么高效地传输海量数据，怎么在带宽受限时高效地回收RPC，怎么应对设备出错，以及根据设备状态合理实现分区平衡</p><p>因此要解决的问题有：</p><ul><li>在节点间高效传数据</li><li>节点协调同步</li><li>容错</li><li>使用locality减少数据传输</li><li>充分利用资源，即平衡快慢设备</li></ul><h3 id="MapReduce-simplified-data-processing-on-large-clusters"><a href="#MapReduce-simplified-data-processing-on-large-clusters" class="headerlink" title="MapReduce: simplified data processing on large clusters"></a>MapReduce: simplified data processing on large clusters</h3><p>MapReduce是一种distributed batch processing system，使用函数式编程，其并行度很高：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs LISP">Map(<span class="hljs-name">function</span>, set of values)<br>Reduce(<span class="hljs-name">function</span>, set of values)<br></code></pre></td></tr></table></figure><p>Map将function作用于set的每个value，Reduce使用function将所有value结合在一起：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs LISP">(<span class="hljs-name">map</span> #&#x27;length&#x27; (() (<span class="hljs-name">a</span>) (<span class="hljs-name">a</span> b) (<span class="hljs-name">a</span> b c))) -&gt; (<span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>)<br>(<span class="hljs-name">reduce</span> #&#x27;+&#x27; (<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span>)) -&gt; <span class="hljs-number">15</span><br></code></pre></td></tr></table></figure><p>只要用户将操作分为Map和Reduce（其中Reduce可以使用Map后的数据），底层就可以优化前面提到的问题：</p><ul><li>在节点间高效传数据：根据数据被用于Map还是Reduce来进行优化，如将Map放在GFS节点上，Reduce放在Map机房</li><li>节点协调同步：Reducer在Mapper后调度</li><li>容错：函数是无状态的，重做即可</li><li>使用locality减少数据传输：根据数据的位置，将Map和Reduce放在同一机器</li><li>充分利用资源，即平衡快慢设备：将慢机器上的Map任务分配给快机器即可，但Reduce对并行不友好</li></ul><p>google的MapReduce进一步优化，Map的结果为kv对，此时Reduce根据key来进行分区，从而实现Reduce的并行</p><p>有了MapReduce后，用户只需要考虑算法即可</p><p>如对于word count，MapReduce可以这样设计：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">Map (<span class="hljs-built_in">input</span>) <span class="hljs-comment"># a shard of file</span><br><span class="hljs-keyword">for</span> each word w <span class="hljs-keyword">in</span> <span class="hljs-built_in">input</span><br>    EmitIntermediate (w, <span class="hljs-string">&quot;1&quot;</span>);<br><br>Reduce (String key, Iterator values)<br>    <span class="hljs-built_in">int</span> result = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> each v <span class="hljs-keyword">in</span> values<br>        result += ParseInt (v);<br>    emit (AsString (result));<br></code></pre></td></tr></table></figure><p>MapReduce的执行流为：</p><ul><li>Map Worker:<ul><li>Map: 数据分片为shard后调用Map函数，生成键值对</li><li>Partition: 调用分区函数，根据key将数据分配给不同的Reducer，实现负载均衡</li></ul></li><li>Reduce Worker:<ul><li>Sort: 对键排序，从而将同一个键的值聚合在一起</li><li>Reduce: 对相同键对应的值进行聚合操作，得到最终结果</li></ul></li></ul><img src="/2026/01/01/CSE-lecture26-GPUs-and-MapReduce/2e76abf49df20b56ce463485e30fc157.png" class="" title="MapReduce"><ul><li>step1: 对文件分片为shard，从而分配给不同的Map Reducer，在GFS场景下为64MB，适配chunk size，降低RPC通信次数，并保证并行度</li><li>step2: 在集群上分配出一个master和多个workers，即remote fork</li><li>step3: 将shard发送给Map Worker，并调用Map函数，生成的键值对暂存在内存中</li><li>step4: 生成IF(intermediate files)，分为多个partition，这是根据分区函数划分的</li><li>step5: Reducer Worker根据分区从Map Worker中获取数据。为了防止数据过多使Reducer Worker内存溢出，需要进行排序，只需要将同一个key的值都拿过来，不需要一次性拿走所有的key</li><li>step6: Reducer Worker进行聚合并直接输出结果</li></ul><p>MapReduce需要进行容错，不需要用户进行log标记（类似于transaction)，并提供GFS，其可以抽象成不会挂的文件系统：</p><ul><li>Worker failure: 类似于raft使用log将会导致性能很差，因此直接进行重做(re-execution)即可，因为Map和Reduce是无状态的，且不会被用户感知</li><li>Master failure: 重做不是一个好的策略，因为时间开销过大。使用高的checkpoint记录中间状态即可</li><li>bad records: 可能因为用户提供的Map或Reduce本身出错，当反复挂时，直接跳过</li></ul><p>locality用于减少网络访问，需要将计算放在离存储更近的地方。而google的计算节点也是GFS chunkserver，而Reducer在Mapper的数据获取可以通过整形规划来进行优化</p><p>对于负载均衡，由于任务可以重做，因此采取first win即可</p>]]></content>
    
    
    <categories>
      
      <category>计算机学习</category>
      
      <category>se专业课</category>
      
      <category>cse</category>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>se</tag>
      
      <tag>cse</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSE_lecture25:GPUs and FlashAttention</title>
    <link href="/2026/01/01/CSE-lecture25-GPUs-and-FlashAttention/"/>
    <url>/2026/01/01/CSE-lecture25-GPUs-and-FlashAttention/</url>
    
    <content type="html"><![CDATA[<h2 id="More-on-GPUs-tiling-and-FlashAttention"><a href="#More-on-GPUs-tiling-and-FlashAttention" class="headerlink" title="More on GPUs, tiling and FlashAttention"></a>More on GPUs, tiling and FlashAttention</h2><h3 id="case-study-GPU"><a href="#case-study-GPU" class="headerlink" title="case study: GPU"></a>case study: GPU</h3><p>GPU的基础单元为SM，每个SM上有多个warp，在同一个warp上都会执行同一个指令，有32个SIMD线程</p><p>现代GPU，如H100，引入了tensor core，即脉冲阵列；同时core变得更具体，定制浮点数计算；还降低了用于图形学的SFU数量。但整体架构没有很大区别</p><p>SIMT使得多核程序也能在GPU上运行，thread会group成thread block，使得它们能够运行在同一个SM上，便于同步；一个grid（一个应用）包含了多个thread block</p><p>GPU的thread数量被定死，但用户可以使用任意数量的thread，只需要将其划分成多个thread block，GPU会根据SM数均分thread block；而每个thread block也会被拆分成多个wrap</p><p>GPU的存储为memory hierarchy，每个wrap有自己的register file和自己的cache，访问register的cycle数少，而访问cache和DRAM会逐层增多</p><p>在同一个warp的所有thread共享相同的program counter，因此这些线程同一时间只能做同一件事。当遇到control flow时，需要使用masking，但可能导致CUDA程序出现死锁问题</p><p>现代GPU不会再出现死锁问题，因为每个ALU有自己的PC，但这些thread还是共享相同的decoder，在不同thread可以执行不同分支的情况下，尽可能让它们还是跑同一指令</p><p>thread block的优点在于可以让里面的thread共享SM上的shared memory，同时可以方便进行thread之间的同步。而访问global memory将会很耗时，即cycle数很多的同时bandwidth也很小，同时load unit很少</p><h3 id="example-revisited-vector-add"><a href="#example-revisited-vector-add" class="headerlink" title="example revisited: vector add"></a>example revisited: vector add</h3><p>向量相加很适合GPU进行并行计算。为了知道当前线程操作的数据位置i，需要确定自己是哪个thread block idx的第几个线程：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">__global__ <span class="hljs-type">void</span> <span class="hljs-title">vecAddKernal</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">float</span>* A, <span class="hljs-type">const</span> <span class="hljs-type">float</span>* B, <span class="hljs-type">float</span>* C, <span class="hljs-type">int</span> n)</span></span>&#123;<br>    i = blockDim.x + blockIdx.x + threadIdx.x<br>    <span class="hljs-keyword">if</span> (i &lt; n)&#123;<br>        C[i] = A[i] + B[i];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>但这种计算方式性能很差，即受限于访存</p><p>两个向量的存储有两种类型，行存和列存：</p><img src="/2026/01/01/CSE-lecture25-GPUs-and-FlashAttention/a38b3f47eec12e84cf72968ab1e9e4bb.png" class="" title="memory layout"><p>由于一次读取会将多个byte读取上来，因此列存的访存次数更少，缺点是需要进行一次列存的转换</p><h3 id="optimizing-attention-computation-analysis-from-a-memory-access-perspective"><a href="#optimizing-attention-computation-analysis-from-a-memory-access-perspective" class="headerlink" title="optimizing attention computation: analysis from a memory access perspective"></a>optimizing attention computation: analysis from a memory access perspective</h3><img src="/2026/01/01/CSE-lecture25-GPUs-and-FlashAttention/5fe634429ba80aa504ac7a28da69748b.png" class="" title="attention basics 1"><img src="/2026/01/01/CSE-lecture25-GPUs-and-FlashAttention/cb2b3e1fe3c4f240439e7c9a66a1eecd.png" class="" title="attention basics 2"><img src="/2026/01/01/CSE-lecture25-GPUs-and-FlashAttention/c7e349232804a7231bd0ff7e92f08641.png" class="" title="attention basics 3"><p>除了softmax的核心均为矩阵乘法，因此重点优化矩阵乘法，而矩阵乘法的FLOPS数量级为 $O(n^3)$</p><p>受限于带宽，在访存时为了加速，尽量访问SRAM（如registered files），而减少HBM（如global memory）的访问</p><p>对于矩阵A(N*K)和B(K*M)相乘得到C(N*M)，要尽可能控制内存访问。假设一次内存读取会读上来BB个bytes，且为行存</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">0.</span>.N:<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-number">0.</span>.M:<br>        <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-number">0.</span>.K:<br>            HBM_read(A[i][k]) <br>            HBM_read(B[k][j])<br>            C[i][j] += A[i][k] * B[k][j]<br>        HBM_write(C[i][j])<br></code></pre></td></tr></table></figure><p>这个简单的实现没有利用一次读取BB个bytes的特性，因此的数量级为 $O(NMK*BB)$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">0.</span>.N:<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-number">0.</span>.M:<br>        <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-number">0.</span>.K:<br>            <span class="hljs-keyword">if</span> k % BB == <span class="hljs-number">0</span>:<br>                HBM_read(A[i][k]) <span class="hljs-comment"># will read A[i][k:k+BB] </span><br>            HBM_read(B[k][j]<br>            C[i][j] += A[i][k] * B[k][j]<br>    <span class="hljs-keyword">if</span> j % BB == <span class="hljs-number">0</span>:<br>        HBM_write(C[i][j]) <span class="hljs-comment"># will write C[i][j:j+BB]</span><br></code></pre></td></tr></table></figure><p>这个代码利用了访存优化，但受限于B矩阵按列读取，故数量级依然为 $O(NMK*BB)$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">0.</span>.N:<br>    <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-number">0.</span>.K:<br>        HBM_read(A[i][k])<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-number">0.</span>.M:<br>            <span class="hljs-keyword">if</span> j % BB == <span class="hljs-number">0</span>:<br>                HBM_read(B[k][j])<br>                HBM_read(C[i][j])<br>            C[i][j] += A[i][k] * B[k][j]<br>        <span class="hljs-keyword">if</span> j % BB == <span class="hljs-number">0</span>: <br>            HBM_write(C[i][j])<br></code></pre></td></tr></table></figure><p>通过交换j和k的循环，使得B矩阵也是按行读取的，从而可以利用到访存优化，数量级降低到 $O(NMK)$</p><p>使用tiling进一步降低访存次数，即将矩阵乘法进行分块</p><img src="/2026/01/01/CSE-lecture25-GPUs-and-FlashAttention/3377a5aef1b70acc1690cd38088508a9.png" class="" title="tiling"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">0.</span>.N/BN.step(BN):<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-number">0.</span>.M/BM.step(BM):<br>        <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-number">0.</span>.K/BK.step(BK):<br>            load(A[i:i+BN][k:k+BK])<br>            load(B[k+BK][j:j+BM])<br>            C[i:i+BN][j:j+BM] += A[i:i+BN][k:k+BK] * B[k+BK][j:j+BM]<br>        write(C[i:i+BN][j:j+BM])<br></code></pre></td></tr></table></figure><p>此时访存次数为：$O(\frac{N}{BN} \times \frac{M}{BM} + 2 \times \frac{N}{BN} \times \frac{M}{BM} \times \frac{K}{BK})$，进一步下降。当然这些数据应当放在SRAM上，因为SRAM有20MB，足够放下</p><p>tiling可以更改i, j, k的顺序，其改变的是分母的因子</p><p>使用auto tuning来选择最为合适的BM, BN, BK</p><p>在attention中，由于N远大于d，在tiling情况下，认为矩阵乘法和softmax的访存复杂度约为 $O(n^2)$，因此性能受限于上下文长度</p><p>flash attention进一步优化复杂度，即对attention的多步操作进行合并</p><p>忽略softmax，则只用考虑 $QK^TV$，这可以进一步优化复杂度：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">0.</span>.N/BQ.step(BQ):  <span class="hljs-comment">## Iterate over the Q</span><br>    load(Q[i:i + BQ , <span class="hljs-number">0</span>:d])<br>    write(O[i:i + BQ , <span class="hljs-number">0</span>:d])<br>    O[i:i + BQ , <span class="hljs-number">0</span>:d] = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-number">0.</span>.N/BK.step(BK):<br>         load(KT[<span class="hljs-number">0</span>:d,j:j+ BK ])<br>         load(V[j:j+ BK, <span class="hljs-number">0</span>:d])<br>         O[i:i+BQ ,<span class="hljs-number">0</span>:d] += Q[i:i+BQ,<span class="hljs-number">0</span>:d] * KT[<span class="hljs-number">0</span>:d,j:j+ BK ] * V[j:j+ BK, <span class="hljs-number">0</span>:d] <br>      write(O[i:i + BQ , <span class="hljs-number">0</span>:d])<br></code></pre></td></tr></table></figure><p>假设GPU缓存量大小为：$M \sim &#x3D; B_Q * d$，那么复杂度为：$O(\frac{N^2d^2}{M})$，而d往往远小于B_Q</p><p>现在将softmax考虑进来，使用online softmax来优化归一化需要整行值的问题</p>]]></content>
    
    
    <categories>
      
      <category>计算机学习</category>
      
      <category>se专业课</category>
      
      <category>cse</category>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>se</tag>
      
      <tag>cse</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSE_lecture24:distributed computing</title>
    <link href="/2025/12/31/CSE-lecture24-distributed-computing/"/>
    <url>/2025/12/31/CSE-lecture24-distributed-computing/</url>
    
    <content type="html"><![CDATA[<h2 id="The-distributed-and-parallel-programming-it’s-all-about-scalability"><a href="#The-distributed-and-parallel-programming-it’s-all-about-scalability" class="headerlink" title="The distributed (and parallel) programming: it’s all about scalability"></a>The distributed (and parallel) programming: it’s all about scalability</h2><p>训练模型的计算分为两步：前向传播和反向传播</p><p>对于前向传播，每层计算 $Y &#x3D; W \circ X$，假设：</p><p>$W: m \times k \ X: k \times B$</p><p>则近似的计算量为 $(2k - 1) \times m \times B \sim &#x3D; 2 \times Size(W) * B$，对于前向传播的所有层求和即可：$2 * B * parameters$</p><p>对于反向传播，每层计算 $dX &#x3D; W \circ dY (k \times m \circ m \times B)$ 和 $dW &#x3D; dY \circ XT(m \times B \circ B \times k)$，则dX计算量为：$(2m - 1) \times k \times B \sim &#x3D; 2 \times Size(W) * B$，dW的计算量为：$(2B - 1) \times m \times k \sim &#x3D; 2 \times Size(W) * B$，对所有层求和即可：$4 * B * parameters$</p><p>综上，一次训练的计算量为：$6 * parameters * Batch_size$</p><p>并行计算可以提高计算的规模</p><h3 id="single-chip-device"><a href="#single-chip-device" class="headerlink" title="single chip device"></a>single chip device</h3><p>对于CPU而言，每秒能做多少次浮点计算(FLOPS)，取决于每秒能给ALU提供多少指令，即clock rate；也取决于流水线，从而充分把clock rate利用起来。理想状况下没有bubble，此时FLOPS约为clock rate</p><p>对于单核CPU，为了提升并行度，需要提高pipeline的并行度，更深的pipeline的bubble更少；超标量（即指令级并行，ILP）每次发射多条指令，尽可能让它们并行计算，但超标量不能太大，否则复杂度会指数上升，受限于芯片的物理面积</p><p>approach #1: 使用多核来规避dependency tracking的问题，使用多个CPU，彼此互相独立，减少软件层对dependency的判断，但代码为了利用多核，需要显式分配pthread</p><p>多核相互独立的代价就是CPU之间无法共享，因此需要引入cache coherence协议，使用全局的directory来存放每个数据的最新值位于哪个CPU上，代价是directory会成为性能的瓶颈，需要限制核数来保证更强的consistency model，而GPU则是在超多核的情况下完全不使用cache coherence</p><p>approach #2: 每个CPU有多个组件，但多核没有充分利用这些组件。因此另一个方法为给每个CPU增加ALU数量，限制在于ALU需要执行相同的操作。SIMD即可实现计算的加速，但问题在于将8个计算并行处理时，性能只提升到了2倍，这是因为计算脱离了缓存</p><h3 id="accessing-memory-roofline-model"><a href="#accessing-memory-roofline-model" class="headerlink" title="accessing memory &amp; roofline model"></a>accessing memory &amp; roofline model</h3><p>一次内存读取的时间足够做几百个ALU操作，拖累了算力的提升。为了优化引入了prefetch，即将下一个可能的内存读取上来，这并不总是有效</p><p>内存操作受限于内存延迟(memory latency)和内存带宽(memory bandwidth)，对于prefetch而言更重要的是后者，公式为 $load_time &#x3D; latency + payload &#x2F; bandwidth$</p><p>roofline model可以判别计算受限于算力还是访存。模型的y轴为算力(Gflops&#x2F;second)，其中peek flops为算力的上限，当达到peek flops时说明受限于算力。x轴则是每读一个byte能做多少次计算(flops&#x2F;byte)，越大说明访存次数越少，因此斜率为带宽(bytes&#x2F;second)</p><img src="/2025/12/31/CSE-lecture24-distributed-computing/24645b442f11895241242cc5a56ae685.png" class="" title="roofline model"><h3 id="put-it-all-together-approach-1-approach-2-are-typically-used-together"><a href="#put-it-all-together-approach-1-approach-2-are-typically-used-together" class="headerlink" title="put it all together: approach #1 + approach #2 are typically used together"></a>put it all together: approach #1 + approach #2 are typically used together</h3><p>将多核和多SIMD合并在一起</p><p>CPU的很多硬件面积用于CPU控制流操作；而GPU的控制流相当简单，cache也很小，且没有cache coherence，从而获得更大面积的ALU组件，从而在牺牲复杂分支预测的前提下获得算力的提升</p><p>SIMD的指令都很简单，一次只能做简单的加法、乘法、读写等，当应用的计算复杂时（如激活函数，需要进行比较），需要使用masking，即将分支都执行，在计算其中一个分支时关闭另一个分支的写入，但会导致计算的浪费和死锁问题</p><img src="/2025/12/31/CSE-lecture24-distributed-computing/44b7403e27dfcf053000edde763bc624.png" class="" title="conditional execution under SIMD"><p>SIMT为SIMD的编程抽象，将每个ALU抽象成thread，当出现分支时自动插入mask，从而像写多核程序一样写GPU程序</p><p>为了加速矩阵乘法的操作，引入domain-specific accelerators</p><p>systolic array可用于加速矩阵的乘法，对于2*2矩阵而言，一般的计算需要12个周期，但脉冲阵列可以在6个周期计算出来</p><img src="/2025/12/31/CSE-lecture24-distributed-computing/cefb629623b2a11d7f6f869561ff57c0.png" class="" title="systolic array">]]></content>
    
    
    <categories>
      
      <category>计算机学习</category>
      
      <category>se专业课</category>
      
      <category>cse</category>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>se</tag>
      
      <tag>cse</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSE_lecture23:secure data flow</title>
    <link href="/2025/12/29/CSE-lecture23-secure-data-flow/"/>
    <url>/2025/12/29/CSE-lecture23-secure-data-flow/</url>
    
    <content type="html"><![CDATA[<h2 id="Secure-Data-Flow"><a href="#Secure-Data-Flow" class="headerlink" title="Secure Data Flow"></a>Secure Data Flow</h2><h3 id="taint-tracking"><a href="#taint-tracking" class="headerlink" title="taint tracking"></a>taint tracking</h3><p>为了防止数据暴露，希望系统具备观测数据流动的能力(taint training)，即对数据进行标记</p><p>对于外部进入的数据，认为其不安全，设置taint status为true，从而标记出所有与外部数据相关的数据，如出现jump xxx，这个xxx的taint status为true，认为代码出现问题。taint的overhead极大，可能翻四十倍</p><p>taintdroid对taint的操作进行分层，高层只使用粗粒度的taint，包括对整个数据库、对整个文件、对整条消息加taint；而只对java虚拟机做细粒度的变量级的taint跟踪；而对于cpp库则提前进行分析，届时只需根据调用关系得到taint情况即可。这样就实现了性能的优化</p><h3 id="defending-malicious-input"><a href="#defending-malicious-input" class="headerlink" title="defending malicious input"></a>defending malicious input</h3><p>一个攻击者根据以下步骤寻找bug：</p><ul><li>寻找契机</li><li>寻找冷门部分的bug，因为测试可能性很小</li><li>设计input data，这是攻击者可控的</li><li>追踪input data</li></ul><p>taintcheck用于监测input data在使用taint后的整个流动过程。当用于IO量大时overhead受影响不够明显</p><h3 id="secure-channel"><a href="#secure-channel" class="headerlink" title="secure channel"></a>secure channel</h3><p>跨机器传输数据需要进行加密</p><p>对称加密为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">encript(key, message) -&gt; ciphertext<br>encript(key, ciphertext) -&gt; message<br></code></pre></td></tr></table></figure><p>即加密和解密使用的密码一致</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">MAC(key, message) -&gt; token<br></code></pre></td></tr></table></figure><p>即使拥有key，也无法通过token得到message，类似于加密哈希。两者联合使用，可以在获取message的同时判断是否被篡改</p><p>问题在于replay attack可以窃取到发送的信息进行重发</p><img src="/2025/12/29/CSE-lecture23-secure-data-flow/581c203551a2c694c632047075b195ae.png" class="" title="replay attack"><p>通过在message中加入sequence来避免replay attack</p><p>此时reflection attack利用发送者和接收者的counter不一致，将发送者的消息发回发送者</p><img src="/2025/12/29/CSE-lecture23-secure-data-flow/aa2cf2f07c7cfd13c29973b2e4629229.png" class="" title="reflection attack"><p>使用两个密钥来进行加密，A给B发送的消息用key1加密，B给A发送的消息用key2加密</p><p>使用Diffie-Hellman key exchange让A和B共享密钥，A持有随机数a，B持有随机数b，共享质数p和随机数g后计算 $key &#x3D; g^{ab} \ mod \ p$ 即可</p><img src="/2025/12/29/CSE-lecture23-secure-data-flow/d580db254b592007cdfdb88286581e0b.png" class="" title="share key"><p>但攻击者可以拦截key的分享过程，进而参与到A和B的通信过程中去</p><img src="/2025/12/29/CSE-lecture23-secure-data-flow/99e14f22d63a81c905b54363dbfd293c.png" class="" title="man-in-the-middle"><p>这种攻击方法无解，因此引入RSA，即非对称加密，使用其中一个密钥加密时，必须用另一个密钥解密</p><p>在加密和解密时，加密用公钥，解密用私钥；在签名和验证时，签名用私钥，验证用公钥</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">sign(secret_key, message) -&gt; sig<br>verify(public_key, message, sig) -&gt; yes/no<br></code></pre></td></tr></table></figure><p>public_key公开，A给B通信时使用公钥发送消息，从而验证B的身份。获取途径为，B提供证书(CA)，其记录公钥，并包含签名，届时即可验证该签名</p><h3 id="privacy"><a href="#privacy" class="headerlink" title="privacy"></a>privacy</h3><p>既要保证使用数据，又要保证数据不被窃取</p><h4 id="OT-obvious-transfer"><a href="#OT-obvious-transfer" class="headerlink" title="OT: obvious transfer"></a>OT: obvious transfer</h4><p>假设A持有两个电话号码，现在B希望获取其中之一，需要保证B不知道另一个电话号码，也不让A知道B选的哪个</p><img src="/2025/12/29/CSE-lecture23-secure-data-flow/38babf70f9fa8ea26e73fb54a3177825.png" class="" title="1-out-of-2 OT"><h4 id="DP-differential-privacy"><a href="#DP-differential-privacy" class="headerlink" title="DP: differential privacy"></a>DP: differential privacy</h4><p>B持有每个人的详细工资信息，A希望进行统计，但需要保证A无法知道具体每个人的工资信息。为了防止A通过作差反推具体每个人的工资信息，只提供约数；同时限制提问次数</p><h4 id="secret-sharing"><a href="#secret-sharing" class="headerlink" title="secret sharing"></a>secret sharing</h4><p>希望将秘密分为n份，当有k个人时即可恢复秘密</p><h4 id="HE-homomorphic-encryption"><a href="#HE-homomorphic-encryption" class="headerlink" title="HE: homomorphic encryption"></a>HE: homomorphic encryption</h4><p>同态加密后的数据依然可以参与计算并提供给计算资源，届时解密即可</p><img src="/2025/12/29/CSE-lecture23-secure-data-flow/130582f551a0c5958281b9999258d1cb.png" class="" title="HE"><h4 id="TEE-trusted-execution-environment"><a href="#TEE-trusted-execution-environment" class="headerlink" title="TEE: trusted execution environment"></a>TEE: trusted execution environment</h4><p>计算资源只在cache使用明文，memory放置密文，而cache极难窃取</p><h3 id="process-of-bug-report"><a href="#process-of-bug-report" class="headerlink" title="process of bug report"></a>process of bug report</h3>]]></content>
    
    
    <categories>
      
      <category>计算机学习</category>
      
      <category>se专业课</category>
      
      <category>cse</category>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>se</tag>
      
      <tag>cse</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSE_lecture22:ROP and CFI</title>
    <link href="/2025/12/28/CSE-lecture22-ROP-and-CFI/"/>
    <url>/2025/12/28/CSE-lecture22-ROP-and-CFI/</url>
    
    <content type="html"><![CDATA[<h2 id="ROP-and-CFI"><a href="#ROP-and-CFI" class="headerlink" title="ROP and CFI"></a>ROP and CFI</h2><h3 id="security-principles"><a href="#security-principles" class="headerlink" title="security principles"></a>security principles</h3><ul><li>least privilege: 只提供完成事件的最小权限</li><li>least trust: 给组件分配任务时只提供最小的信任，如zero trust，内部也视为外网，使用U盘鉴权</li><li>users make mistakes: 安全要考虑用户犯的诸多错误</li><li>cost of security: 安全的成本不能太高</li></ul><h3 id="stack-buffer-overflow"><a href="#stack-buffer-overflow" class="headerlink" title="stack buffer overflow"></a>stack buffer overflow</h3><p>攻击者往往从控制流或数据的角度来攻击</p><p>stack buffer overflow通过栈溢出的手段修改return跳转的地址，从而返回到攻击者设计的恶意代码部分</p><p>防御手段为DEP(data execution prevention)，即数据段不可执行，即设置为non-executable，需要修改NX bit</p><p>此时攻击者使用ROP(return-oriented programming)，寻找原有的代码碎片(gadget)，这些碎片都以return结尾，在栈上注入地址指向这些碎片，从而将这些碎片代码合并在一起</p><img src="/2025/12/28/CSE-lecture22-ROP-and-CFI/f4679bf5a22470dfbbb5445dae223a34.png" class="" title="ROP"><p>防御手段有：</p><ul><li>隐藏binary file，从而无法获取gadget</li><li>ASLR将代码放在随机的地址</li><li>在return addr前面放置canary，覆盖addr时也会覆盖canary，通过检查canary来判断是否被攻击</li></ul><h3 id="CFI-control-flow-integrity"><a href="#CFI-control-flow-integrity" class="headerlink" title="CFI: control flow integrity"></a>CFI: control flow integrity</h3><p>设置合法的控制流，防止控制流被劫持，这需要描述control flow graph，将其和可执行的二进制文件合并后得到一个self-checking program，加入了多个检查点</p><p>攻击者往往从跳转部分劫持，大部分都是direct branches，少部分的indirect branches绝大多数也是跳到那一两个地址：</p><ul><li>direct branches: call或jump后跟着静态的地址</li><li>indirect branches: call或jump后跟着寄存器，代码运行后才能确定跳转的地址，以及return</li></ul><p>CFI通过二进制重写的方法将正确的跳转思路内嵌到代码中做检查</p><img src="/2025/12/28/CSE-lecture22-ROP-and-CFI/38b0bcd825ec5ce442e5be287bcf9154.png" class="" title="CFI example"><p>但这需要保证所有的代码都被patch，对于库代码可能出现问题。因此使用prefetchnta，访问内存地址，如果不合法就等价于nop，比较4字节的prefetchnta后的数字即可</p><img src="/2025/12/28/CSE-lecture22-ROP-and-CFI/ce9dbac48e6d32b4dd2a707f7f48401e.png" class="" title="prefetchnta"><p>假设A可以到C，B可以到C和D，此时C和D的tag一样，这就会导致A可以非法访问D，如果加入判断，会导致性能下降</p><p>因此引入shadow call stack，即单独维护一个存放return address的栈，这是由软件实现的，从而通过比较软件和硬件栈中的地址来判断stack over flow是否出现。为了提升性能，直接使用Intel CET维护硬件层面的shadow call stack</p><p>CFI保证了stack over flow的防御，但不能防御数据修改，如函数指针，或权限位</p><img src="/2025/12/28/CSE-lecture22-ROP-and-CFI/2d9c5ec0e3e554dcb081e593631f4a8b.png" class="" title="possible execution of memory"><h3 id="blind-ROP"><a href="#blind-ROP" class="headerlink" title="blind ROP"></a>blind ROP</h3><p>流程为：</p><ul><li>禁止ASLR，因为在接受socket时会folk，此时地址一样，并没有重启并让地址随机偏移</li><li>窃取binary：注入数据测试什么时候触发stack over flow，再继续通过是否崩溃一位一位猜测地址（这是因为canary不变）</li><li>寻找gadget：测试获取的地址附近的地址，判断是crash还是hang，有用的gadget时而crash，时而hang，说明结尾是return，只是return后跳转的第二个地址是否有效罢了</li><li>设置write的参数，使用BROP和PLT来设置寄存器的值和函数地址</li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机学习</category>
      
      <category>se专业课</category>
      
      <category>cse</category>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>se</tag>
      
      <tag>cse</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSE_lecture21:Security</title>
    <link href="/2025/12/17/CSE-lecture21-Security/"/>
    <url>/2025/12/17/CSE-lecture21-Security/</url>
    
    <content type="html"><![CDATA[<h2 id="Introduction-to-System-Security"><a href="#Introduction-to-System-Security" class="headerlink" title="Introduction to System Security"></a>Introduction to System Security</h2><p>cross-site scripting: 在评论中注入代码，而网站错误解读将其运行，或注入到其他用户的html中</p><p>SQL injection: 在SQL语句中注入SQL语句本身的语法，从而修改语句的含义</p><img src="/2025/12/17/CSE-lecture21-Security/8a10be17e7fae3b1d0738abf0af4e0cf.png" class="" title="SQL injection"><p>security难于实现，因为这是一个negative goal，如禁止某人访问某文件，这需要遍历所有访问这个文件的路径，但路径是非常多的；同时会和其他目标冲突；security还难以量化</p><p>达成安全系统有两步：目标清晰(policy)、假设清晰(threat model)</p><p>policy分为CIA:</p><ul><li>读限制：权限控制与加密</li><li>写限制：哈希或MAC校验</li><li>访问限制（如不可用）：池化</li></ul><p>threat model: 即做出假设，假设有哪些威胁模型，而假设需要现实</p><h3 id="guard-model"><a href="#guard-model" class="headerlink" title="guard model"></a>guard model</h3><p>当明确要保护的资源时，用墙保护资源并在端口放置守卫</p><p>有两个问题：守卫需要知道你是谁，守卫需要知道你是否有权限，这需要查表</p><p>guard model多种多样：文件系统的守卫为OS；web server的守卫为web应用；防火墙的守卫为内部网络，认为外部网络的设备都不可信。这些都是建立在现实的threat model之上的</p><p>但guard model依然可能出错，如软件bug，用户操作出错等。在设计时需要注意一定要将整个资源都包起来，不能留出守卫之外的访问漏洞</p><h3 id="authentication-password"><a href="#authentication-password" class="headerlink" title="authentication: password"></a>authentication: password</h3><p>有三种方法证明你是谁：你知道的、你拥有的、你本人，各有各的优缺点</p><p>password有以下问题：</p><ul><li>顺序遍历一位一位比较：可以根据响应时间判断哪一位出错</li><li>一位一位猜测，当出现磁盘转动时(会访问落在磁盘的下一位，发生page fault，加载进内存页，时间陡升），说明猜对这一位，猜下一位，从而大幅减少猜测的时间</li></ul><p>可以使用哈希解决这个问题，给密码算一个哈希值存储，从而对抗时间问题，同时防止密码泄露</p><p>但可以使用哈希碰撞来猜测密码，攻击者使用最常用的密码计算哈希，得到彩虹表，对照猜出密码</p><p>可以使用加盐(salting)的方法，salt是随机值，将其和密码组合后再计算哈希。这没有真正解决这个问题，因为攻击者能窃取到整个数据库表，得到salt的明文，但由于这需要大量的算力，salting依然被大量使用</p><p>验证的频率需要控制在一个合理的值，而这就需要记录状态，即cookie，包含用户名和过期时间等：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">&#123;username, expiration, H(server_key | username | expiration)&#125;<br></code></pre></td></tr></table></figure><p>对应服务器的session</p><p>早期的cookie也有bug，即直接拼接username和expiration会引发歧义，因此需要结构化</p><p>phishing攻击利用错误输入url的字符引发钓鱼攻击，窃取到密码。解决方法有：</p><ul><li>challenge-response scheme: server生成一个随机值R给client，client计算H(R + password)后返回server，从而进行验证。这能避免网络包被窃取时直接获得密码</li><li>client选择随机数Q，让server计算H(Q + password)，从而判断server是否为真。该方法用的不多，如出现中介</li><li>将offline攻击变成online攻击。这本身没有用，但会暴露攻击者的地址</li><li>specific password: 即用户给不同的网站设置不同的密码，进一步可以设计一个构造密码的算法</li><li>one-time passwords: 密码只能使用n次，server最开始保存 $H^n(salt+password)$，用户首次登陆发送 $H^{n-1}(salt+password)$，这样server只用做一次哈希，并改为存储 $H^{n-1}(salt+password)$，下次登陆时client就发送 $H^{n-2}(salt+password)$，这样被截获后再次登录就会失效</li><li>把authenticaion和request绑定在一起</li><li>FIDO: 把指纹和私钥绑定<img src="/2025/12/17/CSE-lecture21-Security/64d8d73cb8dab123b08faa337c9571a2.png" class="" title="FIDO"></li></ul><img src="/2025/12/17/CSE-lecture21-Security/17708558dba930ac10740f9901a4053d.png" class="" title="example">]]></content>
    
    
    <categories>
      
      <category>计算机学习</category>
      
      <category>se专业课</category>
      
      <category>cse</category>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>se</tag>
      
      <tag>cse</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSE_lecture20:network-dns-cdn</title>
    <link href="/2025/12/17/CSE-lecture20-network-dns-cdn/"/>
    <url>/2025/12/17/CSE-lecture20-network-dns-cdn/</url>
    
    <content type="html"><![CDATA[<h2 id="DNS-Naming-Scheme"><a href="#DNS-Naming-Scheme" class="headerlink" title="DNS &amp; Naming Scheme"></a>DNS &amp; Naming Scheme</h2><h3 id="the-design-of-DNS"><a href="#the-design-of-DNS" class="headerlink" title="the design of DNS"></a>the design of DNS</h3><p>实现hostname和IP地址的转换，从而实现用户友好</p><p>一个域名可以对应多个IP地址，从而实现负载均衡，允许用户访问一个更近的IP地址；一个IP地址也可以对应多个域名；这种映射关系可以发生变化，但需要向DNS服务商发送请求</p><p>为了能够扩大规模，需要引入hierarchy的思想，即进行分层，分成不同的域，每个zone使用不同的name server解析</p><p>name server分为：</p><ul><li>root zone由ICANN管理，非盈利</li><li>“.com” zone由VeriSign管理，盈利</li><li>从root zone到”.com” zone一层一层管理下面的域名</li></ul><img src="/2025/12/17/CSE-lecture20-network-dns-cdn/dd45cca283700199eacb809b2526a555.png" class="" title="DNS hierarchy"><p>以”ipads.se.sjtu.edu.cn”为例，lookup算法为：</p><ul><li>从root开始，告诉我们”cn”的name server的IP</li><li>“cn” name server告诉我们”edu.cn”的name server的IP</li><li>以此类推，直到知道”ipads.se.sjtu.edu.cn”的IP</li></ul><img src="/2025/12/17/CSE-lecture20-network-dns-cdn/aff0ec72481cde897354d02a5a0cdec3.png" class="" title="DNS lookup"><p>即每一层的name server并不需要记住过多的域名，只需要记录下一层的几个节点即可</p><p>DNS的name都是全局的，因此没有上下文的问题。域名使用”.”分割，因此实际为”ipads.se.sjtu.edu.cn.”，最后的点表示root</p><p>每个zone会对应多个name server，从而提高容错</p><p>look-up算法可以进行改进：</p><ul><li>第一个DNS请求可以到任何name server，降低root的压力，这是依靠缓存实现的</li><li>recursion: 降低client的压力，即由name server来帮忙递归找域名地址，好处是更快，缺点是请求是有状态的，因此只用于小范围<img src="/2025/12/17/CSE-lecture20-network-dns-cdn/e9ea4893b8ccc124137c7b945201a235.png" class="" title="DNS recursion"></li><li>caching: 将访问过的地址缓存在DNS client和name server中，但会设置TTL</li></ul><h3 id="behind-the-DNS-design"><a href="#behind-the-DNS-design" class="headerlink" title="behind the DNS design"></a>behind the DNS design</h3><p>DNS设计的优点有：</p><ul><li>hierarchy的设计让管理分化，只需要将新的域名分配给直属的上级name server，简化了域名的管理</li><li>global name防止了DNS指定上下文，而是产生一个唯一的域名</li><li>lookup的性能要求不高，使得性能具备scalable</li><li>一个zone有多个name server，提高了容错</li></ul><p>DNS设计的缺点有：</p><ul><li>谁去控制root zone和”com” zone等等？</li><li>root server的负载依然很高，尤其是当访问不存在的域名时，可能出现缓存穿透</li><li>client无法确定DNS服务器的响应是否正确</li></ul><h3 id="content-distribution"><a href="#content-distribution" class="headerlink" title="content distribution"></a>content distribution</h3><p>需要减小访问网络上大型文件的延迟，client端可以使用cache，而server端也会使用cache，但由于文件很大可能装不下，因此额外使用一些服务器专门用于缓存大型文件，即CDN</p><p>CDN离发出请求的client越近越好，content提供者会进行预热，在大量请求到达之前将大型文件提前缓存在CDN上，从而提升性能</p><p>HTTP redirection中，一个服务器收到请求后，会让client redirect到一台更近的服务器。好处是可以细粒度分发资源，缺点是增加了一次RTT，但对于大型文件而言可以接受</p><img src="/2025/12/17/CSE-lecture20-network-dns-cdn/368c7cb657384e0485ec7e7a35cb1ac4.png" class="" title="HTTP redirection"><p>也可以通过DNS选择服务器，即在资源对应的多个IP地址中选择更近的那个。好处是降低时延，缺点是强依赖IP地址</p><img src="/2025/12/17/CSE-lecture20-network-dns-cdn/6eb613edf6ddc936bcb4d6d1467f06ba.png" class="" title="DNS-based server selection"><h3 id="naming-scheme"><a href="#naming-scheme" class="headerlink" title="naming scheme"></a>naming scheme</h3><p>naming schemes包括：names, values, look-up algorithm</p><p>binding即实现name和value的绑定，可以是一对一，也可以是一对多、多对一；而resolve实现了name的解析</p><p>naming context包括两大类：context和name分开，如inode；context是name的一部分，内嵌在其中，如邮件。当name space只有一个context时为universal name spaces，全球唯一</p><p>决定context的方法有：</p><ul><li>硬编码在resolver里面，如universal name spaces</li><li>从环境变量中寻找，但需要正确的context</li></ul><p>name mapping的算法有：</p><ul><li>查表</li><li>递归查找</li><li>并列查找，如<code>$PATH</code>，冒号隔开的是并列关系</li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机学习</category>
      
      <category>se专业课</category>
      
      <category>cse</category>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>se</tag>
      
      <tag>cse</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSE_lecture19:network-end2end</title>
    <link href="/2025/12/16/CSE-lecture19-network-end2end/"/>
    <url>/2025/12/16/CSE-lecture19-network-end2end/</url>
    
    <content type="html"><![CDATA[<h2 id="End-to-end-Layer-Best-effort-is-not-enough"><a href="#End-to-end-Layer-Best-effort-is-not-enough" class="headerlink" title="End-to-end Layer: Best-effort is not enough"></a>End-to-end Layer: Best-effort is not enough</h2><h3 id="end-to-end-layer"><a href="#end-to-end-layer" class="headerlink" title="end-to-end layer"></a>end-to-end layer</h3><ul><li>UDP: 最简化的协议</li><li>TCP: 能保证数据顺序和不丢包，能保证不重复</li><li>RTP: 建立在UDP，用于实时要求</li></ul><h4 id="assurance-of-at-least-once-delivery"><a href="#assurance-of-at-least-once-delivery" class="headerlink" title="assurance of at-least-once delivery"></a>assurance of at-least-once delivery</h4><p>保证发出的包至少成功一次，在best-effort网络中会为每个包加一个nonce，用于标记是哪个包，发送者会保留包的复制，超时后就可以重传，一直重传直到达到limit times</p><p>会面临一个两难问题，即超时是因为包发过去丢失，还是对方的ACK丢失</p><p>问题在于怎么确实timeout：</p><ul><li>fixed timer: 无法确定等待时间长还是短，因此绝对不能将时间固定</li><li>adaptive timer: 超时时间适应当时的网络环境，可以设置为RTT(往返时延)的150%，或者设置为上次失败时延的两倍</li><li>NAK: 与ACK相反，即接收者主动说明自己没收到的包，这样timer放在接收者，重发由NAK决定</li></ul><h4 id="assurance-of-at-most-once-delivery"><a href="#assurance-of-at-most-once-delivery" class="headerlink" title="assurance of at-most-once delivery"></a>assurance of at-most-once delivery</h4><p>接收者记住自己曾受到过的包，当再次收到这个包时就不必再处理这个包。但这样可能导致表无限增长，因此难点在于怎么设置tombstone；或者由应用设置幂等性的操作</p><p>问题在于怎么做duplicate suppression：</p><ul><li>记录水位，但默认包按照nonce的顺序，这样只用记录一个数字，但old nonce会成为tombstone</li><li>使用一个新的端口接收新的请求，即不再使用已经用过的端口，但old port会成为tombstone</li></ul><p>但当接收者崩溃重启后，这些duplicate suppression会丢失，而写入磁盘又会导致性能下降，因此tombstone会占用资源。因此最好由应用层支撑幂等性</p><p>实践上在5个RTT之后删除记录的包（即发送者和接收者达成了协议），避免接收者记录过多东西</p><h4 id="assurance-of-data-integrity"><a href="#assurance-of-data-integrity" class="headerlink" title="assurance of data integrity"></a>assurance of data integrity</h4><p>为了保证数据完整性，需要添加checksum</p><h4 id="segments-and-reassembly-of-long-messages"><a href="#segments-and-reassembly-of-long-messages" class="headerlink" title="segments and reassembly of long messages"></a>segments and reassembly of long messages</h4><p>对于长消息需要拆分和合并，此时会有类似于”message 914, segment 3 of 7”的标识，这个标识也可以用于at-least-once和at-most-once的编号</p><p>但多个长消息的分块可能出现乱序：</p><ul><li>接收者只ACK in-order的包，抛弃其他包</li><li>ACK所有的包并缓存它们，直到全收到再释放缓存并合并，但当坏包出现时，需要非常大的缓存</li><li>结合前两个方法，维护一个有限的缓存，缓存存不下就丢包，难点在于缓存开多大</li></ul><p>为了缓解坏包带来的问题，可以使用NAK，而不是等到坏包超时再重发。而TCP是基于ACK，而不是NAK</p><h4 id="assurance-of-jitter-control"><a href="#assurance-of-jitter-control" class="headerlink" title="assurance of jitter control"></a>assurance of jitter control</h4><p>每个包到达的时间不完全一样，网络不稳定时导致时延突然过大。解决策略为缓冲，等待一会儿</p><p>缓冲的大小为：$Number_ of_ segment_ buffers &#x3D; \frac{D_{long} - D_{short}}{D_{headway}}$，即统计一段时间内的最长时延和最短时延，相减并除以平均值</p><h4 id="assurance-of-authenticity-and-privacy"><a href="#assurance-of-authenticity-and-privacy" class="headerlink" title="assurance of authenticity and privacy"></a>assurance of authenticity and privacy</h4><p>保证网络的安全性，因此需要身份验证。传统的方法为密钥加密，分为对称加密和非对称加密，非对称加密性能很差，用于建立连接时，后续使用对称加密</p><h4 id="end-to-end-performance"><a href="#end-to-end-performance" class="headerlink" title="end-to-end performance"></a>end-to-end performance</h4><p>考虑性能的同时需要保证网络不崩溃</p><p>使用lock-step protocol很直观，但会导致发送者和接收者出现大面积的闲置时间，浪费带宽</p><img src="/2025/12/16/CSE-lecture19-network-end2end/9a3bd2db7db6c84fa185eaf35b6747ae.png" class="" title="lock-step"><p>pipelining technique会在发送一个包后继续发第二个包，但全力发包可能导致接收者无力承受，需要两边进行协商，此外也可能导致包的丢失</p><img src="/2025/12/16/CSE-lecture19-network-end2end/50c127cdd61efe195f1af6be50b268a3.png" class="" title="pipelining technique"><p>为了协商速度，引入fixed window，即在发包之前协定发送包的数量。但会出现idle</p><img src="/2025/12/16/CSE-lecture19-network-end2end/dbc77669a9d5b0b48dd10972fde4c088.png" class="" title="fixed window"><p>因此在收到ACK时就可以发新的包了，即sliding window</p><img src="/2025/12/16/CSE-lecture19-network-end2end/3c30d83acfbf1e4c5bb3bf258f0b12aa.png" class="" title="sliding window"><p>当有包丢失时，滑动窗口会卡住，直到超时重发并ACK，这是为了防止维护一个过大且未知大小的缓存</p><img src="/2025/12/16/CSE-lecture19-network-end2end/c788bfeae7808b3359bc1f6823801a1e.png" class="" title="handling packet loss"><p>window size的大小公式为：$window_ size \geq round_ trip_ time \times bottleneck_ data_ rate$</p><img src="/2025/12/16/CSE-lecture19-network-end2end/1a9386d0973ad03af0d25936da44db15.png" class="" title="window size"><h3 id="TCP-congestion-control"><a href="#TCP-congestion-control" class="headerlink" title="TCP congestion control"></a>TCP congestion control</h3><p>network layer可以直观体验到拥塞，但发送速度是由end-to-end layer控制的</p><p>当load过大时，不仅会出现拥塞，甚至会出现倒塌(collapse)，成功率反而急速下降</p><p>为了控制拥塞，window size的另一个公式为：$window_ size \leq min(RTT \times bottleneck_ data_ rate, receiver_ buffer)$</p><p>拥塞控制的基本思想(AIMD)为：缓慢线性增加congestion window，即没有丢包就加一，一旦丢包指数减小，即除以二。当有多个发包和收包的人时需要保证公平性</p><p>AIMD的问题在于初始值不能太小，否则会导致浪费</p><p>retrofitting TCP的步骤为：</p><ul><li>slow start: 开始时指数上升，每次给window size乘二</li><li>接收者发现乱序时，发送一个duplicate of latest ACK，发送者收到时window size除以二，再每次加一，重复此过程直到平衡</li><li>超时，等待随机时间，重新开始slow start</li></ul><img src="/2025/12/16/CSE-lecture19-network-end2end/91b390acfa6eb7a20dfaeef99bcbf1d5.png" class="" title="retrofitting TCP"><p>为了提高利用率，在window size减小时可以减的少一点，因此在数据中心会单独适配TCP</p><p>AIMD通过反复调整可以自动保证多个发送者的公平性，即不需要各个节点协商专门调整。这也是为什么window size下降时需要减半</p><img src="/2025/12/16/CSE-lecture19-network-end2end/cf660ab350aa549916c11b1303a3dab7.png" class="" title="AIMP leads to efficiency and fairness"><p>TCP的缺点在于：</p><ul><li>路由器buffer太大会导致长的延时</li><li>丢包不一定由拥塞导致，如wifi在丢包后反而应当发得快一些</li><li>在数据中心时TCP做的不够好，即减半导致利用率低，需要自行适配TCP</li><li>对于长RTT的网络存在偏见，因为吞吐量会下降</li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机学习</category>
      
      <category>se专业课</category>
      
      <category>cse</category>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>se</tag>
      
      <tag>cse</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSE_lecture18:network-ip-2</title>
    <link href="/2025/12/15/CSE-lecture18-network-ip-2/"/>
    <url>/2025/12/15/CSE-lecture18-network-ip-2/</url>
    
    <content type="html"><![CDATA[<h2 id="Network-Layer-2"><a href="#Network-Layer-2" class="headerlink" title="Network Layer - 2"></a>Network Layer - 2</h2><h3 id="case-study-BGP"><a href="#case-study-BGP" class="headerlink" title="case study: BGP"></a>case study: BGP</h3><p>每个region都希望实现自己的policy，比如某些region不想把数据发给其他某些region，或者不允许经过某些路径</p><p>典型BGP的角色有：</p><ul><li>customer&#x2F;provider: customer为provider提供的流量付费，因为低级的AS需要向高级的AS购买流量</li><li>peers: 流量平等，不存在隶属关系，不互相付费</li></ul><img src="/2025/12/15/CSE-lecture18-network-ip-2/912f5284b9e3654df688e0a06c12fca5.png" class="" title="customers and peers"><p>节点会广播自己能访问的节点，如向peer广播自己的customer，从而使其他节点经过自己，获得更多钱</p><p>最佳的路径为customer &gt; peer &gt; provider，即优先选择自己的customer，以谋取更多利润</p><img src="/2025/12/15/CSE-lecture18-network-ip-2/effa929bcf9730bece472871cfcc7e7c.png" class="" title="example"><p>在这个例子中Y看不到C和T节点，这似乎让Y显得没有连上网络，但BGP不阻止这种现象，因为该图是一个简化图，Y也可以通过自己的customer和provider找到这些节点，而Tier-1的节点全球只有十几个（视频网站可能导致peer之间出现付费）</p><p>BGP使用path-vector，此时cost中不只有时间，更多的是考虑金钱</p><p>BGP具有高可扩展，实现简单的特点，但也有不稳定，很脆弱，不安全的问题</p><h3 id="case-NAT"><a href="#case-NAT" class="headerlink" title="case: NAT"></a>case: NAT</h3><p>192.168前缀的地址是内部地址，无法进入公网，如192.168.0.0&#x2F;16，这是因为IPv4的地址数太少，无法让家里的设备都拥有唯一的IPv4地址，因此需要地址转换，即NAT</p><p>内网的地址通过路由器访问Internet，但是这会导致内网设备的地址都是路由的地址，因此需要端口进行区分，从而实现IP的复用。具体而言，路由器需要维护一张表，实现内网地址和端口的对应关系</p><img src="/2025/12/15/CSE-lecture18-network-ip-2/f6176321eb8e073b19f096b2cd6da920.png" class="" title="NAT"><img src="/2025/12/15/CSE-lecture18-network-ip-2/208c28212cf23947a007335824eac858.png" class="" title="massive NAT"><p>注意内网的设备自己也会有端口，相同内网IP的不同端口对应的NAT端口也是不同的</p><p>NAT的缺点在于，端口属于TCP的概念，却被用于IP协议，破坏了分层架构</p><h3 id="case-Ethernet-Mapping"><a href="#case-Ethernet-Mapping" class="headerlink" title="case: Ethernet Mapping"></a>case: Ethernet Mapping</h3><p>以太网分为半双工和全双工两大类，半双工只能发不能收，或者只能收不能发，而全双工既能发也能收</p><img src="/2025/12/15/CSE-lecture18-network-ip-2/a77601130b77905fc22236bf91deb508.png" class="" title="Ethernet package"><p>这里的destination和source为48位，即MAC地址</p><p>以太网同样有ethernet_send和ethernet_handle，后者现在基本只用于接收，因为IP协议来做转发</p><p>为了实现以太网之间的连接，需要将IP的包转为以太网的包，并实现source和destination的MAC地址的连接。因此需要IP地址和以太网MAC地址的映射，即ARP表</p><p>当有人询问IP地址的MAC地址时，听到的节点都可以将这个映射关系记录在ARP表中，因此只需要任意人的询问即可，不一定需要自己询问</p><p>而RARP协议则反过来通过MAC地址知道IP地址</p><p>可以将默认设置为路由器的MAC地址，防止ARP表将多个跨网络的MAC地址都记录为该路由器的地址</p><img src="/2025/12/15/CSE-lecture18-network-ip-2/06ef9a2b06cdb2dbb970f54f40d34b92.png" class="" title="put it together 1"><img src="/2025/12/15/CSE-lecture18-network-ip-2/b14a913723e4d93c70a9f5a38ad05c46.png" class="" title="put it together 2"><img src="/2025/12/15/CSE-lecture18-network-ip-2/4778ec02c59f89296da5f83ed63ada8b.png" class="" title="put it together 3"><p>隐患在于ARP poison，因为ARP表会出现道听途说问题，hacker可以据此修改其他节点中ARP表的IP与MAC的对应关系</p><p>为了对抗ARP spoofing，可以写死ARP表，或者使用ARPwatch监测问题</p><h3 id="data-plane-packet-forwarding"><a href="#data-plane-packet-forwarding" class="headerlink" title="data-plane: packet forwarding"></a>data-plane: packet forwarding</h3><p>network_handle检查包是否是发给自己的，如果是就向上走，否则向下进入link_send继续转发</p><img src="/2025/12/15/CSE-lecture18-network-ip-2/534511d647b37d9e267415cd6a673ed3.png" class="" title="network_handle"><p>在forward一个IP包时，需要在forwarding table中检查是否知道destination，知道就走link，不知道就丢包；每转发一次TTL减一，为零时丢包；更新checksum（仅因为TTL更新）；最后发出去</p>]]></content>
    
    
    <categories>
      
      <category>计算机学习</category>
      
      <category>se专业课</category>
      
      <category>cse</category>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>se</tag>
      
      <tag>cse</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSE_lecture17:network-ip</title>
    <link href="/2025/12/09/CSE-lecture17-network-ip/"/>
    <url>/2025/12/09/CSE-lecture17-network-ip/</url>
    
    <content type="html"><![CDATA[<h2 id="Network-Layer-All-about-routing"><a href="#Network-Layer-All-about-routing" class="headerlink" title="Network Layer: All about routing"></a>Network Layer: All about routing</h2><p>IP协议的传输是尽力而为(best-effort)的，因此是可以丢包的</p><p>与之对应的是guaranteed-delivery network，需要一个缓存队列，但会导致延时，进而导致超时重发。需要由上层来实现</p><p>这一层有network_send和network_handle，后者可能处理，也可能转发</p><p>路由有很多网口，实现了跨子网之间的访问，其中路由表记录了子网和网口的对应关系，而路由器与路由器之间的路由表会进行合并，从而进行多个子网之间的通信</p><p>control-plane控制了数据的流动，如随时更新路由表或确定路由算法，重点在于正确性；data-plane则用于快速查表，重点在于性能</p><p>路由器往往有两个硬件，即CPU和NPU，前者用于处理control-plane，后者用于快速实现data-plane，如使用大的cache</p><h3 id="routing"><a href="#routing" class="headerlink" title="routing"></a>routing</h3><p>路由的目标为能找到任意起点和终点之间的路径，且这条路径是最快的（时间上的，金钱上的）</p><p>难点在于分布式路由的实现，分为三步：</p><ul><li>HELLO protocol: 节点向邻居打招呼，获得邻居的信息</li><li>advertisements: 获得可达节点的信息</li><li>minimum-cost: 根据已知路由确定最小成本路由</li></ul><p>两种类型的routing protocol:</p><ul><li>link-state: 一个节点的advertisement包括它的邻居和到达这些邻居的成本，通过泛洪(flooding)将到达邻居的成本发给所有节点，最后通过Dijkstra最短路径算法进行整合</li><li>distance-vector: 只给邻居告诉它已知的所有节点的成本，使用Bellman-Ford算法进行整合</li></ul><img src="/2025/12/09/CSE-lecture17-network-ip/52671670be8fedf8f2606592c1b8b768.png" class="" title="link-state flooding"><img src="/2025/12/09/CSE-lecture17-network-ip/fea953ba3bf431c6656d65a848382d2d.png" class="" title="link-state Dijkstra"><p>注意到link-state的路由只记录其选择的邻居，而不是完整的路径</p><p>link-state的容错性好且收敛快，但缺点在于网络建立初期，flooding的网络开销极大，因此只适用于规模较小的自组织网络</p><p>相较于link-state在flooding时发送的都是同一信息，distance-vector的邻居节点消化完信息后，会发送新的认知信息，从而让原来的节点更新自己的路由表，并再次发送认知信息（可能停不下来，即持续更新）</p><img src="/2025/12/09/CSE-lecture17-network-ip/7ca0ac10213251cab1c89597c378145b.png" class="" title="distance-vector first advertisement"><img src="/2025/12/09/CSE-lecture17-network-ip/8ed7ea8f229bb19140d59e2a24dfad10.png" class="" title="B" alt="s first advertisement"><img src="/2025/12/09/CSE-lecture17-network-ip/8d701e4653a97f34b3233837199765e3.png" class="" title="D" alt="s first advertisement"><img src="/2025/12/09/CSE-lecture17-network-ip/59f5efe74d87236cf59d38710e5dc8c1.png" class="" title="distance-vector second advertisement"><img src="/2025/12/09/CSE-lecture17-network-ip/fc423095879406d336607abd9b6b0917.png" class="" title="link-state vs distance-vector"><p>distance-vector不能一开始就得到最优解，其容错性要差些，因此failure handling是其缺点，如problem of INFINITY</p><img src="/2025/12/09/CSE-lecture17-network-ip/d055e59a521506f03b8a6dd2d9fb7892.png" class="" title="INFINITY"><p>因此advertisement里面不应当包含A-&gt;B的路径</p><img src="/2025/12/09/CSE-lecture17-network-ip/525010a64bbfacdc65f1a6b444efdbb8.png" class="" title="split horizon"><p>distance-vector的优点在于低开销，缺点在于收敛时间长且与路径长度有关，还有infinity问题，因此也只适用于小型网络</p><h3 id="scale-the-routing"><a href="#scale-the-routing" class="headerlink" title="scale the routing"></a>scale the routing</h3><p>三种扩大规模的方法：</p><ul><li>hierarchy of routing: 即划分region，将多个节点抽象成一个点</li><li>path-vector routing: advertisement将包含完整的path信息</li><li>topological addressing: 将多个地址合并在一起，使路由表变小，如18.0.0.0到18.0.0.255的所有地址压缩成18.0.0.0&#x2F;24，即前24位都相同</li></ul><img src="/2025/12/09/CSE-lecture17-network-ip/26922538fb9a4d2eda3d3e0bad47adc4.png" class="" title="hierarchical address assignment &amp; routing"><p>而跨region应当使用BGP，是一种path-vector protocol</p><p>path-vector将整个path记录下来，有助于检查有无环，防止出现INFINITY问题，还能顺便进行access policy，即检查不能去的节点，最后扩大了规模，收敛时间下降。缺点在于advertisement变大</p><img src="/2025/12/09/CSE-lecture17-network-ip/41b49f81be6335788083ad5ed73a797a.png" class="" title="path-vector exchange"><img src="/2025/12/09/CSE-lecture17-network-ip/b02d3d027271c0124a16bbba18e6c2e0.png" class="" title="path vector &amp; forwarding table"><p>当graph变化时，即某个节点go down，path-vector只需要检查path里面有没有这个节点，修改受到影响的节点即可</p><img src="/2025/12/09/CSE-lecture17-network-ip/e55a9a1dfb5e56f325bf4df3b300d984.png" class="" title="IGP vs EGP"><table><thead><tr><th><strong>特性</strong></th><th><strong>内部网关协议（IGP）</strong></th><th><strong>外部网关协议（EGP）</strong></th></tr></thead><tbody><tr><td><strong>范围</strong></td><td>自治系统（AS）内部</td><td>自治系统（AS）之间</td></tr><tr><td><strong>主要目标</strong></td><td>找到最佳路径；快速收敛</td><td>应用路由策略；控制路径传播</td></tr><tr><td><strong>典型协议</strong></td><td>OSPF、IS-IS、RIP、EIGRP</td><td>BGP（当前唯一使用的 EGP）</td></tr><tr><td><strong>关注点</strong></td><td>速度、效率、网络拓扑</td><td>策略、可达性、AS 路径</td></tr><tr><td><strong>规模</strong></td><td>管理数百到数千条路由</td><td>管理全球互联网（数十万条路由）</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>计算机学习</category>
      
      <category>se专业课</category>
      
      <category>cse</category>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>se</tag>
      
      <tag>cse</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSE_lecture16:network-link</title>
    <link href="/2025/12/08/CSE-lecture16-network-link/"/>
    <url>/2025/12/08/CSE-lecture16-network-link/</url>
    
    <content type="html"><![CDATA[<h2 id="Introduction-to-Network"><a href="#Introduction-to-Network" class="headerlink" title="Introduction to Network"></a>Introduction to Network</h2><h3 id="layers-in-network"><a href="#layers-in-network" class="headerlink" title="layers in network"></a>layers in network</h3><p>最常见的为四层架构分层，这是根据TCP&#x2F;IP系统分层的：</p><ul><li>Application</li><li>Transport</li><li>Network</li><li>Link</li></ul><p>OSI标准定义的则是七层架构，但TCP&#x2F;IP四层架构更加实用</p><img src="/2025/12/08/CSE-lecture16-network-link/9fa412a3963e954ad17aa4fcf7f38df9.png" class="" title="layers in network"><p>Link Layer只处理线段端点间的数据搬运，Network Layer则负责寻找起始节点到目标节点的通路，End-to-end Layer处理具体怎么传输数据</p><p>无论软硬件规定了多少协议，都需要IP协议来进行收束，从而统一标准</p><p>网络发包时会被各层包装，事实上socket buffer的data也是从中间写的，预留出前面的空间来存放header</p><img src="/2025/12/08/CSE-lecture16-network-link/eb78f118cc24804f5b721f96fbdd57ba.png" class="" title="packet encapsulation"><p>port用于在IP相同时标识server提供的服务和进程</p><p>gateway提供了网络与网络之间的连接</p><ul><li>每一层都会添加&#x2F;去掉自己的报头</li><li>每一层可能会拆分更高一层的数据</li><li>每一层会复用多个更高一层的数据</li><li>每一层对更高层来说（大多是）透明的</li></ul><h3 id="link-layer"><a href="#link-layer" class="headerlink" title="link layer"></a>link layer</h3><p>Link Layer实现了将数据传输给物理邻居：</p><ul><li>物理传输</li><li>链路复用</li><li>对比特与比特序列进行成帧处理</li><li>检测传输错误</li><li>为上一层提供一个有用的接口</li></ul><p>为了实现链路复用，可以使用同步通信和异步通信</p><ul><li>isochronous connection: 每人分配一小块时间传输数据，好处在于互不影响，缺点在于利用率不高，因此多用于音频网络<img src="/2025/12/08/CSE-lecture16-network-link/eef35275fd80bcd92f7a3b00a21650a0.png" class="" title="isochronous"></li><li>asynchronous connection: 用于数据网络，通过发包的方式通信，因此包与包之间需要排队，排队策略很多</li></ul><p>现在基本都使用后者了，声音传输也使用数据传输</p><p>为了维护frame，需要使用特殊的序列来标识frame的开始和结束，一个简单的方法是：收到7个1 bit时分离出frame，而数据中如果包含连续的6个1 bit，就在后面额外加一个0 bit</p><p>对于错误处理，可以添加error detection code，如在结尾添加一个checksum，并使用error correction code纠正，纠正不了才选择重传</p><p>一般来说只会有1个bit出现问题，因此通过hamming coding扩充冗余bit位数，达到校验的目的，位数设置的目的是为了直接相加得到真正错误的位数</p><img src="/2025/12/08/CSE-lecture16-network-link/617275ee4949654f49f26873ec0943ab.png" class="" title="hamming coding"><p>point-to-point protocol是指一系列的协议，包括：</p><ul><li>framing method</li><li>link control protocol</li><li>network control protocol</li></ul><img src="/2025/12/08/CSE-lecture16-network-link/0df24885b6da39b2146ed4a42f65064d.png" class="" title="PPP framing and error detection"><p>在正式发送数据之前，会先发送LCP包，用于检查对方是否做好准备，接收者也会返回并协商格式</p>]]></content>
    
    
    <categories>
      
      <category>计算机学习</category>
      
      <category>se专业课</category>
      
      <category>cse</category>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>se</tag>
      
      <tag>cse</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSE_lecture14:2PC+Replication</title>
    <link href="/2025/11/06/CSE-lecture14-2PC-Replication/"/>
    <url>/2025/11/06/CSE-lecture14-2PC-Replication/</url>
    
    <content type="html"><![CDATA[<h2 id="Consistency-under-partial-failure-2PC-replicated-state-machine"><a href="#Consistency-under-partial-failure-2PC-replicated-state-machine" class="headerlink" title="Consistency under partial failure: 2PC &amp; replicated state machine"></a>Consistency under partial failure: 2PC &amp; replicated state machine</h2><h3 id="2PC-and-CAP"><a href="#2PC-and-CAP" class="headerlink" title="2PC and CAP"></a>2PC and CAP</h3><p>CAP认为consistency(linearizability, all-or-nothing, before-or-after, …), availability（响应时间短，规避重启）, partition tolerance（在网络分区的前提下，保证在消息丢失或系统故障下正常运行）三者不能兼得</p><p>2PC保证了consistency，使用replication保证availability，而replication难以保证操作顺序，解决方法为：</p><ul><li>optimistic replication: eventual consistency</li><li>pessimistic replication: linearizability</li></ul><p>为了防止顺序不一致导致的死锁问题，2PC使用linearizability更好，因此希望primary-backup model更通用</p><p>当primary挂了时，有以下方法：</p><ul><li>选一台backup变为primary，但人类难以快速切换</li><li>使用coordinator决定哪个backup来充当primary，速度极快，但为了防止coordinator挂了，需要使用多个coordinator，但它们的决定可能不一样</li><li>黑魔法，如raft</li></ul><p>而网络分区也可能导致各个coordinator处在不同的分区，导致它们认为自己分区的backup是primary，从而导致同时出现多台primary</p><p>view server记录谁才是真正的primary，还记录了历史的primary，切换时view号加一</p><p>coordinator询问谁是当前的primary，得到结果后会cache这个view信息，减小网络开销；view server监听replica的heartbeat，primary挂了时，更新view number并分配新的primary（新的primary直到收到view number后才从backup变为primary，此前还是接受primary的同步和拒绝coordinator的请求）；而网络分区也可能导致heartbeat收不到，导致出现多台primary(split brain)，因此backup同步时还需要带上view number，当其小于primary时就reject，从而区分旧的和新的primary（这是建立在primary必须等待backup全部ACK的前提下的，从而实现请求的拒绝）</p><p>由于primary要等待所有的backup的ACK，当backup挂了时，反而导致了系统不工作；可以让primary只等待一部分backup的ACK，但选择新的primary时需要额外处理，即需要从多台机器中读取最新的数据拼接起来来恢复，事实上很快</p><p>quorum要求，写入时挑选 $Q_w$ 台机器写入，恢复时从 $Q_r$ 台机器中读取出来，只要保证 $Q_r + Q_w &gt; \text{Nreplicas}$ 即可</p><p>最后的问题是view server挂了怎么办，因此需要引入paxos</p><h3 id="paxos"><a href="#paxos" class="headerlink" title="paxos"></a>paxos</h3><h4 id="single-decree-paxos-agree-on-a-single-value-w-o-a-view-server"><a href="#single-decree-paxos-agree-on-a-single-value-w-o-a-view-server" class="headerlink" title="single-decree paxos: agree on a single value w&#x2F;o a view server"></a>single-decree paxos: agree on a single value w&#x2F;o a view server</h4><p>当只有一台writer时，遵循quorum即可，但问题在于怎么处理多台writer</p><p>paxos的角色有client, proposer, acceptor, learner，每个paxos node为后三者三合一，即每个节点充当里面的所有职责：</p><p>proposer要判断自己是否是唯一的writer(leader)，即当它的proposer number最大时为唯一的writer（只需要询问超过半数的机器，从而保证冲突，需要存放highest proposal number seen）（因为另一个proposer在询问时势必会访问到重叠的acceptor，从而保证能决定冲突</p><p>single-decree paxos的流程如下：</p><ul><li>prepare:<ul><li>proposer接收到client的请求后，生成一个递增的proposal number N（为轮次&#x2F;server id对，先比较前者）（N应当大于previous proposal number seen），并发送给所有的acceptor（当然理论上发送给半数以上就可以了，但这是为了更保险）</li><li>acceptor收到消息后，与自己已经做出承诺的proposal number比较，当N大于它时作出承诺，且当已经有接受的提案时返回额外的acceptedProposal和acceptedValue；否则拒绝或忽略。proposal收到半数以上的promise后，认为可以进入accept阶段（这里就会更新已作出承诺的proposal number，而acceptedProposal还没更新）</li></ul></li><li>accept:<ul><li>proposal收到多数派后，选择acceptedProposal最大的哪个acceptedValue，否则才能由自己决定value，并发送消息给多数派</li><li>acceptor收到消息后，还是要检查N是否大于已作出承诺的proposal number，通过后再更新acceptedProposal和acceptedValue（注意这里才更新acceptedProposal）</li></ul></li></ul><p>可以认为slot, one single-decree paxos, client request一一对应；而被拒绝的request后续会对应到新的slot和single-decree paxos上去；而learner一般只读，作为一个可选的部分，在系统紧张时才参与进来；在phase 1结束后，那个获得多数派承诺的proposer成为leader，直到它挂了</p><p>一个简单的理解是proposal number用于选举唯一的write(leader)，而single-decree paxos是为了让leader知道它现在不再是唯一的writer了</p><img src="/2025/11/06/CSE-lecture14-2PC-Replication/fb6ff2eaaa7526c0339c6b0d5944e82a.png" class="" title="paxos pseudo-code"><p>举个例子，假设现在有三个acceptor A, B, C，其中A和B也是proposer：</p><ul><li>A发送&lt;prepare, 1&gt;，得到A和C的响应</li><li>A发送&lt;accecpt, 1, “foo”&gt;给A和C并得到响应，此时A得到多数派响应，认为”foo”被选择；但A在给B发送&lt;accept, 1, “foo”&gt;前挂了</li><li>B发送&lt;prepare, 2&gt;并得到B和C的响应</li><li>B发送&lt;accept, 2, “bar”&gt;给B和C并得到响应，此时B得到多数派响应，因此认为”bar”被选择</li></ul><p>事实上上述流程并不会发生，这并不是说B不是多数派，而是”bar”不会覆写”foo”</p><img src="/2025/11/06/CSE-lecture14-2PC-Replication/502b70abeb37061a1f9ca58213e1a52a.png" class="" title="example question"><p>故在paxos，以下情况哪个让V被写入？</p><ul><li>leader收到了多数派的&lt;promise, …&gt;：还没有开始写value</li><li>多数派收到了&lt;accept, N, V&gt;：只是收到了，因为prepare-accept之间可能被人抢先；还有可能acceptor挂了</li><li>leader收到了多数派的&lt;accepted, …&gt;：现在才能确保V被写入</li></ul><p>paxos使用以下方法应对failure：</p><ul><li>acceptor在发送promise后挂了：acceptor需要记住 $N_h$</li><li>acceptor在收到accept后挂了：acceptor需要记住 $N_h$, $N_a$, $V_a$</li><li>leader在发送accept后挂了：重新生成一个 $M_n$ ，其不用被记住</li></ul><p>目前我们在没有view server的情况下也能正常运行，但让leader挂了后，就再也修改不了value了</p><h4 id="multi-paxos-agree-on-a-sequence-of-values"><a href="#multi-paxos-agree-on-a-sequence-of-values" class="headerlink" title="multi-paxos: agree on a sequence of values"></a>multi-paxos: agree on a sequence of values</h4><p>为每个log entry分配一个paxos(paxos instance)，当发起的paxos instance在别的acceptor里面已经有了value时，选择一个更大的paxos instance，直到找到一个没有value的paxos instance，但这样的方法导致了需要多次尝试，这反而在性能上不如primary-backup（多了一轮RPC）</p><p>paxos在只有一个确定的leader时，可以进行优化，即一次性bacth完所有的paxos instance来发起一次prepare，再依次进行accept</p><img src="/2025/11/06/CSE-lecture14-2PC-Replication/e6fa9eb877d7f5a87cb3d57c876b0618.png" class="" title="prepare message batching"><p>paxos其实是不需要leader也能保证正确性的，但leader可以加速实现</p><p>paxos的log可能会出现不连续的情况，维护更困难</p>]]></content>
    
    
    <categories>
      
      <category>计算机学习</category>
      
      <category>se专业课</category>
      
      <category>cse</category>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>se</tag>
      
      <tag>cse</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSE_lecture13:Transaction and Multi-site Transaction</title>
    <link href="/2025/11/06/CSE-lecture13-Transaction-and-Multi-site-Transaction/"/>
    <url>/2025/11/06/CSE-lecture13-Transaction-and-Multi-site-Transaction/</url>
    
    <content type="html"><![CDATA[<h2 id="Transaction-Multi-site-Transaction"><a href="#Transaction-Multi-site-Transaction" class="headerlink" title="Transaction &amp; Multi-site Transaction"></a>Transaction &amp; Multi-site Transaction</h2><h3 id="transaction-with-high-performance"><a href="#transaction-with-high-performance" class="headerlink" title="transaction with high-performance"></a>transaction with high-performance</h3><p>在读多写少的情况下，即大部分事务只读，且单个事务中读远多于写，OCC和2PL能实现很快的性能，但原生的OCC和2PL还不行</p><p>对于OCC来说，如果中途有数据被修改了，读修改前的状态就好了。因此引入versionedData，即snapshot</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Data</span>&#123;</span><br>    value: List&lt;VersionedData&gt;<br>    lock: <span class="hljs-type">lock_t</span><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VersionedData</span>&#123;</span><br>    value: u8[...]<br>    version: u64<br>&#125;<br></code></pre></td></tr></table></figure><p>在事务读之前维护一个时钟，即所有读只读某一个版本的数据，而写的时候需要引入新版本（这个版本应当约等于事务提交时间），可以使用global counter来FAA(fetch and add)时间戳，事务开始和提交时都需要FAA</p><p>对OCC的改进方法为，事务开始时获取开始时钟，从而确定read时的snapshot，而write还是要缓存在write set中；提交时获取提交时钟，write时的version为该时钟，并保留以前的snapshot；现在不需要再validate了</p><p>但snapshot可能出现写到一半就被别人FAA的问题，因此需要保证整个写都原子化</p><img src="/2025/11/06/CSE-lecture13-Transaction-and-Multi-site-Transaction/2a10913e0bbcaf4b5d118dc52db316e3.png" class="" title="partial snapshot example"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python">Commit(tx):<br>   <span class="hljs-keyword">for</span> record <span class="hljs-keyword">in</span> tx.write_set: <br>       lock(record)<br>   let commit_ts = FAA(global_counter)<br>   <span class="hljs-keyword">for</span> record <span class="hljs-keyword">in</span> tx.write_set:<br>       record.insert_new_version(commit_ts, ...) <br>       unlock(record) <br><br><br>Get(tx, record):<br>   <span class="hljs-keyword">while</span> record.is_locked():<br>         <span class="hljs-keyword">pass</span><br>   <span class="hljs-keyword">for</span> version,value <span class="hljs-keyword">in</span> record.sort_version_in_decreasing():<br>       <span class="hljs-keyword">if</span> version &lt;= tx.start_time: <br>          <span class="hljs-keyword">return</span> value <br><br></code></pre></td></tr></table></figure><p>注意要先拿锁，再commit FAA，否则还是会读到原来的snapshot</p><p>此时write还是可能出现漏加的情况，因此写操作不能从同一个snapshot来修改，因此还是需要validate</p><p>多版本并发控制(MVCC)的流程如下，即validate检查在start time后是否出现了新的snapshot：</p><img src="/2025/11/06/CSE-lecture13-Transaction-and-Multi-site-Transaction/0da1647616cfd053898f2fb2076a09d5.png" class="" title="MVCC"><p>MVCC实际上并没有保证before-or-after，由于validate阶段没有检查read，会出现写偏斜(write skew)</p><img src="/2025/11/06/CSE-lecture13-Transaction-and-Multi-site-Transaction/a3067afa7843695809f4232dd51fd880.png" class="" title="write skew anomaly"><p>为了保证conflict serializability，可以在read-write事务中检查read set，虽然会退化到OCC，但实际用的不少（因为读远多于写，而只读事务不用检查read set）；或者不考虑(snapshot isolation, SI)</p><h3 id="multi-site-transaction-multi-site-atomicity"><a href="#multi-site-transaction-multi-site-atomicity" class="headerlink" title="multi-site transaction &amp; multi-site atomicity"></a>multi-site transaction &amp; multi-site atomicity</h3><p>用于处理事务的partial failure，出现场景为跨机器访问数据（数据切块），此时希望全提交或全放弃</p><p>因此需要一个中心化的事务决定是否提交，即high-layer TX，具体操作单台机器的操作为low-layer TX，所有的low-layer TX要么全提交，要么都放弃</p><p>此时需要two-phase commit:</p><ul><li>preparation&#x2F;voting: low-layer TX只能tentatively commit&#x2F;abort，high-layer TX评估lower的情况</li><li>commitment: hight-layer决定low-layer是提交还是放弃</li></ul><img src="/2025/11/06/CSE-lecture13-Transaction-and-Multi-site-Transaction/b11cd266bc0dda09d03aeaa7de0947b2.png" class="" title="2PC"><img src="/2025/11/06/CSE-lecture13-Transaction-and-Multi-site-Transaction/279c7fb78c49ecc34f553a971aeedb4b.png" class="" title="2PC TX"><p>2PC会导致通信量增加，此时会出现unreliable communication，此时需要coordinator将abort&#x2F;commit的决定写入log，worker在收到coordinator的消息前都应该等待</p><p>prepare failure有以下情况：</p><ul><li>prepare消息丢失：超时就重发</li><li>prepare的ACK丢失：同上</li><li>prepare阶段worker挂了：让其他worker放弃</li><li>coordinator挂了：log中还没有决定，直接全放弃</li></ul><p>此时worker在恢复后，不能自己决定是否提交，而是询问coordinator，由coordinator决定</p><p>commit failure有以下情况：</p><ul><li>commit消息丢失：超时就重发</li><li>commit的ACK丢失：同上</li><li>commit阶段worker挂了：恢复后向coordinator询问是否提交</li><li>coordinator挂了：根据log重做所有的提交，可能出现某些worker多次收到提交，第二次收到时由于已经提交，直接返回就好</li></ul><p>low-layer TX需要等到coordinator决定提交后才放2PL锁，而coordinator已经帮OCC做了validate &amp; commit阶段；lower-layer TX的log需要标记为partial-checkpoint，此时还不能清理</p>]]></content>
    
    
    <categories>
      
      <category>计算机学习</category>
      
      <category>se专业课</category>
      
      <category>cse</category>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>se</tag>
      
      <tag>cse</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSE_lecture12:Transaction</title>
    <link href="/2025/11/05/CSE-lecture12-Transaction/"/>
    <url>/2025/11/05/CSE-lecture12-Transaction/</url>
    
    <content type="html"><![CDATA[<h2 id="Serializability-OCC-Transaction"><a href="#Serializability-OCC-Transaction" class="headerlink" title="Serializability, OCC &amp; Transaction"></a>Serializability, OCC &amp; Transaction</h2><h3 id="OCC-optimistic-concurrency-control"><a href="#OCC-optimistic-concurrency-control" class="headerlink" title="OCC: optimistic concurrency control"></a>OCC: optimistic concurrency control</h3><p>死锁难以解决，因此需要避免，可以引入乐观并发控制(OCC)，其认为数据不会被race condition，因此不用拿锁，检查结果，如果真的发生race condition就放弃并重试</p><p>OCC执行事务分为以下三个阶段：</p><ul><li>并发本地控制：不上锁，读数据放入read set，写操作进行缓存而非直接写，放入write set</li><li>操作完成后进行可串行化检查：检查read set里面的数据是否被别人修改</li><li>检查失败就放弃，成功就将write set写入磁盘</li></ul><p>只通过数据的值来判断race condition是有问题的，因为可能被另一个事务修改过后又被第三个事务改回去了，因此需要维护一个严格递增的version</p><p>OCC还需要保证单个数据的读取是原子性的，一种方法是拿锁，另一种方法是最先拿version，读取数据的值后再检查version是否变化</p><p>写操作时在更新write set后，需要更新read set，保证后续read能读到write后的值</p><p>OCC的阶段2(validation)和阶段3(abort&#x2F;commitment)也要保证before-or-after，是不能拆开的，即实现一整个critical section，可以上一个全局锁，也可以为每个set里的数据上2PL锁，但缺点是没有规避死锁，以及拿锁有开销</p><p>死锁的解决方法为按照从小到大的顺序拿锁，在OCC可以这样做，因为提交阶段可以确定所有的操作，因此直接排序就好了；而为了优化拿锁的开销，可以不拿read set的锁，因为validation本身就是一个隐形的锁</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">validate_and_commit</span>() // phase <span class="hljs-number">2</span> &amp; <span class="hljs-number">3</span><br>    <span class="hljs-keyword">for</span> d <span class="hljs-keyword">in</span> <span class="hljs-built_in">sorted</span>(write-<span class="hljs-built_in">set</span>):<br>        d.lock()<br>    <span class="hljs-keyword">for</span> d <span class="hljs-keyword">in</span> read-<span class="hljs-built_in">set</span>:<br>        <span class="hljs-keyword">if</span> d has changed:<br>            abort()<br>    <span class="hljs-keyword">for</span> d <span class="hljs-keyword">in</span> write-<span class="hljs-built_in">set</span>:<br>        write(d)<br>    // release th locks<br></code></pre></td></tr></table></figure><p>上述代码并非没有问题，可能出现read-write conflict</p><img src="/2025/11/05/CSE-lecture12-Transaction/06a4583155966443a7149c8563b188f4.png" class="" title="read-write conflict"><p>因此在validation阶段需要检查是否上锁：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">validate_and_commit</span>() // phase <span class="hljs-number">2</span> &amp; <span class="hljs-number">3</span> <span class="hljs-keyword">with</span> before-<span class="hljs-keyword">or</span>-after<br>    <span class="hljs-keyword">for</span> d <span class="hljs-keyword">in</span> <span class="hljs-built_in">sorted</span>(write-<span class="hljs-built_in">set</span>):<br>        d.lock()<br>    <span class="hljs-keyword">for</span> d <span class="hljs-keyword">in</span> read-<span class="hljs-built_in">set</span>:<br>        <span class="hljs-keyword">if</span> d has changed <span class="hljs-keyword">or</span> d has been locked:<br>            abort()<br>    <span class="hljs-keyword">for</span> d <span class="hljs-keyword">in</span> write-<span class="hljs-built_in">set</span>:<br>        write(d)<br>    // release th locks<br></code></pre></td></tr></table></figure><p>OCC的好处在于能减少拿锁的开销，因为拿锁的开销是很大的，尤其是相较于read</p><p>但OCC也有问题，即不必要的放弃，对于没有环的两个事务，OCC因为只能允许某一种顺序，会放弃其他可以等效串行化的顺序</p><img src="/2025/11/05/CSE-lecture12-Transaction/f40ccfa8cbf1fc4dfddfc135be4a2952.png" class="" title="false aborts"><p>当read非常多时，放弃的概率会更高，这会引发活锁，即事务在反复重试</p><p>低并发情况下OCC吞吐量更高，高并发情况下2PL更高，但性能都下降了</p><p>使用fast path和slow path，使用fast path加速，并进行validate，失败再采用slow path，这建立在两个假设：fast path + validate加起来快于slow path，且fast path常见</p><p>在LLM中，要加速很大的模型的推理速度，可以先用小模型推理，再用大的模型验证，验证失败再重新让大的模型推理</p><p>Hardware Transactional Memory(HTM)是一种用于多并发的新CPU特性，在intel中为RTM(Restricted Transactional Memory)，提供了两个指令：<code>xbegin</code>和<code>xend</code>，当出现race condition时会放弃并返回abort code，而直接重试不能解决问题，因为RTM本质也是OCC</p><p>在RTM中，使用cache来记录read&#x2F;write sets来防止外泄，其修改时就会广播，从而知道发生了race condition，这限制了read&#x2F;write sets的大小；另一方面，操作系统中线程会定期中断并切换，此时cache会刷到内存，而这会导致数据泄露，RTM会直接放弃</p><p>对于简单的操作，HTM比软件层面的OCC性能更高，但一旦复杂起来就表现很差了</p><h3 id="transactions"><a href="#transactions" class="headerlink" title="transactions"></a>transactions</h3><p>事务是一个管理数据的抽象，其保证了ACID(Atomicity, consistency, isolation, durability)</p><p>atomicity保证了all-or-nothing，isolation保证了before-or-after，durability保证了事务提交后，数据能被持久化</p><p>consistency和atomicity不同，其是面向用户的，即数据库只管理atomicity，而应用层保证用户定义的consistency，比如转账时银行总金额不变。但一般而言consistency和atomicity + isolation关联很强</p><p>目前OCC和2PL不能达到要求，但在特殊情况下它们可以很快</p>]]></content>
    
    
    <categories>
      
      <category>计算机学习</category>
      
      <category>se专业课</category>
      
      <category>cse</category>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>se</tag>
      
      <tag>cse</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSE_lecture11:Before or after atomicity</title>
    <link href="/2025/11/05/CSE-lecture11-Before-or-after-atomicity/"/>
    <url>/2025/11/05/CSE-lecture11-Before-or-after-atomicity/</url>
    
    <content type="html"><![CDATA[<h2 id="Before-or-after-atomicity-and-Serializability"><a href="#Before-or-after-atomicity-and-Serializability" class="headerlink" title="Before-or-after atomicity and Serializability"></a>Before-or-after atomicity and Serializability</h2><p>并发能提升吞吐量，但是会危害正确性，因此需要引入before-or-after模型</p><p>假设有一个单线程的银行系统，此时请求响应的时间不会仅由RPC和请求处理时间的时间决定，而是由吞吐量决定的。当有多个请求发过来时，请求会陷入排队，出队后才会处理，因此当request arrival rate大于system throughput时，延迟会爆炸</p><p>使用concurrency来scaling throughput：</p><ul><li>scale-up: 一台机器跑多线程</li><li>scale-out: 多台机器并发运行</li></ul><p>但并发操作容易引发正确性问题：</p><img src="/2025/11/05/CSE-lecture11-Before-or-after-atomicity/9ae51ac6e118f6b85e11b9b1abcf766c.png" class="" title="race condition"><p>race condition难以控制，同时不确定性导致难以发现和debug</p><p>保证在并发情况下，能够让效果等价于一系列操作的串行执行，因此需要维护一些操作整体为原子的，挡住可能会引发race condition的其他操作</p><p>使用全局锁(global lock)可以达到这个效果，但会导致性能很差，如导致不会引发race contidion的操作阻塞，以及拿锁本身也会有开销。因此需要减小锁的范围，比如不同的数据记录（如不同账户）使用不同的锁(fine-grained lock)，但缺点是不能严格保证before-or-after，如存在访问多个数据的操作</p><img src="/2025/11/05/CSE-lecture11-Before-or-after-atomicity/dc58cfd6cbc36b4bbde1109078932e9c.png" class="" title="accessing multiple records"><p>对于要处理多个数据的操作，应当在开头拿到所有锁，在结尾才释放掉所有锁</p><img src="/2025/11/05/CSE-lecture11-Before-or-after-atomicity/0c6e78a463ada00690344a1b30d4697b.png" class="" title="acquire all locks first, and release them at last"><p>这样的缺点是拿锁的时间会非常长，因此引入two-phase locking(2PL)，即只保证操作在释放某一个锁后不再拿任何新的锁，此时可以实现不在一开头拿完所有锁，也不用在最后才释放所有锁</p><p>global lock, fine-grained lock, 2PL lock都能保证before-or-after atomicity</p><p>判别是否保证before-or-after的一种方法是能否找到一个等价的串行执行，这不仅要保证写的正确性，也要保证读的正确性，即判别view serializability时，需要找到一个view equivalent的serial schedule，满足每个操作的读正确，最终写正确</p><p>而view serializability在操作极多时无法检查，因此使用conflict serializability，定义conflict为：</p><ul><li>两个操作都在操作同一个数据</li><li>至少有一个在写</li><li>属于不同的事务</li></ul><p>conflict serializability只需要找到所有conflict的顺序等价于某一个串行的conflict关系。可以认为事务是节点，conflict是有向边（方向为第一个操作发生在哪个事务中），只要其为无环图，就能找到一个拓扑排序，从而实现conflict serializability</p><img src="/2025/11/05/CSE-lecture11-Before-or-after-atomicity/497c9e20e7ba2156b8884c8dd142b907.png" class="" title="conflict serializability"><p>但事实上就算有环，也可以找到一个等价的串行执行（写最终正确，每个操作的读正确），因此认为 $\text{view serializability} \supset \text{conflict serializability}$ ，conflict serializability虽然定义更严格，但实现更容易</p><p>2PL能够实现conflict serializability，可以用反证法证明</p><img src="/2025/11/05/CSE-lecture11-Before-or-after-atomicity/c530ec45c0012f1bbd2d044c35cf8c25.png" class="" title="proof of 2PL"><p>然而2PL其实并不见得一定能保证conflict serializability，因为可能出现错拿锁漏拿锁，比如下图新插入的老师没有涨薪，因为锁是存在在成员内部的，即幻读问题(phantom problem)</p><img src="/2025/11/05/CSE-lecture11-Before-or-after-atomicity/d345ab3b5e149d0ee280271110311b8d.png" class="" title="phantom problem"><p>解决幻读问题可以用以下方法：</p><ul><li>谓词锁(predicate lock)，即锁住满足某个条件的所有数据，但开销大</li><li>为B树非叶子节点上锁，实现范围上锁，或锁住整张表</li><li>忽略</li></ul><p>2PL的另一个问题就是死锁。2PL本身是一个悲观锁(pessimistic)，即认为race condition一定发生，故访问数据前一定上锁，但这样可能引发死锁，即互相等待对方释放锁</p><img src="/2025/11/05/CSE-lecture11-Before-or-after-atomicity/3aec3c88631164596f4a50c9e4a4c30f.png" class="" title="deadlock"><p>死锁的解决方法如下，但事实上都各有各的问题：</p><ul><li>让大家都按照同一个顺序访问各个数据(pre-defined order)，但难以提前知道要访问哪些数据</li><li>找到环，并放弃环中的一个事务，但开销极大，而且该事务重做后可能再次被放弃</li><li>超时后就放弃</li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机学习</category>
      
      <category>se专业课</category>
      
      <category>cse</category>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>se</tag>
      
      <tag>cse</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSE_lab2攻略</title>
    <link href="/2025/10/25/CSE-lab2%E6%94%BB%E7%95%A5/"/>
    <url>/2025/10/25/CSE-lab2%E6%94%BB%E7%95%A5/</url>
    
    <content type="html"><![CDATA[<h2 id="lab2-Distributed-FileSystem"><a href="#lab2-Distributed-FileSystem" class="headerlink" title="lab2: Distributed FileSystem"></a>lab2: Distributed FileSystem</h2><p>在lab1中，我们已经实现了基本的inode filesystem，并能够操作directory；而在lab2中，我们需要实现一个分布式的文件系统，该系统分为以下三部分，它们通过rpc进行通信：</p><ul><li>filesystem client: 文件系统服务器，向metadata server发送请求获取元数据，再向各个data server发送请求修改具体的block</li><li>metadata server: 只有一台，用于存放元数据</li><li>data server: 有很多台，存放具体的block</li></ul><p>在lab2中有两种文件类型：regular file和directory，其中regular file被拆成一个或多个块，存放在不同的data server上；而directory block则放在metadata server上</p><p>lab2需要运行三种测试，这需要进入docker环境，在<code>chfs</code>目录下启动docker：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker start -a -i chfs<br></code></pre></td></tr></table></figure><p>进入docker环境后，在<code>build</code>目录下输入以下指令来编译代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">cmake ..<br>make -j<br>make build-tests -j<br></code></pre></td></tr></table></figure><p>对于单元测试，执行以下指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">make <span class="hljs-built_in">test</span> -j<br></code></pre></td></tr></table></figure><p>对于压力测试，执行以下指令，该测试执行速度很慢：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">make run_concurrent_stress_test<br></code></pre></td></tr></table></figure><p>如遇失败，使用以下指令清理残留的中间状态，防止下一次测试又失败：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">make clean-fs<br></code></pre></td></tr></table></figure><p>而集成测试比较麻烦，需要额外设置环境，在<code>scripts/lab2</code>目录下执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># pull cse-lab2-base image</span><br>docker pull registry.cn-shenzhen.aliyuncs.com/cse-lab/cse-lab2-base<br><span class="hljs-comment"># rename the image</span><br>docker tag registry.cn-shenzhen.aliyuncs.com/cse-lab/cse-lab2-base cse-lab2-base<br><span class="hljs-comment"># set up the environment</span><br>docker compose up<br></code></pre></td></tr></table></figure><p>这时终端会停在某一页面，这反而说明<code>docker compose</code>成功，新建一个终端并执行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">exec</span> -it lab2-fs_client-1 bash<br></code></pre></td></tr></table></figure><p>进入docker容器后，在<code>scripts/lab2</code>目录下执行以下指令，如果遇到权限问题，使用<code>chmod +x ...</code>赋予相应文件执行权限：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./integration_test.sh<br></code></pre></td></tr></table></figure><p>注意运行集成测试后，无论成功与否，都需要清理容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">rm</span> -f lab2-fs_client-1 lab2-data-1 lab2-meta-1<br></code></pre></td></tr></table></figure><p>三个测试都通过后即可提交</p><p>接下来提供lab2的攻略，在lab2中，阅读头文件，使用lab1已经实现的api尤为关键。<strong>注意：本攻略未实现选做部分，即part 3</strong></p><h3 id="part-1-distributed-filesystem"><a href="#part-1-distributed-filesystem" class="headerlink" title="part 1: distributed filesystem"></a>part 1: distributed filesystem</h3><h4 id="part-1A-data-server"><a href="#part-1A-data-server" class="headerlink" title="part 1A: data server"></a>part 1A: data server</h4><p>data server的操作都是以单个block为单元的，这是因为每个文件的所有block都分散在不同的data server上。因此，在这一部分，我们也只需要操作单个block即可。注意：在这一部分我们还暂时不实现版本号</p><p>阅读<code>dataserver.h</code>可知，我们可以使用lab1就已经实现的<code>block_allocator_</code>，而<code>BlockAllocator</code>类有成员<code>bm</code>，从而保证我们可以使用已经实现的块分配和块读写</p><p>首先是<code>read_data</code>，与<code>BlockManager</code>不同，这次我们不是一次读取一整个块，而是只读取其中的一部分。因此我们使用<code>bm</code>将整个块读取出来，再返回我们需要的那一部分</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">DataServer::read_data</span><span class="hljs-params">(<span class="hljs-type">block_id_t</span> block_id, usize offset, usize len,</span></span><br><span class="hljs-params"><span class="hljs-function">                           <span class="hljs-type">version_t</span> version)</span> -&gt; std::vector&lt;u8&gt; </span>&#123;<br>  <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Implement this function.</span><br>  <span class="hljs-built_in">CHFS_ASSERT</span>(offset + len &lt;= block_allocator_-&gt;bm-&gt;<span class="hljs-built_in">block_size</span>(),<br>              <span class="hljs-string">&quot;Invalid offset or length&quot;</span>);<br>  <span class="hljs-function">std::vector&lt;u8&gt; <span class="hljs-title">buffer</span><span class="hljs-params">(block_allocator_-&gt;bm-&gt;block_size())</span></span>;<br>  <span class="hljs-keyword">auto</span> res = block_allocator_-&gt;bm-&gt;<span class="hljs-built_in">read_block</span>(block_id, buffer.<span class="hljs-built_in">data</span>());<br>  <span class="hljs-built_in">CHFS_ASSERT</span>(res.<span class="hljs-built_in">is_ok</span>(), <span class="hljs-string">&quot;Failed to read block&quot;</span>);<br><br>  <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">vector</span>&lt;u8&gt;(buffer.<span class="hljs-built_in">begin</span>() + offset, buffer.<span class="hljs-built_in">begin</span>() + offset + len);<br>&#125;<br></code></pre></td></tr></table></figure><p>而<code>write_data</code>相对更简单，因为在<code>bm</code>中已经实现了<code>write_partial_block</code>了，直接调用即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">DataServer::write_data</span><span class="hljs-params">(<span class="hljs-type">block_id_t</span> block_id, usize offset,</span></span><br><span class="hljs-params"><span class="hljs-function">                            std::vector&lt;u8&gt; &amp;buffer)</span> -&gt; <span class="hljs-type">bool</span> </span>&#123;<br>  <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Implement this function.</span><br>  <span class="hljs-keyword">auto</span> res = block_allocator_-&gt;bm-&gt;<span class="hljs-built_in">write_partial_block</span>(block_id, buffer.<span class="hljs-built_in">data</span>(), offset, buffer.<span class="hljs-built_in">size</span>());<br>  <span class="hljs-keyword">if</span> (res.<span class="hljs-built_in">is_ok</span>()) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后<code>alloc_block</code>和<code>free_block</code>直接调用<code>block_allocator_</code>的对应api即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">DataServer::alloc_block</span><span class="hljs-params">()</span> -&gt; std::pair&lt;<span class="hljs-type">block_id_t</span>, <span class="hljs-type">version_t</span>&gt; </span>&#123;<br>  <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Implement this function.</span><br>  <span class="hljs-keyword">auto</span> res = block_allocator_-&gt;<span class="hljs-built_in">allocate</span>();<br>  <span class="hljs-keyword">if</span> (res.<span class="hljs-built_in">is_ok</span>()) &#123;<br>    <span class="hljs-type">block_id_t</span> block_id = res.<span class="hljs-built_in">unwrap</span>();<br>    version = <span class="hljs-number">0</span> <span class="hljs-comment">// 仅占位</span><br>    <span class="hljs-keyword">return</span> &#123;block_id, version + <span class="hljs-number">1</span>&#125;;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> &#123;&#125;;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">DataServer::free_block</span><span class="hljs-params">(<span class="hljs-type">block_id_t</span> block_id)</span> -&gt; <span class="hljs-type">bool</span> </span>&#123;<br>  <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Implement this function.</span><br>  <span class="hljs-keyword">auto</span> res = block_allocator_-&gt;<span class="hljs-built_in">deallocate</span>(block_id);<br>  <span class="hljs-keyword">if</span> (res.<span class="hljs-built_in">is_ok</span>()) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>基于lab1实现这一部分很轻松，现在我们可以通过以下单元测试：</p><ul><li><code>DataServerTest.ReadAndWrite</code></li></ul><p>注意<code>DataServerTest.AllocateAndDelete</code>暂时通过不了，因为该测试涉及到了版本号的判断</p><h4 id="part-1B-metadata-server"><a href="#part-1B-metadata-server" class="headerlink" title="part 1B: metadata server"></a>part 1B: metadata server</h4><p>这一部分要求我们实现metadata server，因此先要搞清楚metadata server的架构：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">| Boot block | Super block | Inode Table | Inode Bitmap | Free block Bitmap | Directory blocks |<br></code></pre></td></tr></table></figure><p>这里不必太在乎inode table与inode分离的问题，实际上metadata server的块架构与lab1的inode层架构是一致的，唯一的区别就是metadata server的data block只存放inode和directory，不会存放regular file</p><p>在lab1中经常传参<code>InodeType</code>，但我们并没有根据这个参数作分类讨论，现在需要用到这个了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">enum class</span> <span class="hljs-title class_">InodeType</span> : u32 &#123;<br>  Unknown = <span class="hljs-number">0</span>,<br>  FILE = <span class="hljs-number">1</span>,<br>  Directory = <span class="hljs-number">2</span>,<br>&#125;;<br></code></pre></td></tr></table></figure><p>可以注意到分为了<code>FILE</code>和<code>Directory</code>两种类型，其中<code>FILE</code>就是lab2需要额外讨论的regular file</p><p>我们先说directory，directory直接放在metadata server上，因此其inode和我们在lab1实现的并没有区别，还是多个direct block和一个indirect block，而它们存放的block id自然也是metadata server上的block id：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">| <span class="hljs-built_in">type</span> | FileAttr | Direct block <span class="hljs-built_in">id</span> | Indirect block <span class="hljs-built_in">id</span> |<br></code></pre></td></tr></table></figure><p>而regular file与我们在lab1中的实现有很大区别，由于regular file的各个块被分散在多台data server上，因此我们不仅要维护block id，还要维护mac id和version，即<code>using BlockInfo = std::tuple&lt;block_id_t, mac_id_t, version_t&gt;</code>，其架构如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">| <span class="hljs-built_in">type</span> | FileAttr | BlockInfo(block <span class="hljs-built_in">id</span> &amp; mac <span class="hljs-built_in">id</span> &amp; version) |<br></code></pre></td></tr></table></figure><p>这里需要再注意一下<code>FileAttr</code>，在lab1中框架代码已经帮我们实现了inode参数的处理，但由于现在我们需要额外实现regular file的处理函数，需要额外操作<code>FileAttr</code>了，至于如何操作，复用<code>data_op.cc</code>中<code>read_file</code>和<code>write_file</code>的框架代码即可：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">FileAttr</span> &#123;<br>  <span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Inode</span>;<br><br><span class="hljs-keyword">public</span>:<br>  u64 atime = <span class="hljs-number">0</span>;<br>  u64 mtime = <span class="hljs-number">0</span>;<br>  u64 ctime = <span class="hljs-number">0</span>;<br>  u64 size = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">set_mtime</span><span class="hljs-params">(u64 t)</span> </span>&#123; mtime = t; &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">set_all_time</span><span class="hljs-params">(u64 t)</span> </span>&#123;<br>    atime = t;<br>    mtime = t;<br>    ctime = t;<br>  &#125;<br><br>&#125; __attribute__((packed));<br></code></pre></td></tr></table></figure><p>分析完metadata server的架构后，我们可以实现相应的代码了</p><p>首先，在正式实现<code>metadata_server.cc</code>中的函数之前，我们先在<code>FileOperation</code>类中添加以下函数，用于处理regular file的逻辑。因为<code>MetadataServer</code>类的函数基本都是靠调用成员<code>std::shared_ptr&lt;FileOperation&gt; operation_</code>来处理逻辑的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">add_block_mapping</span><span class="hljs-params">(<span class="hljs-type">inode_id_t</span> id, <span class="hljs-type">block_id_t</span> bid, <span class="hljs-type">mac_id_t</span> mac_id, <span class="hljs-type">version_t</span> version)</span></span><br><span class="hljs-function">      -&gt; ChfsNullResult</span>;<br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">remove_block_mapping</span><span class="hljs-params">(<span class="hljs-type">inode_id_t</span> id, <span class="hljs-type">block_id_t</span> bid)</span></span><br><span class="hljs-function">      -&gt; ChfsNullResult</span>;<br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">get_block_mapping</span><span class="hljs-params">(<span class="hljs-type">inode_id_t</span> id)</span></span><br><span class="hljs-function">      -&gt; ChfsResult&lt;std::vector&lt;std::tuple&lt;<span class="hljs-type">block_id_t</span>, <span class="hljs-type">mac_id_t</span>, <span class="hljs-type">version_t</span>&gt;&gt;&gt;</span>;<br></code></pre></td></tr></table></figure><p>这是因为regular file的inode与lab1实现的区别就是block id的存放逻辑，即block mapping，这需要我们在<code>Inode</code>类进行添加：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 用于metadata server中的directory和regular file两种类型的inode</span><br><span class="hljs-comment">// 使用type进行区分</span><br>[[maybe_unused]] <span class="hljs-type">block_id_t</span> blocks[<span class="hljs-number">0</span>];<br>[[maybe_unused]] std::tuple&lt;<span class="hljs-type">block_id_t</span>, <span class="hljs-type">mac_id_t</span>, <span class="hljs-type">version_t</span>&gt; blocks_map[<span class="hljs-number">0</span>];<br></code></pre></td></tr></table></figure><p>其中blocks原来就有，给directory使用即可；我们添加的是blocks_map，用于regular file（maybe_unused其实就是在暗示）</p><p>注意到我们分配的数组大小为0，这是一种柔性数组写法，当Inode buffer空间开的足够大时，我们就可以通过指针来访问数组而不越界，但缺点在于blocks和blocks_map的起始地址一样，因此建议不要为block_id, mac_id, version各开一个数组，否则会出现覆写问题</p><p>这里我们认为blocks_map数组的实际大小就是block_num，因此blocks_map不应当出现空洞才对，从而保证添加新的block时，直接追加即可，同时节约了空间，防止无限遍历（真正读写文件时并不用担心出现空洞的问题，因为不会突然释放中间的block）</p><p>现在我们回到<code>data_op.cc</code>中来实现这三个处理blocks_map的函数。首先是<code>add_block_mapping</code>，步骤为：</p><ul><li>读取inode信息，参考<code>write_file</code>的框架代码即可</li><li>找到第一个空闲的位置，这里其实可以简化为在末尾追加即可（代码有历史残留），同时我们需要修改inner_attr中的size，这是我们判断block_num的重要依据</li><li>处理一下inner_attr，写回inode所在的block，同样参考<code>write_file</code>即可</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">FileOperation::add_block_mapping</span><span class="hljs-params">(<span class="hljs-type">inode_id_t</span> id, <span class="hljs-type">block_id_t</span> bid, <span class="hljs-type">mac_id_t</span> mac_id, <span class="hljs-type">version_t</span> version)</span> -&gt; ChfsNullResult </span>&#123;<br>  <span class="hljs-comment">// 1. 读取inode信息</span><br>  <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> block_size = <span class="hljs-keyword">this</span>-&gt;block_manager_-&gt;<span class="hljs-built_in">block_size</span>();<br>  <span class="hljs-function">std::vector&lt;u8&gt; <span class="hljs-title">inode</span><span class="hljs-params">(block_size)</span></span>;<br>  <span class="hljs-keyword">auto</span> inode_p = <span class="hljs-built_in">reinterpret_cast</span>&lt;Inode *&gt;(inode.<span class="hljs-built_in">data</span>());<br>  <span class="hljs-keyword">auto</span> inode_res = <span class="hljs-keyword">this</span>-&gt;inode_manager_-&gt;<span class="hljs-built_in">read_inode</span>(id, inode);<br>  <span class="hljs-keyword">if</span> (inode_res.<span class="hljs-built_in">is_err</span>()) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">ChfsNullResult</span>(inode_res.<span class="hljs-built_in">unwrap_error</span>());<br>  &#125;<br>  <span class="hljs-comment">// 注意需要判断类型</span><br>  <span class="hljs-keyword">if</span> (inode_p-&gt;<span class="hljs-built_in">get_type</span>() != InodeType::FILE) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">ChfsNullResult</span>(ErrorType::INVALID_ARG);<br>  &#125;<br>  <span class="hljs-comment">// 2. 找到第一个空闲的位置，添加映射</span><br>  usize file_sz = inode_p-&gt;<span class="hljs-built_in">get_size</span>();<br>  usize block_num = <span class="hljs-built_in">calculate_block_sz</span>(file_sz, block_size);<br>  <span class="hljs-comment">// 防止溢出</span><br>  <span class="hljs-keyword">if</span> (block_num &gt;= inode_p-&gt;<span class="hljs-built_in">max_file_sz_supported</span>() / block_size) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">ChfsNullResult</span>(ErrorType::OUT_OF_RESOURCE);<br>  &#125;<br>  <span class="hljs-comment">// 由于remove直接将block位置设为无效，因此这里直接找到第一个无效的位置，而不是追加到末尾（写错了懒得改了）</span><br>  usize i = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span>(; i &lt; block_num; ++i) &#123;<br>    <span class="hljs-keyword">if</span> (std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">0</span>&gt;(inode_p-&gt;blocks_map[i]) == KInvalidBlockID) &#123;<br>      <span class="hljs-comment">// 找到空闲位置，添加映射</span><br>      inode_p-&gt;blocks_map[i] = std::<span class="hljs-built_in">make_tuple</span>(bid, mac_id, version);<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (i == block_num) &#123;<br>    <span class="hljs-comment">// 没有找到空闲位置，添加到末尾</span><br>    inode_p-&gt;blocks_map[block_num] = std::<span class="hljs-built_in">make_tuple</span>(bid, mac_id, version);<br>  &#125;<br>  inode_p-&gt;inner_attr.size += block_size;<br>  inode_p-&gt;inner_attr.mtime = <span class="hljs-built_in">time</span>(<span class="hljs-number">0</span>);<br>  <span class="hljs-comment">// 3. 写回inode信息</span><br>  inode_p-&gt;inner_attr.<span class="hljs-built_in">set_all_time</span>(<span class="hljs-built_in">time</span>(<span class="hljs-number">0</span>));<br>  <span class="hljs-keyword">auto</span> write_res =<br>      <span class="hljs-keyword">this</span>-&gt;block_manager_-&gt;<span class="hljs-built_in">write_block</span>(inode_res.<span class="hljs-built_in">unwrap</span>(), inode.<span class="hljs-built_in">data</span>());<br>  <span class="hljs-keyword">if</span> (write_res.<span class="hljs-built_in">is_err</span>()) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">ChfsNullResult</span>(write_res.<span class="hljs-built_in">unwrap_error</span>());<br>  &#125;<br>  <span class="hljs-keyword">return</span> KNullOk;<br>&#125;<br></code></pre></td></tr></table></figure><p>而<code>remove_block_mapping</code>步骤类似，遍历blocks_map，找到block_id对应的条目并将其设置为KInvalidBlockID即可，但为了避免空洞问题，需要将其后面的条目前移一格，从而覆写该条目（其实还需要将遍历完后末尾的条目设置为KInvalidBlockID，但由于block_num限制了范围，保证了我们不会读取到末尾，后续add时覆写即可）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">FileOperation::remove_block_mapping</span><span class="hljs-params">(<span class="hljs-type">inode_id_t</span> id, <span class="hljs-type">block_id_t</span> bid)</span> -&gt; ChfsNullResult </span>&#123;<br>  <span class="hljs-comment">// 1. 读取inode信息</span><br>  <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> block_size = <span class="hljs-keyword">this</span>-&gt;block_manager_-&gt;<span class="hljs-built_in">block_size</span>();<br>  <span class="hljs-function">std::vector&lt;u8&gt; <span class="hljs-title">inode</span><span class="hljs-params">(block_size)</span></span>;<br>  <span class="hljs-keyword">auto</span> inode_p = <span class="hljs-built_in">reinterpret_cast</span>&lt;Inode *&gt;(inode.<span class="hljs-built_in">data</span>());<br>  <span class="hljs-keyword">auto</span> inode_res = <span class="hljs-keyword">this</span>-&gt;inode_manager_-&gt;<span class="hljs-built_in">read_inode</span>(id, inode);<br>  <span class="hljs-keyword">if</span> (inode_res.<span class="hljs-built_in">is_err</span>()) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">ChfsNullResult</span>(inode_res.<span class="hljs-built_in">unwrap_error</span>());<br>  &#125;<br>  <span class="hljs-comment">// 注意需要判断类型</span><br>  <span class="hljs-keyword">if</span> (inode_p-&gt;<span class="hljs-built_in">get_type</span>() != InodeType::FILE) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">ChfsNullResult</span>(ErrorType::INVALID_ARG);<br>  &#125;<br>  <span class="hljs-comment">// 2. 找到需要移除的block</span><br>  <span class="hljs-type">bool</span> found = <span class="hljs-literal">false</span>;<br>  usize file_sz = inode_p-&gt;<span class="hljs-built_in">get_size</span>();<br>  usize block_num = <span class="hljs-built_in">calculate_block_sz</span>(file_sz, block_size);<br>  <span class="hljs-keyword">for</span> (usize i = <span class="hljs-number">0</span>; i &lt; block_num; ++i) &#123;<br>    <span class="hljs-keyword">if</span> (found)&#123;<br>      <span class="hljs-comment">// 向前移动一格，覆盖被删除的block，防止inode size与数组长度不匹配，同时避免空洞</span><br>      inode_p-&gt;blocks_map[i - <span class="hljs-number">1</span>] = inode_p-&gt;blocks_map[i];<br>      <span class="hljs-keyword">continue</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">0</span>&gt;(inode_p-&gt;blocks_map[i]) == bid) &#123;<br>      <span class="hljs-comment">// 找到后移除映射</span><br>      inode_p-&gt;blocks_map[i] = std::<span class="hljs-built_in">make_tuple</span>(KInvalidBlockID, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>      inode_p-&gt;inner_attr.size = (inode_p-&gt;inner_attr.size &gt; block_size) ? (inode_p-&gt;inner_attr.size - block_size) : <span class="hljs-number">0</span>;<br>      inode_p-&gt;inner_attr.mtime = <span class="hljs-built_in">time</span>(<span class="hljs-number">0</span>);<br>      found = <span class="hljs-literal">true</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (!found) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">ChfsNullResult</span>(ErrorType::INVALID_ARG);<br>  &#125;<br>  <span class="hljs-comment">// 3. 写回inode信息</span><br>  inode_p-&gt;inner_attr.<span class="hljs-built_in">set_all_time</span>(<span class="hljs-built_in">time</span>(<span class="hljs-number">0</span>));<br>  <span class="hljs-keyword">auto</span> write_res =<br>      <span class="hljs-keyword">this</span>-&gt;block_manager_-&gt;<span class="hljs-built_in">write_block</span>(inode_res.<span class="hljs-built_in">unwrap</span>(), inode.<span class="hljs-built_in">data</span>());<br>  <span class="hljs-keyword">if</span> (write_res.<span class="hljs-built_in">is_err</span>()) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">ChfsNullResult</span>(write_res.<span class="hljs-built_in">unwrap_error</span>());<br>  &#125;<br>  <span class="hljs-keyword">return</span> KNullOk;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>最后<code>get_block_mapping</code>省略写回inode步骤即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">FileOperation::get_block_mapping</span><span class="hljs-params">(<span class="hljs-type">inode_id_t</span> id)</span> -&gt; ChfsResult&lt;std::vector&lt;std::tuple&lt;<span class="hljs-type">block_id_t</span>, <span class="hljs-type">mac_id_t</span>, <span class="hljs-type">version_t</span>&gt;&gt;&gt; </span>&#123;<br>  <span class="hljs-comment">// 1. 读取inode信息</span><br>  <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> block_size = <span class="hljs-keyword">this</span>-&gt;block_manager_-&gt;<span class="hljs-built_in">block_size</span>();<br>  <span class="hljs-function">std::vector&lt;u8&gt; <span class="hljs-title">inode</span><span class="hljs-params">(block_size)</span></span>;<br>  <span class="hljs-keyword">auto</span> inode_p = <span class="hljs-built_in">reinterpret_cast</span>&lt;Inode *&gt;(inode.<span class="hljs-built_in">data</span>());<br>  <span class="hljs-keyword">auto</span> inode_res = <span class="hljs-keyword">this</span>-&gt;inode_manager_-&gt;<span class="hljs-built_in">read_inode</span>(id, inode);<br>  <span class="hljs-keyword">if</span> (inode_res.<span class="hljs-built_in">is_err</span>()) &#123;<br>    <span class="hljs-keyword">return</span> ChfsResult&lt;std::vector&lt;std::tuple&lt;<span class="hljs-type">block_id_t</span>, <span class="hljs-type">mac_id_t</span>, <span class="hljs-type">version_t</span>&gt;&gt;&gt;(inode_res.<span class="hljs-built_in">unwrap_error</span>());<br>  &#125;<br>  <span class="hljs-comment">// 注意需要判断类型</span><br>  <span class="hljs-keyword">if</span> (inode_p-&gt;<span class="hljs-built_in">get_type</span>() != InodeType::FILE) &#123;<br>    <span class="hljs-keyword">return</span> ChfsResult&lt;std::vector&lt;std::tuple&lt;<span class="hljs-type">block_id_t</span>, <span class="hljs-type">mac_id_t</span>, <span class="hljs-type">version_t</span>&gt;&gt;&gt;(ErrorType::INVALID_ARG);<br>  &#125;<br>  <span class="hljs-comment">// 2. 依次将映射压入到vector中</span><br>  std::vector&lt;std::tuple&lt;<span class="hljs-type">block_id_t</span>, <span class="hljs-type">mac_id_t</span>, <span class="hljs-type">version_t</span>&gt;&gt; mappings;<br>  usize file_sz = inode_p-&gt;<span class="hljs-built_in">get_size</span>();<br>  usize block_num = <span class="hljs-built_in">calculate_block_sz</span>(file_sz, block_size);<br>  <span class="hljs-keyword">for</span> (usize i = <span class="hljs-number">0</span>; i &lt; block_num; ++i) &#123;<br>    <span class="hljs-keyword">if</span> (std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">0</span>&gt;(inode_p-&gt;blocks_map[i]) != KInvalidBlockID) &#123;<br>      mappings.<span class="hljs-built_in">emplace_back</span>(std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">0</span>&gt;(inode_p-&gt;blocks_map[i]),<br>                            std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">1</span>&gt;(inode_p-&gt;blocks_map[i]),<br>                            std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">2</span>&gt;(inode_p-&gt;blocks_map[i]));<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> ChfsResult&lt;std::vector&lt;std::tuple&lt;<span class="hljs-type">block_id_t</span>, <span class="hljs-type">mac_id_t</span>, <span class="hljs-type">version_t</span>&gt;&gt;&gt;(std::<span class="hljs-built_in">move</span>(mappings));<br><br>&#125;<br></code></pre></td></tr></table></figure><p>现在我们终于分析并实现完regular file中的blocks_map逻辑，可以实现<code>metadata_server.cc</code>中的函数了。这里面的大部分函数都直接调用<code>operation_</code>中的对应api即可</p><p>首先是<code>mknode</code>，需要我们创建一个inode，给了parent，因此调用lab1实现的<code>operation_-&gt;mk_helper</code>即可：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">MetadataServer::mknode</span><span class="hljs-params">(u8 type, <span class="hljs-type">inode_id_t</span> parent, <span class="hljs-type">const</span> std::string &amp;name)</span></span><br><span class="hljs-function">    -&gt; <span class="hljs-type">inode_id_t</span> </span>&#123;<br>  <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Implement this function.</span><br>  <span class="hljs-comment">// 等效于调用 operation_ 的 mk_helper 方法</span><br>  <span class="hljs-keyword">auto</span> res = operation_-&gt;<span class="hljs-built_in">mk_helper</span>(parent, name.<span class="hljs-built_in">c_str</span>(), <span class="hljs-built_in">static_cast</span>&lt;InodeType&gt;(type));<br>  <span class="hljs-keyword">if</span> (res.<span class="hljs-built_in">is_ok</span>()) &#123;<br>    <span class="hljs-keyword">return</span> res.<span class="hljs-built_in">unwrap</span>();<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>关于<code>unlink</code>，在directory中删除文件，调用<code>operation_-&gt;unlink</code>即可：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">MetadataServer::unlink</span><span class="hljs-params">(<span class="hljs-type">inode_id_t</span> parent, <span class="hljs-type">const</span> std::string &amp;name)</span></span><br><span class="hljs-function">    -&gt; <span class="hljs-type">bool</span> </span>&#123;<br>  <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Implement this function.</span><br>  <span class="hljs-comment">// 等效于调用 operation_ 的 unlink 方法</span><br>  <span class="hljs-keyword">auto</span> res = operation_-&gt;<span class="hljs-built_in">unlink</span>(parent, name.<span class="hljs-built_in">c_str</span>());<br>  <span class="hljs-keyword">if</span> (res.<span class="hljs-built_in">is_ok</span>()) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>关于<code>lookup</code>函数，调用<code>operation_-&gt;lookup</code>即可：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">MetadataServer::lookup</span><span class="hljs-params">(<span class="hljs-type">inode_id_t</span> parent, <span class="hljs-type">const</span> std::string &amp;name)</span></span><br><span class="hljs-function">    -&gt; <span class="hljs-type">inode_id_t</span> </span>&#123;<br>  <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Implement this function.</span><br>  <span class="hljs-comment">// 等效于调用 operation_ 的 lookup 方法</span><br>  <span class="hljs-keyword">auto</span> res = operation_-&gt;<span class="hljs-built_in">lookup</span>(parent, name.<span class="hljs-built_in">c_str</span>());<br>  <span class="hljs-keyword">if</span> (res.<span class="hljs-built_in">is_ok</span>()) &#123;<br>    <span class="hljs-keyword">return</span> res.<span class="hljs-built_in">unwrap</span>();<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>而<code>allocate_block</code>是用于regular file的，步骤为：</p><ul><li>使用<code>metadata_server.h</code>中的<code>RandomNumberGenerator generator</code>来随机选择一个data server（注释其实已经告诉你了）</li><li>在data server中调用<code>alloc_block</code>函数，这需要用到rpc，在<code>RpcClient</code>中提供了<code>call</code>函数来帮助实现，从而得到block_id和version</li><li>调用<code>operation_-&gt;add_block_mapping</code>来将这个新的block压入inode中</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">MetadataServer::allocate_block</span><span class="hljs-params">(<span class="hljs-type">inode_id_t</span> id)</span> -&gt; BlockInfo </span>&#123;<br>  <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Implement this function.</span><br>  <span class="hljs-comment">// 向data server请求分配新块</span><br>  <span class="hljs-comment">// 随机选择一个data server</span><br>  u32 mac_id = generator.<span class="hljs-built_in">rand</span>(<span class="hljs-number">1</span>, num_data_servers);<br>  <span class="hljs-keyword">auto</span> client_it = clients_[mac_id];<br>  <span class="hljs-comment">// 使用rpc调用data server的alloc_block方法</span><br>  <span class="hljs-keyword">auto</span> rpc_res = client_it-&gt;<span class="hljs-built_in">call</span>(<span class="hljs-string">&quot;alloc_block&quot;</span>);<br>  <span class="hljs-keyword">if</span>(!rpc_res.<span class="hljs-built_in">is_ok</span>()) &#123;<br>    <span class="hljs-keyword">return</span> &#123;&#125;;<br>  &#125;<br>  <span class="hljs-keyword">auto</span> [block_id, version] = rpc_res.<span class="hljs-built_in">unwrap</span>()-&gt;as&lt;std::pair&lt;<span class="hljs-type">block_id_t</span>, <span class="hljs-type">version_t</span>&gt;&gt;();<br>  <span class="hljs-comment">// 在inode中更新这个block的信息</span><br>  <span class="hljs-keyword">auto</span> inode_res = operation_-&gt;<span class="hljs-built_in">add_block_mapping</span>(id, block_id, mac_id, version);<br>  <span class="hljs-keyword">if</span>(!inode_res.<span class="hljs-built_in">is_ok</span>()) &#123;<br>    <span class="hljs-keyword">return</span> &#123;&#125;;<br>  &#125;<br>  <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">make_tuple</span>(block_id, mac_id, version);<br>&#125;<br></code></pre></td></tr></table></figure><p>而<code>free_block</code>已经提供了machine_id，依次调用<code>client_it-&gt;call(&quot;free_block&quot;, block_id)</code>和<code>operation_-&gt;remove_block_mapping</code>即可：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">MetadataServer::free_block</span><span class="hljs-params">(<span class="hljs-type">inode_id_t</span> id, <span class="hljs-type">block_id_t</span> block_id,</span></span><br><span class="hljs-params"><span class="hljs-function">                                <span class="hljs-type">mac_id_t</span> machine_id)</span> -&gt; <span class="hljs-type">bool</span> </span>&#123;<br>  <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Implement this function.</span><br>  <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(block_mutex)</span></span>;<br>  <span class="hljs-comment">// 找到对应的data server移除block</span><br>  <span class="hljs-keyword">auto</span> client_it = clients_[machine_id];<br>  <span class="hljs-keyword">auto</span> rpc_res = client_it-&gt;<span class="hljs-built_in">call</span>(<span class="hljs-string">&quot;free_block&quot;</span>, block_id);<br>  <span class="hljs-keyword">if</span> (!rpc_res.<span class="hljs-built_in">is_ok</span>()) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br>  <span class="hljs-comment">// 在inode中移除这个block的信息</span><br>  <span class="hljs-keyword">auto</span> inode_res = operation_-&gt;<span class="hljs-built_in">remove_block_mapping</span>(id, block_id);<br>  <span class="hljs-keyword">if</span> (inode_res.<span class="hljs-built_in">is_ok</span>()) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>关于<code>readdir</code>，使用<code>directory_op.h</code>中提供的<code>read_directory</code>帮助函数即可：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">MetadataServer::readdir</span><span class="hljs-params">(<span class="hljs-type">inode_id_t</span> node)</span></span><br><span class="hljs-function">    -&gt; std::vector&lt;std::pair&lt;std::string, <span class="hljs-type">inode_id_t</span>&gt;&gt; </span>&#123;<br>  <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Implement this function.</span><br>  <span class="hljs-comment">// 使用directory_op的read_directory方法</span><br>  std::list&lt;DirectoryEntry&gt; entries;<br>  <span class="hljs-keyword">auto</span> res = <span class="hljs-built_in">read_directory</span>(operation_.<span class="hljs-built_in">get</span>(), node, entries);<br>  <span class="hljs-keyword">if</span> (res.<span class="hljs-built_in">is_err</span>()) <span class="hljs-keyword">return</span> &#123;&#125;;<br>  std::vector&lt;std::pair&lt;std::string, <span class="hljs-type">inode_id_t</span>&gt;&gt; result;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;entry : entries) &#123;<br>    result.<span class="hljs-built_in">emplace_back</span>(entry.name, entry.id);<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>关于<code>get_block_map</code>，调用<code>operation_-&gt;get_block_mapping</code>即可：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">MetadataServer::get_block_map</span><span class="hljs-params">(<span class="hljs-type">inode_id_t</span> id)</span> -&gt; std::vector&lt;BlockInfo&gt; </span>&#123;<br>  <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Implement this function.</span><br>  <span class="hljs-comment">// 等效于调用 operation_ 的 get_block_mapping方法</span><br>  <span class="hljs-keyword">auto</span> res = operation_-&gt;<span class="hljs-built_in">get_block_mapping</span>(id);<br>  <span class="hljs-keyword">if</span> (res.<span class="hljs-built_in">is_ok</span>()) &#123;<br>    <span class="hljs-keyword">return</span> res.<span class="hljs-built_in">unwrap</span>();<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> &#123;&#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后<code>get_type_attr</code>调用<code>operation_-&gt;get_type_attr</code>即可，这个函数不是我们自己实现的，注意两者返回的类型不一致，需要类型转换一下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">MetadataServer::get_type_attr</span><span class="hljs-params">(<span class="hljs-type">inode_id_t</span> id)</span></span><br><span class="hljs-function">    -&gt; std::tuple&lt;u64, u64, u64, u64, u8&gt; </span>&#123;<br>  <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Implement this function.</span><br>  <span class="hljs-keyword">auto</span> res = operation_-&gt;<span class="hljs-built_in">get_type_attr</span>(id);<br>  <span class="hljs-keyword">if</span> (res.<span class="hljs-built_in">is_ok</span>()) &#123;<br>    <span class="hljs-keyword">auto</span> [type, attr] = res.<span class="hljs-built_in">unwrap</span>();<br>    <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">make_tuple</span>(attr.size, attr.atime, attr.mtime, attr.ctime,<br>                           <span class="hljs-built_in">static_cast</span>&lt;u8&gt;(type));<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> &#123;&#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在，我们可以通过以下单元测试：</p><ul><li><code>MetadataServerTest.CreateDirThenLookup</code></li><li><code>MetadataServerTest.WriteAnEmptyFile</code></li><li><code>MetadataServerTest.CheckPersist</code></li><li><code>MetadataServerTest.CheckReadDir</code></li><li><code>MetadataServerTest.CheckUnlink</code></li></ul><h4 id="part-1C-filesystem-client"><a href="#part-1C-filesystem-client" class="headerlink" title="part 1C: filesystem client"></a>part 1C: filesystem client</h4><h5 id="part-1C-1-client-implement"><a href="#part-1C-1-client-implement" class="headerlink" title="part 1C.1: client implement"></a>part 1C.1: client implement</h5><p>现在我们来实现client，大部分时间，它都是直接访问metadata server的；而读写文件时，client先在metadata server上拿到blocks_map，再根据mac_id访问各个data server拿到需要的block</p><p>在实现前需要注意的是，client都是通过rpc来访问数据的，因此错误处理其实处理的是rpc调用成功与否；而无论是metadata server还是data server，其函数返回值基本都没有被ChfsResult包装过，而是使用特殊值返回的方法来返回错误，因此需要根据这些特殊值来进行错误处理（这里的错误处理用于metadata并发导致的错误，而block并发引发的version不一致返回空值即可，以迎合测试集）</p><p>首先是<code>mknode</code>，直接rpc到metadata server的<code>mknode</code>函数即可，错误处理为返回值为0（由lab1可知，这里的inode id是logic id，因此不可能是0）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">ChfsClient::mknode</span><span class="hljs-params">(FileType type, <span class="hljs-type">inode_id_t</span> parent,</span></span><br><span class="hljs-params"><span class="hljs-function">                        <span class="hljs-type">const</span> std::string &amp;name)</span> -&gt; ChfsResult&lt;<span class="hljs-type">inode_id_t</span>&gt; </span>&#123;<br>  <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Implement this function.</span><br>  <span class="hljs-keyword">auto</span> rpc_res = metadata_server_-&gt;<span class="hljs-built_in">call</span>(<span class="hljs-string">&quot;mknode&quot;</span>, <span class="hljs-built_in">static_cast</span>&lt;u8&gt;(type), parent, name);<br>  <span class="hljs-keyword">if</span> (rpc_res.<span class="hljs-built_in">is_ok</span>()) &#123;<br>    <span class="hljs-type">inode_id_t</span> new_inode = rpc_res.<span class="hljs-built_in">unwrap</span>()-&gt;<span class="hljs-built_in">as</span>&lt;<span class="hljs-type">inode_id_t</span>&gt;();<br>    <span class="hljs-keyword">if</span> (new_inode == <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">ChfsResult</span>&lt;<span class="hljs-type">inode_id_t</span>&gt;(ErrorType::AlreadyExist);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">ChfsResult</span>&lt;<span class="hljs-type">inode_id_t</span>&gt;(new_inode);<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">ChfsResult</span>&lt;<span class="hljs-type">inode_id_t</span>&gt;(rpc_res.<span class="hljs-built_in">unwrap_error</span>());<br>&#125;<br></code></pre></td></tr></table></figure><p>关于<code>unlink</code>，直接rpc到metadata server上调用<code>unlink</code>函数即可，错误处理为返回值为false</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">ChfsClient::unlink</span><span class="hljs-params">(<span class="hljs-type">inode_id_t</span> parent, std::string <span class="hljs-type">const</span> &amp;name)</span></span><br><span class="hljs-function">    -&gt; ChfsNullResult </span>&#123;<br>  <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Implement this function.</span><br>  <span class="hljs-keyword">auto</span> rpc_res = metadata_server_-&gt;<span class="hljs-built_in">call</span>(<span class="hljs-string">&quot;unlink&quot;</span>, parent, name);<br>  <span class="hljs-keyword">if</span> (rpc_res.<span class="hljs-built_in">is_err</span>()) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">ChfsNullResult</span>(rpc_res.<span class="hljs-built_in">unwrap_error</span>());<br>  &#125;<br>  <span class="hljs-keyword">if</span> (!rpc_res.<span class="hljs-built_in">unwrap</span>()-&gt;<span class="hljs-built_in">as</span>&lt;<span class="hljs-type">bool</span>&gt;()) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">ChfsNullResult</span>(ErrorType::NotExist);<br>  &#125;<br>  <span class="hljs-keyword">return</span> KNullOk;<br>&#125;<br></code></pre></td></tr></table></figure><p>关于<code>lookup</code>，通过rpc调用metadata server的<code>lookup</code>即可，错误处理为返回值为0，即inode id错误：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">ChfsClient::lookup</span><span class="hljs-params">(<span class="hljs-type">inode_id_t</span> parent, <span class="hljs-type">const</span> std::string &amp;name)</span></span><br><span class="hljs-function">    -&gt; ChfsResult&lt;<span class="hljs-type">inode_id_t</span>&gt; </span>&#123;<br>  <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Implement this function.</span><br>  <span class="hljs-keyword">auto</span> rpc_res = metadata_server_-&gt;<span class="hljs-built_in">call</span>(<span class="hljs-string">&quot;lookup&quot;</span>, parent, name);<br>  <span class="hljs-keyword">if</span> (rpc_res.<span class="hljs-built_in">is_ok</span>()) &#123;<br>    <span class="hljs-type">inode_id_t</span> inode = rpc_res.<span class="hljs-built_in">unwrap</span>()-&gt;<span class="hljs-built_in">as</span>&lt;<span class="hljs-type">inode_id_t</span>&gt;();<br>    <span class="hljs-keyword">if</span> (inode == <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">ChfsResult</span>&lt;<span class="hljs-type">inode_id_t</span>&gt;(ErrorType::NotExist);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">ChfsResult</span>&lt;<span class="hljs-type">inode_id_t</span>&gt;(inode);<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">ChfsResult</span>&lt;<span class="hljs-type">inode_id_t</span>&gt;(rpc_res.<span class="hljs-built_in">unwrap_error</span>());<br>&#125;<br></code></pre></td></tr></table></figure><p>关于<code>readdir</code>，通过rpc调用metadata server的<code>readdir</code>即可，考虑到directory确实可能为空，不必错误处理</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">ChfsClient::readdir</span><span class="hljs-params">(<span class="hljs-type">inode_id_t</span> id)</span></span><br><span class="hljs-function">    -&gt; ChfsResult&lt;std::vector&lt;std::pair&lt;std::string, <span class="hljs-type">inode_id_t</span>&gt;&gt;&gt; </span>&#123;<br>  <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Implement this function.</span><br>  <span class="hljs-keyword">auto</span> rpc_res = metadata_server_-&gt;<span class="hljs-built_in">call</span>(<span class="hljs-string">&quot;readdir&quot;</span>, id);<br>  <span class="hljs-keyword">if</span> (rpc_res.<span class="hljs-built_in">is_ok</span>()) &#123;<br>    <span class="hljs-keyword">auto</span> entries = rpc_res.<span class="hljs-built_in">unwrap</span>()-&gt;as&lt;std::vector&lt;std::pair&lt;std::string, <span class="hljs-type">inode_id_t</span>&gt;&gt;&gt;();<br>    <span class="hljs-keyword">return</span> ChfsResult&lt;std::vector&lt;std::pair&lt;std::string, <span class="hljs-type">inode_id_t</span>&gt;&gt;&gt;(entries);<br>  &#125;<br>  <span class="hljs-keyword">return</span> ChfsResult&lt;std::vector&lt;std::pair&lt;std::string, <span class="hljs-type">inode_id_t</span>&gt;&gt;&gt;(<br>      rpc_res.<span class="hljs-built_in">unwrap_error</span>());<br>&#125;<br></code></pre></td></tr></table></figure><p>关于<code>get_type_attr</code>，通过rpc调用metadata server的<code>get_type_attr</code>即可，错误处理为tuple返回为空，因为正常情况下不可能为空，注意两者返回类型也不一致，需要类型转换：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">ChfsClient::get_type_attr</span><span class="hljs-params">(<span class="hljs-type">inode_id_t</span> id)</span></span><br><span class="hljs-function">    -&gt; ChfsResult&lt;std::pair&lt;InodeType, FileAttr&gt;&gt; </span>&#123;<br>  <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Implement this function.</span><br>  <span class="hljs-keyword">auto</span> rpc_res = metadata_server_-&gt;<span class="hljs-built_in">call</span>(<span class="hljs-string">&quot;get_type_attr&quot;</span>, id);<br>  <span class="hljs-keyword">if</span> (rpc_res.<span class="hljs-built_in">is_ok</span>()) &#123;<br>    <span class="hljs-keyword">auto</span> type_attr = rpc_res.<span class="hljs-built_in">unwrap</span>()-&gt;as&lt;std::tuple&lt;u64, u64, u64, u64, u8&gt;&gt;();<br>    <span class="hljs-keyword">if</span> (type_attr == std::tuple&lt;u64, u64, u64, u64, u8&gt;&#123;&#125;) &#123;<br>      <span class="hljs-keyword">return</span> ChfsResult&lt;std::pair&lt;InodeType, FileAttr&gt;&gt;(ErrorType::NotExist);<br>    &#125;<br>    InodeType type = <span class="hljs-built_in">static_cast</span>&lt;InodeType&gt;(std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">4</span>&gt;(type_attr));<br>    FileAttr attr;<br>    attr.size = std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">0</span>&gt;(type_attr);<br>    attr.atime = std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">1</span>&gt;(type_attr);<br>    attr.mtime = std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">2</span>&gt;(type_attr);<br>    attr.ctime = std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">3</span>&gt;(type_attr);<br>    <span class="hljs-keyword">return</span> ChfsResult&lt;std::pair&lt;InodeType, FileAttr&gt;&gt;(std::<span class="hljs-built_in">make_pair</span>(type, attr));<br>  &#125;<br>  <span class="hljs-keyword">return</span> ChfsResult&lt;std::pair&lt;InodeType, FileAttr&gt;&gt;(rpc_res.<span class="hljs-built_in">unwrap_error</span>());<br>&#125;<br></code></pre></td></tr></table></figure><p>而<code>read_file</code>比较复杂，因为涉及到了data server的直接访问，步骤如下：</p><ul><li>rpc调用metadata server的<code>get_block_map</code>函数，错误时返回为空，但不必错误处理，因为为空时不会进入到后面的遍历循环</li><li>维护remain和cur_offset，分别判断剩余读取大小和当前块的偏移量，遍历时根据它们决定是否读取当前块，并用它们计算本次读取内容的长度</li><li>遍历blocks_map，rpc到mac_id对应的data server，并调用<code>read_data</code>函数，这里错误处理相当于高耦合了version和client，因此反而不管最好</li><li>返回result</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">ChfsClient::read_file</span><span class="hljs-params">(<span class="hljs-type">inode_id_t</span> id, usize offset, usize size)</span></span><br><span class="hljs-function">    -&gt; ChfsResult&lt;std::vector&lt;u8&gt;&gt; </span>&#123;<br>  <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Implement this function.</span><br>  <span class="hljs-keyword">auto</span> rpc_res = metadata_server_-&gt;<span class="hljs-built_in">call</span>(<span class="hljs-string">&quot;get_block_map&quot;</span>, id);<br>  <span class="hljs-keyword">if</span> (!rpc_res.<span class="hljs-built_in">is_ok</span>()) &#123;<br>    <span class="hljs-keyword">return</span> ChfsResult&lt;std::vector&lt;u8&gt;&gt;(ErrorType::NotExist);<br>  &#125;<br>  <span class="hljs-keyword">auto</span> block_map = rpc_res.<span class="hljs-built_in">unwrap</span>()-&gt;as&lt;std::vector&lt;std::tuple&lt;<span class="hljs-type">block_id_t</span>, <span class="hljs-type">mac_id_t</span>, <span class="hljs-type">version_t</span>&gt;&gt;&gt;();<br>  std::vector&lt;u8&gt; result;<br>  usize remain = size;<br>  usize cur_offset = offset;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;[block_id, mac_id, version] : block_map) &#123;<br>    <span class="hljs-keyword">if</span> (remain == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">if</span> (cur_offset &gt;= DiskBlockSize)&#123;<br>      cur_offset -= DiskBlockSize;<br>      <span class="hljs-keyword">continue</span>;<br>    &#125;<br>    <span class="hljs-keyword">auto</span> cli = data_servers_[mac_id];<br>    usize to_read = std::<span class="hljs-built_in">min</span>(remain, DiskBlockSize - cur_offset);<br>    <span class="hljs-keyword">auto</span> data_res = cli-&gt;<span class="hljs-built_in">call</span>(<span class="hljs-string">&quot;read_data&quot;</span>, block_id, cur_offset, to_read, version);<br>    <span class="hljs-keyword">if</span>(!data_res.<span class="hljs-built_in">is_ok</span>()) &#123;<br>      <span class="hljs-keyword">return</span> ChfsResult&lt;std::vector&lt;u8&gt;&gt;(ErrorType::BadResponse);<br>    &#125;<br>    <span class="hljs-keyword">auto</span> data = data_res.<span class="hljs-built_in">unwrap</span>()-&gt;as&lt;std::vector&lt;u8&gt;&gt;();<br>    result.<span class="hljs-built_in">insert</span>(result.<span class="hljs-built_in">end</span>(), data.<span class="hljs-built_in">begin</span>(), data.<span class="hljs-built_in">end</span>());<br>    remain -= to_read;<br>    cur_offset = <span class="hljs-number">0</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> ChfsResult&lt;std::vector&lt;u8&gt;&gt;(result);<br>&#125;<br></code></pre></td></tr></table></figure><p>而<code>write_file</code>的步骤为：</p><ul><li>rpc调用metadata server的<code>get_block_map</code>函数，错误时返回为空，但不必错误处理，因为为空时不会进入到后面的遍历循环</li><li>维护remain和cur_offset，分别判断剩余写入大小和当前块的偏移量，遍历时根据它们决定是否写入，并用它们计算本次读取内容的长度；同时将blocks_map维护成一个队列</li><li>进入循环时先判断是否需要分配一个新的block，rpc调用metadata server的<code>allocate_block</code>函数（注意rpc的名字映射为alloc_block，这是唯一的不同名），分配失败时返回值为空，需要错误处理，成功则入队</li><li>blocks_map出队并rpc调用data server的<code>write_data</code>函数（这里也该错误处理，但写漏了）</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">ChfsClient::write_file</span><span class="hljs-params">(<span class="hljs-type">inode_id_t</span> id, usize offset, std::vector&lt;u8&gt; data)</span></span><br><span class="hljs-function">    -&gt; ChfsNullResult </span>&#123;<br>  <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Implement this function.</span><br>  <span class="hljs-keyword">auto</span> rpc_res = metadata_server_-&gt;<span class="hljs-built_in">call</span>(<span class="hljs-string">&quot;get_block_map&quot;</span>, id);<br>  <span class="hljs-keyword">if</span> (!rpc_res.<span class="hljs-built_in">is_ok</span>()) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">ChfsNullResult</span>(rpc_res.<span class="hljs-built_in">unwrap_error</span>());<br>  &#125;<br>  <span class="hljs-keyword">auto</span> block_map = rpc_res.<span class="hljs-built_in">unwrap</span>()-&gt;as&lt;std::vector&lt;std::tuple&lt;<span class="hljs-type">block_id_t</span>, <span class="hljs-type">mac_id_t</span>, <span class="hljs-type">version_t</span>&gt;&gt;&gt;();<br>  usize remain = data.<span class="hljs-built_in">size</span>();<br>  usize cur_offset = offset;<br>  usize data_pos = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">while</span>(remain &gt; <span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-comment">// 先判断是否需要分配一个新的块</span><br>    <span class="hljs-keyword">if</span> (block_map.<span class="hljs-built_in">empty</span>())&#123;<br>      <span class="hljs-keyword">auto</span> new_block_res = metadata_server_-&gt;<span class="hljs-built_in">call</span>(<span class="hljs-string">&quot;alloc_block&quot;</span>, id);<br>      <span class="hljs-keyword">if</span> (!new_block_res.<span class="hljs-built_in">is_ok</span>()) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">ChfsNullResult</span>(new_block_res.<span class="hljs-built_in">unwrap_error</span>());<br>      &#125;<br>      <span class="hljs-keyword">if</span> (new_block_res.<span class="hljs-built_in">unwrap</span>()-&gt;as&lt;std::tuple&lt;<span class="hljs-type">block_id_t</span>, <span class="hljs-type">mac_id_t</span>, <span class="hljs-type">version_t</span>&gt;&gt;() == std::tuple&lt;<span class="hljs-type">block_id_t</span>, <span class="hljs-type">mac_id_t</span>, <span class="hljs-type">version_t</span>&gt;&#123;&#125;) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">ChfsNullResult</span>(ErrorType::OUT_OF_RESOURCE);<br>      &#125;<br>      <span class="hljs-keyword">auto</span> [new_block_id, mac_id, version] = new_block_res.<span class="hljs-built_in">unwrap</span>()-&gt;as&lt;std::tuple&lt;<span class="hljs-type">block_id_t</span>, <span class="hljs-type">mac_id_t</span>, <span class="hljs-type">version_t</span>&gt;&gt;();<br>      block_map.<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">make_tuple</span>(new_block_id, mac_id, version));<br>    &#125;<br>    <span class="hljs-comment">// 出队</span><br>    <span class="hljs-keyword">auto</span> &amp;[block_id, mac_id, version] = block_map.<span class="hljs-built_in">front</span>();<br>    block_map.<span class="hljs-built_in">erase</span>(block_map.<span class="hljs-built_in">begin</span>());<br>    <span class="hljs-keyword">if</span> (cur_offset &gt;= DiskBlockSize)&#123;<br>      cur_offset -= DiskBlockSize;<br>      <span class="hljs-keyword">continue</span>;<br>    &#125;<br>    <span class="hljs-keyword">auto</span> cli = data_servers_[mac_id];<br>    usize to_write = std::<span class="hljs-built_in">min</span>(remain, DiskBlockSize - cur_offset);<br>    <span class="hljs-function">std::vector&lt;u8&gt; <span class="hljs-title">write_data</span><span class="hljs-params">(data.begin() + data_pos, data.begin() + data_pos + to_write)</span></span>;<br>    <span class="hljs-keyword">auto</span> write_res = cli-&gt;<span class="hljs-built_in">call</span>(<span class="hljs-string">&quot;write_data&quot;</span>, block_id, cur_offset, write_data);<br>    <span class="hljs-keyword">if</span> (!write_res.<span class="hljs-built_in">is_ok</span>()) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">ChfsNullResult</span>(write_res.<span class="hljs-built_in">unwrap_error</span>());<br>    &#125;<br>    remain -= to_write;<br>    data_pos += to_write;<br>    cur_offset = <span class="hljs-number">0</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> KNullOk;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后<code>free_file_block</code>通过rpc调用metadata server上的<code>free_block</code>函数，根据返回值是否为false来进行错误处理</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">ChfsClient::free_file_block</span><span class="hljs-params">(<span class="hljs-type">inode_id_t</span> id, <span class="hljs-type">block_id_t</span> block_id,</span></span><br><span class="hljs-params"><span class="hljs-function">                                 <span class="hljs-type">mac_id_t</span> mac_id)</span> -&gt; ChfsNullResult </span>&#123;<br>  <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Implement this function.</span><br>  <span class="hljs-keyword">auto</span> rpc_res = metadata_server_-&gt;<span class="hljs-built_in">call</span>(<span class="hljs-string">&quot;free_block&quot;</span>, id, block_id, mac_id);<br>  <span class="hljs-keyword">if</span> (rpc_res.<span class="hljs-built_in">is_err</span>()) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">ChfsNullResult</span>(rpc_res.<span class="hljs-built_in">unwrap_error</span>());<br>  &#125;<br>  <span class="hljs-keyword">if</span> (!rpc_res.<span class="hljs-built_in">unwrap</span>()-&gt;<span class="hljs-built_in">as</span>&lt;<span class="hljs-type">bool</span>&gt;()) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">ChfsNullResult</span>(ErrorType::INVALID);<br>  &#125;<br>  <span class="hljs-keyword">return</span> KNullOk;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="part-1C-2-version-implement"><a href="#part-1C-2-version-implement" class="headerlink" title="part 1C.2: version implement"></a>part 1C.2: version implement</h5><p>为了保证block操作的before-or-after原子性，需要为每个block引入version，这些version被存放在data server的开头，架构如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">| version blocks | free block bitmap | file data blocks |<br></code></pre></td></tr></table></figure><p>这里我们回到<code>BlockAllocator</code>的构造函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *  Creates a new block allocator with a block manager and a bitmap block id.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * @param bm the block manager</span><br><span class="hljs-comment"> * @param bitmap_block_id the block id of the bitmap</span><br><span class="hljs-comment"> * @param will_initialize whether to initialize the bitmap</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * # Note!!!!</span><br><span class="hljs-comment"> * We assume that the blocks before the `bitmap_block_id` is reserved,</span><br><span class="hljs-comment"> * so they cannot be allocated.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">BlockAllocator</span>(std::shared_ptr&lt;BlockManager&gt; bm, usize bitmap_block_id,<br>               <span class="hljs-type">bool</span> will_initialize = <span class="hljs-literal">true</span>);<br></code></pre></td></tr></table></figure><p>可以注意到这里指定了bitmap_block_id前的块不能被分配出去，正好可以用来存放version block，我们只需要计算version block num，并在未initialized的情况下清空这一部分即可。因此<code>DataServer::initialize</code>修改如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 使用最前面不会被分配出去的块来实现version blocks</span><br><span class="hljs-keyword">constexpr</span> usize version_block_cnt = (KDefaultBlockCnt * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">version_t</span>) + DiskBlockSize - <span class="hljs-number">1</span>) / DiskBlockSize;<br><br><span class="hljs-keyword">auto</span> bm = std::<span class="hljs-built_in">shared_ptr</span>&lt;BlockManager&gt;(<br>    <span class="hljs-keyword">new</span> <span class="hljs-built_in">BlockManager</span>(data_path, KDefaultBlockCnt));<br><span class="hljs-keyword">if</span> (is_initialized) &#123;<br>  block_allocator_ =<br>      std::<span class="hljs-built_in">make_shared</span>&lt;BlockAllocator&gt;(bm, version_block_cnt, <span class="hljs-literal">false</span>);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-comment">// We need to reserve some blocks for storing the version of each block</span><br>  <span class="hljs-comment">// 这里需要初始化一下version blocks</span><br>  std::vector&lt;u8&gt; <span class="hljs-built_in">zero_block_data</span>(bm-&gt;<span class="hljs-built_in">block_size</span>(), <span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">for</span> (usize i = <span class="hljs-number">0</span>; i &lt; version_block_cnt; ++i) &#123;<br>    <span class="hljs-keyword">auto</span> write_res =<br>        bm-&gt;<span class="hljs-built_in">write_block</span>(i, zero_block_data.<span class="hljs-built_in">data</span>());<br>    <span class="hljs-built_in">CHFS_ASSERT</span>(write_res.<span class="hljs-built_in">is_ok</span>(), <span class="hljs-string">&quot;Failed to initialize version blocks&quot;</span>);<br>  &#125;<br>  block_allocator_ = std::<span class="hljs-built_in">shared_ptr</span>&lt;BlockAllocator&gt;(<br>      <span class="hljs-keyword">new</span> <span class="hljs-built_in">BlockAllocator</span>(bm, version_block_cnt, <span class="hljs-literal">true</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>version在每次分配和释放块时，都加一；而在read block时，如果不匹配，返回空值（这是为了迎合测试集）</p><p>因此在<code>DataServer::read_data</code>添加以下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 检查版本号是否匹配</span><br><span class="hljs-type">version_t</span> current_version = <span class="hljs-built_in">get_block_version</span>(block_id);<br><span class="hljs-keyword">if</span> (current_version != version) &#123;<br>    <span class="hljs-comment">// 版本不匹配，拒绝访问</span><br>    <span class="hljs-keyword">return</span> &#123;&#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>在<code>alloc_block</code>和<code>free_block</code>添加以下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 更新版本号</span><br><span class="hljs-type">version_t</span> version = <span class="hljs-built_in">get_block_version</span>(block_id);<br><span class="hljs-built_in">set_block_version</span>(block_id, version + <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p>注意<code>alloc_block</code>要返回更新之后的版本号即可</p><p>现在我们需要额外自行实现<code>get_block_version</code>和<code>set_block_version</code>函数，计算好version block id和offset，然后进行对应block的操作即可：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">DataServer::get_block_version</span><span class="hljs-params">(<span class="hljs-type">block_id_t</span> block_id)</span> -&gt; <span class="hljs-type">version_t</span> </span>&#123;<br>  usize block_size = block_allocator_-&gt;bm-&gt;<span class="hljs-built_in">block_size</span>();<br>  usize versions_per_block = block_size / <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">version_t</span>);<br>  usize version_block_index = block_id / versions_per_block;<br>  usize offset_in_block = (block_id % versions_per_block) * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">version_t</span>);<br>  <span class="hljs-function">std::vector&lt;u8&gt; <span class="hljs-title">buffer</span><span class="hljs-params">(block_size)</span></span>;<br>  <span class="hljs-keyword">auto</span> res = block_allocator_-&gt;bm-&gt;<span class="hljs-built_in">read_block</span>(version_block_index, buffer.<span class="hljs-built_in">data</span>());<br>  <span class="hljs-built_in">CHFS_ASSERT</span>(res.<span class="hljs-built_in">is_ok</span>(), <span class="hljs-string">&quot;Failed to read version block&quot;</span>);<br>  <span class="hljs-type">version_t</span> version;<br>  <span class="hljs-built_in">memcpy</span>(&amp;version, buffer.<span class="hljs-built_in">data</span>() + offset_in_block, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">version_t</span>));<br>  <span class="hljs-keyword">return</span> version;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">DataServer::set_block_version</span><span class="hljs-params">(<span class="hljs-type">block_id_t</span> block_id, <span class="hljs-type">version_t</span> version)</span> -&gt; <span class="hljs-type">void</span> </span>&#123;<br>  usize block_size = block_allocator_-&gt;bm-&gt;<span class="hljs-built_in">block_size</span>();<br>  usize versions_per_block = block_size / <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">version_t</span>);<br>  usize version_block_index = block_id / versions_per_block;<br>  usize offset_in_block = (block_id % versions_per_block) * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">version_t</span>);<br>  <span class="hljs-function">std::vector&lt;u8&gt; <span class="hljs-title">buffer</span><span class="hljs-params">(block_size)</span></span>;<br>  <span class="hljs-keyword">auto</span> res = block_allocator_-&gt;bm-&gt;<span class="hljs-built_in">read_block</span>(version_block_index, buffer.<span class="hljs-built_in">data</span>());<br>  <span class="hljs-built_in">CHFS_ASSERT</span>(res.<span class="hljs-built_in">is_ok</span>(), <span class="hljs-string">&quot;Failed to read version block&quot;</span>);<br>  <span class="hljs-built_in">memcpy</span>(buffer.<span class="hljs-built_in">data</span>() + offset_in_block, &amp;version, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">version_t</span>));<br>  <span class="hljs-keyword">auto</span> write_res = block_allocator_-&gt;bm-&gt;<span class="hljs-built_in">write_block</span>(version_block_index, buffer.<span class="hljs-built_in">data</span>());<br>  <span class="hljs-built_in">CHFS_ASSERT</span>(write_res.<span class="hljs-built_in">is_ok</span>(), <span class="hljs-string">&quot;Failed to write version block&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>现在，我们可以通过以下测试：</p><ul><li><code>DataServerTest.AllocateAndDelete</code></li><li><code>DistributedClientTest.WriteAndThenRead</code></li><li><code>MetadataServerTest.ReadWhenBlockIsInvalid</code></li></ul><h3 id="part-2-support-concurrency"><a href="#part-2-support-concurrency" class="headerlink" title="part 2: support concurrency"></a>part 2: support concurrency</h3><p>之前我们通过version解决了block分配与释放导致的原子性问题，现在，我们还需要保证metadata的原子性。我们只需要给<code>metadata_server.cc</code>的以下函数上锁即可，因为它们并不是只读操作：</p><ul><li><code>mknode</code></li><li><code>unlink</code></li><li><code>allocate_block</code></li><li><code>free_block</code></li></ul><p>在它们开头添加<code>std::lock_guard&lt;std::mutex&gt; lock(metadata_mutex);</code>即可</p><p>现在可以通过以下单元测试了：</p><ul><li><code>DistributedClientTest.CreateConcurrent</code></li><li><code>DistributedClientTest.ReCreateWhenDelete</code></li><li><code>MetadataServerTest.CheckInvariant1</code></li><li><code>MetadataServerTest.CheckInvariant2</code></li><li><code>MetadataServerTest.CheckInvariant3</code></li><li><code>MetadataServerTest.CheckInvariant4</code></li></ul><p>最后运行一下压力测试和集成测试即可</p><p>总结一下这个lab，由于part 3变为选做部分，难度下降了很多，注意chfs的耦合度较高即可</p>]]></content>
    
    
    <categories>
      
      <category>计算机学习</category>
      
      <category>se专业课</category>
      
      <category>cse</category>
      
      <category>lab</category>
      
    </categories>
    
    
    <tags>
      
      <tag>se</tag>
      
      <tag>cse</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSE_lecture10:Atomicity-Logging</title>
    <link href="/2025/10/23/CSE-lecture10-Atomicity-Logging/"/>
    <url>/2025/10/23/CSE-lecture10-Atomicity-Logging/</url>
    
    <content type="html"><![CDATA[<h2 id="Realizing-atomicity-Logging-Checkpoint"><a href="#Realizing-atomicity-Logging-Checkpoint" class="headerlink" title="Realizing atomicity: Logging + Checkpoint"></a>Realizing atomicity: Logging + Checkpoint</h2><h3 id="logging-for-atomicity"><a href="#logging-for-atomicity" class="headerlink" title="logging for atomicity"></a>logging for atomicity</h3><p>logging是journaling的扩展，更加通用</p><p>log entry是一个原子性的单元，维护能恢复用户数据的修改</p><p>transaction用于标记哪些操作是原子性的；commit point为一行代码，经过commit point说明transaction已经是all，此时transaction的操作才认为是有效的（即log完全刷盘之前都是nothing，完全刷盘后就是all）</p><p>TX.begin()到TX.commit()这部分中间的内容被存放在log entry中</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">transfer(bank, a, b, amt, log):<br>    records = mmap(bank, ...)<br>    new_a = records[a] - amt<br>    new_b = records[b] + amt<br><br>    commit_log = <span class="hljs-string">&quot;log start: a:&quot;</span> + new_a + <span class="hljs-string">&quot;\b:&quot;</span> + new_b<br>    log.append(commit_log).sync()<br><br>    records[a] = new_a<br>    records[b] = new_b<br></code></pre></td></tr></table></figure><p>在确保修改一定能被恢复之前不要真的写入数据，比如可以在内存上临时写入；再写入log保存修改的信息，这一部分有两行代码，但其实不用维护原子性，只要能检测到log是否完整写完即可；logging结束后再写入磁盘，更新完后不必fsync，而是只需要定期刷盘（如内存不够），重启后从log中恢复，刷盘前read先访问内存即可</p><p>完成<code>log.append(commit_log).sync()</code>这一步后，认为是commit point</p><p>redo-only logging只保证系统从旧的状态变为新的状态，注意REDO和DO不一定要一样</p><img src="/2025/10/23/CSE-lecture10-Atomicity-Logging/3812e2ce061f6e67e00ab0f91c9718f5.png" class="" title="redo-only logging"><p>value logging记录的是值，恢复时将log里面的值替换到旧的值上即可，但这样就相当于value写了两次；operation logging则是记录做了什么操作，但这样需要重新跑一遍，同时需要保证幂等性。需要权衡</p><p>redo-only logging的性能很好，唯一的开销是多一次log的写入，而log是只追加的，优于随机写。缺点是更新全都缓存在内存中，内存压力大；log一直在增加，而实际上已经有大部分操作已经写回到磁盘了</p><p>操作系统会在内存不够时，将部分页表swap到磁盘上，从而释放一些内存。这种系统对于redo-only logging并不友好，一方面swap后会额外占用磁盘空间，另一方面swap的性能难以建模，且强依赖操作系统</p><p>为了解决内存不够的问题，需要直接在原有的位置上进行修改，此时需要维护undo log来维护修改之前的原来的数据。但依然需要redo log，从而不必等待数据落盘（赋值只是修改了内存映射区），只保证log落盘即可。使用undo-redo log实现旧的值和新的值同时写入log</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">transfer(bank, a, b, amt, log):<br>    records = mmap(bank, ...)<br>    <span class="hljs-comment"># log记录为Action(file name, offset, old &amp; new values)</span><br>    log.append(...).sync()<br>    records[a] = records[a] - amt<br>    log.append(...).sync()<br>    records[b] = records[b] + amt<br>    log.append(<span class="hljs-string">&quot;TX &#123;id&#125; commit&quot;</span>).sync()<br></code></pre></td></tr></table></figure><p>redo-only logging每次只append一个log entry，对应一个transaction；而undo-redo logging需要append多个log records，当多个transaction并行操作时，会导致log record不连续，出现交错，此时在log里维护一个指针指向前一个record，将同一个transaction的record串起来</p><p>redo-only logging在恢复时，直接从左到右遍历一遍log entry即可；而undo-redo logging的恢复步骤为：</p><ul><li>从后向前扫一遍log</li><li>找到所有没有commit的transaction，标记其所有的log record，并append到ABORT log中</li><li>undo所有的ABORT log</li><li>redo所有的CMT log</li></ul><img src="/2025/10/23/CSE-lecture10-Atomicity-Logging/2a38f2c096a7524891f1c32b9256500d.png" class="" title="the type of logging"><p>redo-only logging在执行事务和恢复操作中都更快，因此在内存足够时，偏向于使用redo-only logging</p><p>undo-only logging要求修改在transaction commit前就刷盘，因此执行事务的速度比undo-redo logging还慢，因此极少使用</p><h3 id="checkpoint"><a href="#checkpoint" class="headerlink" title="checkpoint"></a>checkpoint</h3><p>为了解决log file无限增长的问题，引入checkpoint，用于将系统的状态压缩得更紧凑，其应用很广泛，比如可以本地固化eventual consistency的聊天记录</p><h4 id="case-study-1-checkpoint-in-logging"><a href="#case-study-1-checkpoint-in-logging" class="headerlink" title="case study 1: checkpoint in logging"></a>case study 1: checkpoint in logging</h4><p>让系统在恢复时遍历一次log，但这样太慢了；事实上已经刷盘的事务不用再恢复了。checkpoint的目的是，保证只做checkpoint之后的恢复等价于没有检查点的全部恢复，问题在于正在做checkpoint时有事务在执行，因此需要记录这些事务的log</p><p>checkpoint的步骤为：</p><ul><li>已提交的事务刷盘并摒弃log</li><li>收集未提交的事务的log</li></ul><img src="/2025/10/23/CSE-lecture10-Atomicity-Logging/21221e2cd480371e7620520daab6f147.png" class="" title="recovery with checkpoint"><h4 id="case-study-2-checkpoint-in-LLM-pre-training-how-we-configure-the-checkpoint-frequency"><a href="#case-study-2-checkpoint-in-LLM-pre-training-how-we-configure-the-checkpoint-frequency" class="headerlink" title="case study 2: checkpoint in LLM (pre)training &amp; how we configure the checkpoint frequency"></a>case study 2: checkpoint in LLM (pre)training &amp; how we configure the checkpoint frequency</h4><p>定期的checkpoint保证了崩溃后不用从头开始计算，而是从某一个iteration开始计算</p><p>而checkpoint本身也要保证原子性，因此使用shadow copy，保留上一次的checkpoint，直到这次的checkpoint做完</p><p>checkpoint时模型训练会停下来，因此checkpoint需要更快，而这不能简单通过减少checkpoint频率来解决，因为恢复重算的时间会变长</p><h4 id="case-study-3-checkpoint-in-an-eventually-consistent-system"><a href="#case-study-3-checkpoint-in-an-eventually-consistent-system" class="headerlink" title="case study 3: checkpoint in an eventually consistent system"></a>case study 3: checkpoint in an eventually consistent system</h4><p>在eventual consistency中，每个节点都会维护一个log，并在sync后重排整个log，因此为了防止log无限增长，需要引入checkpoint，而挑战在于不同设备不能自己单独决定在哪进行checkpoint</p><p>事实上在lamport架构中，会存在一些永远排在前面的操作，即它们在所有其他设备的lamport clock之前，此时其他设备不会传来排在它们之前的操作。因此取得所有设备的lamport clock并取最小值，在其之前的操作都是stable的</p><p>但问题在于如果存在offline的机器，那么它的lamport clock会因为一直不更新自己的时间而很小，导致log中能stable的操作也会很少。因此为操作时间戳里面加入由centralized决定的CSN，其遵循严格的顺序，当收到所有小于当前CSN的消息时，当前操作也就stable了</p><p>为了维护lamport clock的因果性，在分配CSN时需要也拿到当前操作之前的所有tentative操作的CSN</p>]]></content>
    
    
    <categories>
      
      <category>计算机学习</category>
      
      <category>se专业课</category>
      
      <category>cse</category>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>se</tag>
      
      <tag>cse</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSE_lecture9:Atomicity</title>
    <link href="/2025/10/22/CSE-lecture9-Atomicity/"/>
    <url>/2025/10/22/CSE-lecture9-Atomicity/</url>
    
    <content type="html"><![CDATA[<h2 id="Consistency-under-failure-The-requirement-of-atomicity"><a href="#Consistency-under-failure-The-requirement-of-atomicity" class="headerlink" title="Consistency under failure: The requirement of atomicity"></a>Consistency under failure: The requirement of atomicity</h2><p>即使不考虑分布式，故障的发生也可能引发不一致性</p><p>fail-stop发生时，整个系统的所有部分都出现failure</p><p>以下面的代码为例，必须保证bank(a) + bank(b)不变：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">transfer(bank, a, b, amt):<br>    record = mmap(bank, ...)        <span class="hljs-comment"># 将文件数据加载到内存页表中，从而像操作内存一样操作文件</span><br>    records[a] = records[a] - amt<br>    records[b] = records[b] + amt<br>    fsync(bank, ...)                <span class="hljs-comment"># 将内存flush汇磁盘中</span><br>    notify_the_user()<br></code></pre></td></tr></table></figure><p>其中fsync的本质是将内存页表的数据一个接一个写回到磁盘中，分为Write(A)和Write(B)两步</p><p>如果error发生在fsync前，不会发生问题，因为没有修改文件；但如果error发生在fsync执行过程中，比如写到一半就挂了，就可能出现问题。因此需要系统提供atomicity的能力，即保证一系列操作all-or-nothing</p><p>shadow copy的思想为先不修改原来的文件，而是备份一个正确的数据，修改copy的数据，最后将copy的数据变成原来的数据即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># shadow copy</span><br>transfer(bank, a, b, amt):<br>    fcopy(bank, bank_temp)<br>    records = mmap(bank_temp, ...)<br>    records[a] = records[a] - amt<br>    records[b] = records[b] + amt<br>    fsync(bank_temp, ...)<br>    rename(bank_temp, bank)<br></code></pre></td></tr></table></figure><p>当crash发生在fcopy或者fsync执行时，由于bank本身没有被修改，所以不影响一致性；当crash发生在rename执行时，由于bank_temp和bank这两个文件都是保证了一致性的，因此问题在于filesystem的实现，严重时可能导致filesystem挂掉</p><p>原来的rename操作需要依次修改inode num和refcnt，因此需要让filesystem也具备all-or-nothing，现在不能再使用shadow copy了，否则会递归下去。使用journaling的方法，其思想为允许数据被改错，只要能保证能修复即可，在进行正式的数据更新前，先把即将进行的修改内容记录到日志文件中</p><p>journaling的方法为：</p><ul><li>将修改记录在journal中</li><li>提交journal，即将journal写入磁盘</li><li>更新，按照journal进行真正的数据修改</li></ul><p>如果crash发生在commit前，数据并没有真正修改；发生在commit后时，将journal里的操作重做一次即可</p><p>通过journaling进行rename的操作为：</p><img src="/2025/10/22/CSE-lecture9-Atomicity/128288a329e0593f1423271f2dd0b47f.png" class="" title="rename via journaling"><p>涉及到多个block修改的操作都可以通过journaling来保证一致性，如append a file：</p><img src="/2025/10/22/CSE-lecture9-Atomicity/fa8c99c5419e503f485c6592685866ea.png" class="" title="append a file via journaling"><p>journaling也有缺点：需要额外的写操作（两倍），当文件极大时磁盘压力很大。解决方法为选择快速操作，只保证一部分重要的操作是原子性的，因此journaling只用于关键的操作，这也是shadow copy依然需要的原因</p><p>当crash发生在journal commit时，由于厂商保证disk写入一个sector时一定是原子性的，故journal commit也是all-or-nothing的；即使没有，也可以使用校验码验证，但有开销</p><p>现在shadow copy就实现原子性了，但其有一定缺点：</p><ul><li>一次只能进行一个操作：多个client同时操作同一个文件的不同部分时，直接copy会导致覆写，此时只能共享文件，且必须等待所有client完成时才能写回。这样的性能很差，故shadow copy只用于简单的场景</li><li>难以修改多个文件：需要大量的复制，同时只有放在同一目录下才能勉强保证原子性</li><li>微小的改动都会引发整个文件的copy，可以通过copy-on-write优化</li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机学习</category>
      
      <category>se专业课</category>
      
      <category>cse</category>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>se</tag>
      
      <tag>cse</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSE_lecture8:Consistency</title>
    <link href="/2025/10/20/CSE-lecture8-Consistency/"/>
    <url>/2025/10/20/CSE-lecture8-Consistency/</url>
    
    <content type="html"><![CDATA[<h2 id="Consistency-when-executing-operations-concurrently"><a href="#Consistency-when-executing-operations-concurrently" class="headerlink" title="Consistency when executing operations concurrently"></a>Consistency when executing operations concurrently</h2><h3 id="implement-ChatAPP"><a href="#implement-ChatAPP" class="headerlink" title="implement ChatAPP"></a>implement ChatAPP</h3><p>最简单的方法就是使用一个中心化的服务器，但实际上使用的很少，原因为：</p><ul><li>每次post都要网络通信，都要等待response</li><li>每次read都要等待RPC</li><li>断网时无法访问</li><li>服务器挂了就无法处理了</li></ul><p>因此系统是需要备份的，不仅备份在server上，也要备份在各个设备上(replicated list)</p><p>最方便的方法在于只更新本地数据，但这样不能实现备份间的同步</p><p>如果向所有备份同步，会导致低性能，同时当部分server挂了时就同步不了</p><p>一个常用的方法是只同步在一部分server上，这样可以离线读取聊天记录，但反映不了聊天记录的全貌。因此需要定期同步数据，或者被动接收同步数据</p><img src="/2025/10/20/CSE-lecture8-Consistency/e90f0a83c9b42f005142e8e541537a44.png" class="" title="read the local copy + periodically sync"><p>现在的挑战在于：</p><ul><li>不能同步所有的服务器</li><li>同步的内容为操作而非数据，因为无法区分哪些数据是正确的</li><li>采用过滤后追加的方法更新本地数据</li></ul><p>这样又带来一个问题，即不同人看到的聊天记录是不一致的</p><img src="/2025/10/20/CSE-lecture8-Consistency/c244b12cd3c87796836b9c7b1dfd2c36.png" class="" title="can replicated approach reorder operations?"><p>consistency model定义了乱序现象会不会出现，有强弱之分，依情况选择合适的模型</p><img src="/2025/10/20/CSE-lecture8-Consistency/fb97fb01c65b8874205abade6d99e74d.png" class="" title="spectrum of consistency models"><h3 id="eventual-consistency"><a href="#eventual-consistency" class="headerlink" title="eventual consistency"></a>eventual consistency</h3><p>我们的目标有：</p><ul><li>一旦能联网就能通信</li><li>打开微信不一定需要看到最新的消息，可以容忍一定的延迟，但要保证最终消息顺序是一样的</li></ul><p>eventual consistency的读写都是只向任意一台服务器发起的，定期进行同步操作即可，即只保证最终一致性（或本地副本读取，写的时候还需要广播）</p><p>eventual consistency可能出现一段时间数据不一致现象，但能保证最终数据是一致的，要求为：一旦服务器收到的消息一致，那么给用户呈现的消息也应当一致，即需要保证确定的顺序</p><img src="/2025/10/20/CSE-lecture8-Consistency/18b93122084d52ec5edde924db79c0cd.png" class="" title="ordering challenge"><p>将收到的消息缓存在log中，再按照相同的规则进行排序，最后将排序好的聊天记录覆写过去</p><p>问题在于怎么实现排序，需要一个total order的timestamp：</p><ul><li>直接使用系统时间排序，但不同机器可能出现时钟相等的问题，因此不能使用</li><li>使用&lt;time T, node ID&gt;</li></ul><p>但由于不同设备之间的时钟可能不一致，仍然可能出现被引用内容排在引用后面的情况</p><img src="/2025/10/20/CSE-lecture8-Consistency/d65896ee7328d652441c7d1835a5fa80.png" class="" title="unsynchronized clock time"><p>定义casual relationship X -&gt; Y如下：</p><ul><li>同一台机器中X发生在Y之前</li><li>不同机器上，X导致了Y的发生，如Y引用了X</li><li>存在传递性</li></ul><p>故解决方法为lamport clock，即按照casual relationship排序，算法为：</p><ul><li>每个server维护一个自己的时钟</li><li>时钟每隔一定时间加一</li><li>收到其他server（时间戳为T’）的消息时，将自己的时间戳更新为 T &#x3D; Max(T, T’ + 1)<img src="/2025/10/20/CSE-lecture8-Consistency/a8932a35620cc7dd22215ea11510292b.png" class="" title="lamport clock algorithms"></li></ul><p>假设TS(event #1) &lt; TS(event #2)，且在不同node上能否说明以下几点：</p><ul><li>event #1发生的物理时间早于event #2？不一定，可能发生时没有通信</li><li>node #1和node #2通信？不一定，可能初始时node #1时间远小于node #2</li><li>event #1同步到了node #2，event #1发生的比event #2早？还是不一定</li></ul><p>但这并不能解决引用内容不存在的问题，因为还是只保证了最终一致性，本地可能在中途没有同步到被引用内容</p><p>eventual consistency不能支持所有场景，比如接龙，如果两个用户没有通信，可能就会乱序。解决方法为：</p><ul><li>如果没有明确的casual relationship，应当回退</li><li>使用更强的一致性模型</li></ul><p>因此应当增加partial order，即存在不能排序的情况。因此使用vector clock，只有每一项都比另一个大时才能排序。实现方法为向量包含本地的lamport clock和它观测到的其他server的lamport clock，未通信时只增加自己的lamport clock；同步时保证每一项都有T &#x3D; Max(T, T’ + 1)</p><p>当出现不能排序的情况时，由应用自己决定怎么解决，这也是缺点之一</p><h3 id="strong-consistency-model"><a href="#strong-consistency-model" class="headerlink" title="strong consistency model"></a>strong consistency model</h3><p>另一个方法是使用更强的一致性模型，此时能保证大家看到的都是一个确定的顺序，而不同强一致性模型的区别就是按照什么顺序</p><p>strict consistency严格按照issue time，即操作的发起时间。使用中心化服务器的挑战在于网络延迟：</p><ul><li>这不能使用本地时间解决</li><li>等待前面的请求都到了为止，问题在于延迟很久，同时不知道有多少消息要等待</li></ul><p>因此strict consistency难以实现</p><p>linearizability consistency 按照中心化的服务器排序，收到请求就执行，按照completion-to-issue排序，即才发起的操作排在已经做完的操作后面，并发时可以随意排序，但这不影响不同设备之间的一致性</p><p>当出现备份服务器时，linearizability也可以实现，原则为primary-backup model：仅由primary来决定顺序，因此也只能在primary上进行读写，再广播到其他备份上。当primary挂了之后，可以临时启用backup</p><p>primary-backup在write时步骤为：</p><ul><li>先广播到所有backup</li><li>再本地写</li><li>返回</li></ul><p>这需要保证primary和backup的顺序一致，但网络可能导致乱序，因此需要维护一个全局的seq number</p><img src="/2025/10/20/CSE-lecture8-Consistency/6ab8e18c30dc1b0d9406ab37c53ec126.png" class="" title="seq number"><p>允许read发生在write forward之前，这样虽然读取不到最新的write，但顺序是没有乱的，这样保证了高性能</p><p>primary-backup的缺点为性能远不及eventual consistency，同时容错性维护很复杂（如出现多台primary）</p><p>sequential consistency进一步优化，即可以在backup上read，下面例子的最后两次read违反了completion-to-issue，即pre-process issuing&#x2F;completion order</p><img src="/2025/10/20/CSE-lecture8-Consistency/ba1c2d56d7c817cf90f371d7a2cc747e.png" class="" title="sequential consistency"><p>eventual和linearizability比较：</p><img src="/2025/10/20/CSE-lecture8-Consistency/f3fe8e5bf285c52311e9c1f570d0d540.png" class="" title="eventual vs linearizability"><p>使用哪种模型应当由具体场景决定</p>]]></content>
    
    
    <categories>
      
      <category>计算机学习</category>
      
      <category>se专业课</category>
      
      <category>cse</category>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>se</tag>
      
      <tag>cse</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSE_lecture7:System modelling + KFS</title>
    <link href="/2025/10/19/CSE-lecture7-System-modelling-KFS/"/>
    <url>/2025/10/19/CSE-lecture7-System-modelling-KFS/</url>
    
    <content type="html"><![CDATA[<h2 id="System-modelling-Key-value-stores-KVS"><a href="#System-modelling-Key-value-stores-KVS" class="headerlink" title="System modelling &amp; Key-value stores(KVS)"></a>System modelling &amp; Key-value stores(KVS)</h2><h3 id="key-value-store-abstraction"><a href="#key-value-store-abstraction" class="headerlink" title="key-value store abstraction"></a>key-value store abstraction</h3><p>key-value使用唯一的key来标识value，提供接口为get, scan, update, insert, delete，比文件系统更简单</p><p>一种想法是可以直接在filesystem上封装一层key-value store的API，key认为是文件名，value为文件的内容。使用system modelling来进行量化</p><h3 id="system-modelling"><a href="#system-modelling" class="headerlink" title="system modelling"></a>system modelling</h3><p>在设计系统前，建立其内部模型抽象，提炼出决定系统行为的主要组成部分，实现定性模型。相较于直觉更科学，相较于实验更加高效和普适（但不代表就不用实验了）</p><p>现在使用定性模型(qualitative system model)来分析使用filesystem的key-value store：</p><ul><li><p>定义系统的目标：低延迟，并使用少量空间存储更多的数据</p></li><li><p>分析：以Insert为例，为CREATE + WRITE，共两次system call，并将system call进一步展开</p><img src="/2025/10/19/CSE-lecture7-System-modelling-KFS/de6866305fcd4829bcb018bdc2027b75.png" class="" title="system modelling analysis"><p>现在只要知道disk read&#x2F;write的latency就可以在不实现具体系统的情况下进行分析。</p></li></ul><p>结论是并不高效，额外的操作太多。但实际上在value特别大时还是能够接受的。因此在system modelling时需要考虑参数(parameterized)，如static parameters（如disk read&#x2F;write time）, input parameters（如key-value sizes）, runtime parameters</p><p>一般来说，key-value store用于数据大小很小的时候，因此不考虑该实现，即理想状况下只进行一次block write；另一方面这也造成了很大的空间浪费</p><h3 id="build-key-value-store-system"><a href="#build-key-value-store-system" class="headerlink" title="build key-value store system"></a>build key-value store system</h3><p>核心想法是：将多个key-value放到同一个文件中，减少空间浪费和延迟</p><img src="/2025/10/19/CSE-lecture7-System-modelling-KFS/d89ba88fc1dcea773f6ea9f116d9c01d.png" class="" title="key-value store &amp; file system"><p>使用filesystem而不是直接进行disk操作是因为这样更加方便，同时兼容性好</p><h4 id="step-1-a-naive-key-value-storage"><a href="#step-1-a-naive-key-value-storage" class="headerlink" title="step 1: a naive key-value storage"></a>step 1: a naive key-value storage</h4><p>将所有的key-value都放在一个单一文件中，以update为例，有两种方法：</p><ul><li>file in-place write: 根据offset进行file write来修改，这需要一次random disk write</li><li>file append: 在文件末尾追加更新值，这一般只需要进行一次sequential disk write</li></ul><p>比较之后，append更加高效。</p><p>insert和update类似，而delete则会append一个NULL entry，后续进行垃圾回收</p><h4 id="step-2-log-structure-key-value-stores-L-KVS"><a href="#step-2-log-structure-key-value-stores-L-KVS" class="headerlink" title="step 2: log-structure key-value stores(L-KVS)"></a>step 2: log-structure key-value stores(L-KVS)</h4><p>log-structured file是append-only的</p><p>此时get操作难以高效实现，需要倒序遍历文件</p><h4 id="step-3-L-KVS-index"><a href="#step-3-L-KVS-index" class="headerlink" title="step 3: L-KVS + index"></a>step 3: L-KVS + index</h4><p>加一层index组件，用于key -&gt; offset的映射，这一层不需要持久化</p><h5 id="step-3-1-in-memory-hash-index-log-structured-data-file"><a href="#step-3-1-in-memory-hash-index-log-structured-data-file" class="headerlink" title="step 3.1: in-memory hash index + log-structured data file"></a>step 3.1: in-memory hash index + log-structured data file</h5><p>在内存维护一个map来实现key -&gt; byte offset，问题在于index能否在内存中放下，因此需要允许index放在磁盘上</p><h4 id="step-4-L-KVS-in-memory-disk-hybrid-index"><a href="#step-4-L-KVS-in-memory-disk-hybrid-index" class="headerlink" title="step 4: L-KVS + (in-memory &amp; disk hybrid index)"></a>step 4: L-KVS + (in-memory &amp; disk hybrid index)</h4><img src="/2025/10/19/CSE-lecture7-System-modelling-KFS/fb147884a89dbe1c28f818e3a06bf2c7.png" class="" title="bucket-based hashing index"><p>使用fat pointer，其既可以指向虚拟内存地址，也可以指向文件的offset</p><p>当index既可能在内存中，也可能在磁盘中时，可能导致多次磁盘访问，甚至导致随机磁盘访问，因此不能使用linked-list-based hashing，改进方法为：</p><ul><li>一个entry放入多个key，减小链的长度</li><li>使用更高级的hashing方法，如cuckoo hashing</li></ul><p>目前的架构还有以下问题：</p><ul><li>log file是永远在增大的，最终导致磁盘空间用尽</li><li>不支持范围查找</li></ul><p>使用compaction来防止log file无限增大，即通过压缩来删除重复的数据，但当文件特别大的时候相当耗时</p><p>因此将文件分为多个segment，compaction时挑选一部分segment，并以segment的粒度来进行压缩，同时在segment之间进行merge；在compaction时还能顺便进行垃圾回收，实现删除。此时模型更加复杂了，在compact&#x2F;merge时进行get性能会受限，因此建模时还需要考虑compact&#x2F;merge的频率</p><h5 id="step-4-1-L-KVS-w-compaction-merging-in-memory-disk-hybrid-hashing-index"><a href="#step-4-1-L-KVS-w-compaction-merging-in-memory-disk-hybrid-hashing-index" class="headerlink" title="step 4.1: L-KVS(w&#x2F; compaction &amp; merging) + (in-memory &amp; disk hybrid hashing index)"></a>step 4.1: L-KVS(w&#x2F; compaction &amp; merging) + (in-memory &amp; disk hybrid hashing index)</h5><p>此时还是没有解决范围查找的问题。解决方法为使用B+树作为index，实现key的排序和高效的范围查找，但这和log-structured file不太兼容</p><h4 id="step-5-B-tree-based-KVS"><a href="#step-5-B-tree-based-KVS" class="headerlink" title="step 5: B+ tree-based KVS"></a>step 5: B+ tree-based KVS</h4><p>B+树中，update&#x2F;insert需要多次磁盘访问，尤其是随机磁盘访问；但范围查找效果很好</p><h4 id="step-6-SSTables-sorted-string-table-KVS"><a href="#step-6-SSTables-sorted-string-table-KVS" class="headerlink" title="step 6: SSTables(sorted string table) KVS"></a>step 6: SSTables(sorted string table) KVS</h4><p>SSTable基于segmented log file，同时有两个更新：</p><ul><li>每个segment中的key都排好序</li><li>segment不可修改，因此不是append-only</li></ul><p>SSTable的好处在于：</p><ul><li>key的查找很高效：index只存放一部分key的offset，实际查找时夹逼即可</li><li>支持segment里的范围查找</li></ul><p>使用memtable来实现内存的修改，从而将SSTable的修改batch在一起。以insert为例：</p><ul><li>在memtable中insert</li><li>当memtable大到一定程度后，排序并写入SSTable</li><li>当SSTable过多时，进行compact + merge</li></ul><p>而查找时，先在memtable查找，再依序查找SSTable，可以在每个SSTable上保留一个稀疏的in-memory index来进行优化</p><p>范围查找则需要segment之间也进行排序</p><p>SSTable不应当简单地顺序存储，因此还需要优化</p><h4 id="step-7-LSM-trees"><a href="#step-7-LSM-trees" class="headerlink" title="step 7: LSM trees"></a>step 7: LSM trees</h4><p>将SSTable摆放为多层架构，除了L0之外，每层的文件都排好序，且没有重复的key；上层的数据比下层的数据更新</p><img src="/2025/10/19/CSE-lecture7-System-modelling-KFS/2b4b853979f4bd5da57aca36d0b95162.png" class="" title="analysis of different system models for KVS"><p>任何系统都可能出现corner case，比如LSM tree可能出现写阻塞(write stall)，这是因为前一次写入过于耗时（多次compact）导致的</p><p>对于错误处理，比如memtable丢失，可以使用log来恢复memtable</p><p>相较于B+ tree，好处是写的性能更好，坏处是range性能稍差</p>]]></content>
    
    
    <categories>
      
      <category>计算机学习</category>
      
      <category>se专业课</category>
      
      <category>cse</category>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>se</tag>
      
      <tag>cse</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSE_lecture6:DFS</title>
    <link href="/2025/10/15/CSE-lecture6-DFS/"/>
    <url>/2025/10/15/CSE-lecture6-DFS/</url>
    
    <content type="html"><![CDATA[<h2 id="Distributed-file-system-DFS"><a href="#Distributed-file-system-DFS" class="headerlink" title="Distributed file system(DFS)"></a>Distributed file system(DFS)</h2><p>distributed file service有以下类型：</p><ul><li>upload&#x2F;download model: 如FTP，实现文件在客户端和服务端的复制，好处是简单，坏处是浪费、引发空间不足问题、难以保证一致性</li><li>remote access model: 使用RPC，好处是只用获取需要的部分、服务端可以维护一致性，缺点是可能出现服务器和网络问题</li></ul><h3 id="NFS-with-RPC"><a href="#NFS-with-RPC" class="headerlink" title="NFS with RPC"></a>NFS with RPC</h3><p>即network file system，特点为：</p><ul><li>任何机器都可以作为服务端或者客户端</li><li>支持diskless workstations</li><li>支持异构部署，兼容性好</li><li>访问透明性，支持远程访问模型</li><li>具备故障恢复能力</li><li>高性能，使用cache和read-ahead等优化</li></ul><p>要将inode file system中的system call变为RPC，此时多了<code>NULL()</code>和<code>LOOKUP()</code>，少了<code>OPEN()</code>和<code>CLOSE()</code>，fd则变为fh，多了offset（这是为了保证stateless）</p><img src="/2025/10/15/CSE-lecture6-DFS/3ac75d20310a673dd00501890965bcb1.png" class="" title="RPC in NFS"><p>首先实现mount，即挂载，server上将shared directories写入配置文件，client进行mount，实现远程路径和本地路径的映射</p><p>每个request都需要有一个permission，以检查一下client是否是某一用户，然后server返回一个file handler</p><img src="/2025/10/15/CSE-lecture6-DFS/58612290f90e7c6454c79bd4cd8d9295.png" class="" title="NFS read a file"><p>NFS client从本地向application提供OPEN, READ, WRITE, CLOSE等接口，从而保证application不必修改代码；另一边通过网络访问NFS server，这才会使用RPC的接口</p><p>OPEN操作其实并没有在server上真的打开文件，因此CLOSE也不会访问到server；READ操作也不会传递buffer给server；file attributes用于更新本地的inode，同时由于存在其他client更改文件，故这可用于维护一致性</p><p>server是无状态的，不存放cursor，因此两次访问server之间发生重启不会出现错误，从而保证容错性的同时减少资源的使用；client则是有状态的，即存在file table等，存放cursor等，因此多次调用READ，需要调整offset，而RPC本身的READ由于存在offset，因此是幂等的</p><p>client和server之间不能传递fd，不然就需要打开文件，违背了无状态性，因此传递fh</p><p>fh不能使用path name，否则在一个client打开文件后，另一个client重命名目录时会出现问题</p><img src="/2025/10/15/CSE-lecture6-DFS/3ad4af297aedeb3c17c0061f7240a6c4.png" class="" title="rename after open"><p>也不能使用inode number，否则在一个client打开文件后，另一个client删除这个inode并分配一个新的文件，也会出现读取到新文件的问题，这需要额外维护版本号(generation number)，这不得不违背本地unix规范</p><img src="/2025/10/15/CSE-lecture6-DFS/1a0a0c392651717ac3dbf2f7a5ae8dd6.png" class="" title="delete after open"><p>因此file handler包含inode number和generation number</p><p>性能上，通常慢于本地访问，但不总是，这和file server的性能和网速有关。为了优化，应当在client使用cache，从而降低远程操作的次数，如file data, file attribute, pathname bindings，而server端自动进行buffer cache，因此不需要额外操作</p><p>cache会带来一致性问题(cache coherence)，即能否read到最近一次write(read observes last write)，有两种：</p><ul><li>close-to-open consistency: open时比较是否与cache的状态一致，close时再将本地cache的write一起发回server，性能好，但容易引发一致性问题</li><li>read&#x2F;write coherence: 能在本地read到最新的数据，NFS client全权保证read&#x2F;write coherence，或只保证其中一部分</li></ul><p>处理方法如下：</p><ul><li>close-to-open consistency: close时刷新cache</li><li>read&#x2F;write coherence: client和server都维护timestamp，反复比较，远程更新时无效化本地的cache，cache还需要设置有效时间</li></ul><p>还可以使用以下方法进一步优化性能：</p><ul><li>每次多传一些数据</li><li>read-ahead: 提前多传一些头部数据</li></ul><p>NFS的缺点为：</p><ul><li>在容量和处理能力上无法扩展：例如，文件系统的容量受限于单个节点的容量，处理能力也类似</li><li>NFS 不支持高可用性：例如，如果服务器崩溃会发生什么</li></ul><p>GFS的引入部分解决了上述问题，但面临挑战：一致性问题</p><h3 id="GFS-the-google-file-system"><a href="#GFS-the-google-file-system" class="headerlink" title="GFS: the google file system"></a>GFS: the google file system</h3><p>google具备以下特性：大部分文件是append而非overwritten，因此random write几乎为零；workload主要是read</p><p>因此GFS的设计目标为：可扩展的分布式文件系统(scalable distributed file system)；为大型数据密集型应用设计；错误容忍度高；高性能</p><p>GFS并没有提供标准的OS级别API，基本操作为create&#x2F;delete&#x2F;open&#x2F;close&#x2F;read&#x2F;write，多了snapshot&#x2F;append，少了link&#x2F;symlink&#x2F;rename，否则rename容易引发一致性问题（因为有多个备份，避免了inode和server的高耦合）</p><p>GFS的架构为一台master和很多台chunk server，master控制元数据信息，chunk server存放具体的数据（其中chunk非常大，为64MB，应用于大文件场景）</p><p>每一个文件都有三个备份，用于容错，这些chunk被放在不同的chunk server上，master管理metadata，放在memory中</p><img src="/2025/10/15/CSE-lecture6-DFS/41a22ca3644617bef74f55276b112d34.png" class="" title="GFS files"><p>large chunk的优点在于：减少通信次数，减小metadata的大小</p><p>chunk handle全局唯一</p><p>master唯一的好处在于，metadata在内存中，从而实现super-fast；operation log用于保证master的崩溃引发的容错</p><p>client GFS不必cache</p><p>在GFS中read文件的步骤如下（前两步可以cache）：</p><ul><li>访问master</li><li>得到文件的metadata，即chunk handles</li><li>得到chunk handles的位置</li><li>选一个可用的chunk server，后续不必再麻烦master了</li></ul><p>而write文件分两步：</p><ul><li><p>先只传递数据而不写，client拿到三备份，一主两从，选一个最近的replica，一个接一个pipeline来写完所有的chunk server</p><img src="/2025/10/15/CSE-lecture6-DFS/f6cbc95d13a07bf05afdb94981a38003.png" class="" title="send data in GFS"></li><li><p>将数据写入到文件中去，这需要修改master</p></li></ul><p>在GFS中进行naming时，实际上是没有目录的概念的，而是直接进行文件名和chunk server的哈希，好处是没有任何的link，同时查找速度极快</p>]]></content>
    
    
    <categories>
      
      <category>计算机学习</category>
      
      <category>se专业课</category>
      
      <category>cse</category>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>se</tag>
      
      <tag>cse</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSE_lecture5:Remote Procedure Call</title>
    <link href="/2025/10/02/CSE-lecture5-Remote-Procedure-Call/"/>
    <url>/2025/10/02/CSE-lecture5-Remote-Procedure-Call/</url>
    
    <content type="html"><![CDATA[<h2 id="Remote-Procedure-Call"><a href="#Remote-Procedure-Call" class="headerlink" title="Remote Procedure Call"></a>Remote Procedure Call</h2><p>RPC让文件系统变成远程，同时让远程服务器像运行在本地一样，相比于sockets api，RPC不必因为突然变成远程服务器而修改代码，即这个接口应当同时能访问本地和远程</p><p>为了不改应用的高层代码，将缺乏语义的共同部分打包成RPC stub</p><img src="/2025/10/02/CSE-lecture5-Remote-Procedure-Call/ca5a0cd169e9a0ba6b37aeac0d06031a.png" class="" title="RPC stub"><p>client stub做以下事情：发请求，接受响应，进行convert</p><img src="/2025/10/02/CSE-lecture5-Remote-Procedure-Call/96263d51ce570e304e3047161cf0ce03.png" class="" title="client stub"><p>server stub做以下事情：使用一个do forever不断接受请求，根据参数进行switch case，从而判断响应OK与否</p><img src="/2025/10/02/CSE-lecture5-Remote-Procedure-Call/fd22e083eed71a927efb9d4f8ef80a31.png" class="" title="server stub"><p>其中message里面包括：</p><ul><li>service id</li><li>service parameter</li><li>marshal&#x2F;unmarshal: 即保证object以序列化的形式传输，从而替代指针，收到消息后根据规则进行反序列化</li></ul><p>RPC request message包括：</p><ul><li>Xid: 即transaction id，保证每个消息都有一个id，便于重发</li><li>call&#x2F;reply</li><li>rpc version</li><li>program #: 调用哪个程序（库文件）</li><li>program version</li><li>procedure #: 调用哪个函数</li><li>auth staff</li><li>arguments: 需要序列化</li></ul><p>RPC reply message包括以下部分：</p><ul><li>Xid</li><li>call&#x2F;reply</li><li>accepted?: 用于判定RPC version</li><li>auth staff</li><li>success?: 用于判定prog&#x2F;proc</li><li>results: 需要序列化</li></ul><p>binding用于寻找服务器，这是依靠服务注册实现的</p><h3 id="how-to-pass-the-data-between-client-server"><a href="#how-to-pass-the-data-between-client-server" class="headerlink" title="how to pass the data between client &amp; server?"></a>how to pass the data between client &amp; server?</h3><p>参数传递充满挑战性：</p><ul><li>跨服务器无法pass by reference，因此需要转换成pointless</li><li>大小端的问题</li><li>client和server的兼容性</li></ul><p>为了表示数据，需要进行encoding，这一般不会是语言特化的</p><p>standard encoding有JSON, XML, CSV等等，好处是人类可读，缺点是可能有二义性、binary strings支持困难等等</p><p>而binary formats难以阅读，但更紧凑、更准确、性能更好</p><p>JSON每次传输时都要出现字段名，而Thrift和Protocol Buffers使用schema来将字段及其类型进行编号码，从而进行压缩</p><p>以Thrift为例：</p><img src="/2025/10/02/CSE-lecture5-Remote-Procedure-Call/b1bcdc87b62594a6bfb45eb8e756b3d5.png" class="" title="The BinaryProtocol of Thrift"><p>压缩还可以进一步进行，需要将这些0去除，比如记录field tag的差值，将数字变为链表存储等等：</p><img src="/2025/10/02/CSE-lecture5-Remote-Procedure-Call/e5cd42d45f962faa66e26271b730392c.png" class="" title="Thrift CompactProtocol"><p>stub代码可以自动生成，这只需要头文件即可</p><p>marshal&#x2F;unmarshal也有可能反而耗时，因此其适用于慢的网速，而网速快时反而不需要压缩（这里是说是否有必要利用marshal的压缩功能，对于指针参数，marshal是必要的）</p><h3 id="when-RPC-meets-failure"><a href="#when-RPC-meets-failure" class="headerlink" title="when RPC meets failure"></a>when RPC meets failure</h3><p>本地调用基本不会出错，但RPC却可能遇到各种各样的错误，而我们的目标为只需要一次调用，而现在有三种场景：</p><ul><li>at-least-once: 反复retry即可</li><li>at-most-once: server记录Xid，出现retry时将过去的结果返回，但问题在于什么时候删除</li><li>exactly-once: 很困难</li></ul><p>需要区分幂等性(idempotent)和非幂等性，幂等的操作反复执行结果是一致的，配合at-least-once可以实现exactly-once</p>]]></content>
    
    
    <categories>
      
      <category>计算机学习</category>
      
      <category>se专业课</category>
      
      <category>cse</category>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>se</tag>
      
      <tag>cse</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSE_lecture4:Distributed System</title>
    <link href="/2025/09/28/CSE-lecture4-Distributed-System/"/>
    <url>/2025/09/28/CSE-lecture4-Distributed-System/</url>
    
    <content type="html"><![CDATA[<h2 id="Scalability-in-Practice-a-Highly-scalable-web-app"><a href="#Scalability-in-Practice-a-Highly-scalable-web-app" class="headerlink" title="Scalability in Practice: a Highly scalable web app"></a>Scalability in Practice: a Highly scalable web app</h2><p>互联网应用需要支撑的三个能力：</p><ul><li>处理海量的请求</li><li>存储海量的数据</li><li>透明化的可拓展性(transparent scale)</li></ul><p>因此我们需要构建一个scalable的系统</p><h3 id="case-study-an-e-commerce-web-application"><a href="#case-study-an-e-commerce-web-application" class="headerlink" title="case study: an e-commerce web application"></a>case study: an e-commerce web application</h3><p>一次点击可能需要上千的服务器处理</p><p>远古时代使用单个服务器架构：应用层、文件系统、数据库集成在一起，但这也导致了一些问题</p><p><em>问题一：存储容量无法满足要求</em></p><h4 id="step-1-for-scalability-disaggregating-application-data"><a href="#step-1-for-scalability-disaggregating-application-data" class="headerlink" title="step 1 for scalability: disaggregating application &amp; data"></a>step 1 for scalability: disaggregating application &amp; data</h4><p>使用大公司提供的数据库和文件系统来存储海量数据，当需要存储更多数据时购买额外的服务即可</p><p>但是每次访问数据都既要访问磁盘，又要网络请求，因此会非常慢</p><h4 id="step-2-avoid-the-slow-data-accesses-caching"><a href="#step-2-avoid-the-slow-data-accesses-caching" class="headerlink" title="step 2 avoid the slow data accesses? caching"></a>step 2 avoid the slow data accesses? caching</h4><p>使用缓存来加速访问数据，这是考虑到大部分访问都是在访问那少部分数据</p><p>但问题在于内存很小，只能放下很少的数据，因此使用多台server来存放cache</p><p>memcached是一种distributed cache server，它使用key-value来标记，从而找到数据存放在个caching server；同时使用路由(routing)来实现key和ip的映射</p><p>使用hash来根据key计算address，公式为 $address &#x3D; Hash(key);%;#server$，使用consistent hashing来保证增加新的server时miss不会太多</p><img src="/2025/09/28/CSE-lecture4-Distributed-System/b606b7ce159f883c8096c36c7f2659d6.png" class="" title="consistent hashing"><p><em>问题二：应用层使用CPU处理，但单个CPU的拓展能力有限，这是由于moore’s law和dennard scaling导致了无法通过提升硬件来解决问题</em></p><h4 id="step-3-for-scalability-more-app-servers"><a href="#step-3-for-scalability-more-app-servers" class="headerlink" title="step 3 for scalability: more app servers"></a>step 3 for scalability: more app servers</h4><p>这对于stateless（即没有上下文）的请求效果良好，而对于stateful的请求效果较差（这是因为其他app server没有context），当然也可以使用一些手段来将stateful转换为stateless（比如将context存储在用户端）</p><p>为了让多个app server的请求流量比较平均，使用load balance，如round-robin, random, hashing等等，好的balance能够考虑到不同请求的时间长短和各个server的不同处理能力</p><h4 id="step-4-for-scalability-distributed-databases"><a href="#step-4-for-scalability-distributed-databases" class="headerlink" title="step 4 for scalability: distributed databases"></a>step 4 for scalability: distributed databases</h4><p>远古时代使用一个数据库只读，一个数据库只写的方法，但这样无法保证正确性</p><p>因此现在使用将数据均匀地分配在不同的机器上，上层使用算法来保证多台机器和单台机器等价，即complex consistency management</p><h4 id="step-5-for-scalability-distributed-file-system"><a href="#step-5-for-scalability-distributed-file-system" class="headerlink" title="step 5 for scalability: distributed file system"></a>step 5 for scalability: distributed file system</h4><p>经过前五步架构，当一个请求来了之后，先进行load balance来防止排队，从而抵达应用层；数据和文件分布在多台机器上，从而按需拓展；缓存层来加速数据访问。因此一次访问需要经过多台服务器</p><p>不同的任务需要不同的scale方法</p><h4 id="step-6-for-scalability-using-CDN"><a href="#step-6-for-scalability-using-CDN" class="headerlink" title="step 6 for scalability: using CDN"></a>step 6 for scalability: using CDN</h4><p>网络服务商上使用CDN来缓存一些数据，在应用层之前就获取到数据，这样离用户更近</p><h4 id="step-7-for-scalability-separate-different-applications"><a href="#step-7-for-scalability-separate-different-applications" class="headerlink" title="step 7 for scalability: separate different applications"></a>step 7 for scalability: separate different applications</h4><p>使用容器来打包应用，使用k8s来管理多个容器</p><p>复杂的请求需要复杂的计算，因此需要使用distributed computing，根据不同的计算场景使用不同的计算框架</p><p>因此每一个应用层后面接一个计算框架，从而提供针对性的服务</p><p>现在我们构成了一个并行与分布式系统，这是在现代数据中心的支持下实现的，这些数据中心都是有备份的</p><h3 id="challenge-fault-handling"><a href="#challenge-fault-handling" class="headerlink" title="challenge: fault handling"></a>challenge: fault handling</h3><p>三种出错方式：</p><ul><li>fault: 可以是潜在的或激活的，可以是软件层面的，也可以是硬件层面的，这是很常见的</li><li>error: 是激活fault的结果</li><li>failure: 发生在错误没有被检测和屏蔽时</li></ul><p>总结一下：Fault（缺陷） -&gt; 激活 -&gt; Error（错误） -&gt; 未被检测&#x2F;屏蔽 -&gt; Failure（失效）</p><p>分布式系统的规模实在太大，导致fault频发，然而，即使有少部分遇到failure，对外依然能够正确运行，而partial failure难以侦测</p><p>以unreliable network为例，请求未响应的原因很多：</p><ul><li>远程服务器挂了</li><li>请求包丢失了</li><li>请求在队列里排队，导致不能及时响应</li><li>垃圾回收的耗时导致远程服务器暂停响应</li><li>响应丢失</li><li>响应延迟</li></ul><p>另一个常见的fault为network partition，即组内能通信，但组与组之间不能，这可能是因为机器或者交换机宕机，也可能是因为物理损坏</p><p>而分布式系统需要处理fault来提供always-on的状态</p><p>可用性是建立在以极快的速度处理fault的基础上，即提升可靠性</p><p>为了达到高可用性，可以使用replications，即冗余，这样只要保证其中之一响应就好，但这样带来了consistency问题；或者使用retry，对于stateless的情况不会有一致性问题，而有些请求会有一致性问题</p><h3 id="CAP-Consistency-availability-partition-tolerance"><a href="#CAP-Consistency-availability-partition-tolerance" class="headerlink" title="CAP: Consistency, availability, partition tolerance"></a>CAP: Consistency, availability, partition tolerance</h3><p>无法在网络分区的情况下同时保证一致性和高可用性，需要牺牲其中之一</p><p>总而言之，分布式系统需要trade-off以下特性：scalability, performance, fault tolarance, consistency, ease of programming</p>]]></content>
    
    
    <categories>
      
      <category>计算机学习</category>
      
      <category>se专业课</category>
      
      <category>cse</category>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>se</tag>
      
      <tag>cse</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSE_lab1攻略</title>
    <link href="/2025/09/27/CSE-lab1%E6%94%BB%E7%95%A5/"/>
    <url>/2025/09/27/CSE-lab1%E6%94%BB%E7%95%A5/</url>
    
    <content type="html"><![CDATA[<h2 id="lab1-Basic-Filesystem"><a href="#lab1-Basic-Filesystem" class="headerlink" title="lab1: Basic Filesystem"></a>lab1: Basic Filesystem</h2><p>在lab1中，我们需要实现一个单机inode-based filesystem，共有三层架构：</p><ul><li>block layer: 包括block manager和block allocator</li><li>inode layer: 包括inode manager</li><li>filesystem layer: 包括create, write, read操作，同时对等directory和file</li></ul><p>lab的每个部分正好对应了这三层</p><p>关于怎么获取lab和配置docker不再赘述，简单说明怎么编译和测试。在<code>chfs</code>目录下使用以下命令进行编译：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> build<br><span class="hljs-built_in">cd</span> build<br>cmake ..<br></code></pre></td></tr></table></figure><p>在<code>build</code>目录下使用以下指令完成单元测试：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">make build-tests -j<br>make <span class="hljs-built_in">test</span> -j<br></code></pre></td></tr></table></figure><p>要进行集成测试，首先在<code>build</code>目录下使用以下指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">make fs -j<br></code></pre></td></tr></table></figure><p>再进入<code>scripts/lab1</code>执行以下命令，请不要使用<code>sudo</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./integration_test.sh<br></code></pre></td></tr></table></figure><p>接下来提供lab1的攻略，在实现lab时，阅读对应的头文件来使用可以简化代码的api</p><h3 id="part-1-block-layer"><a href="#part-1-block-layer" class="headerlink" title="part 1: block layer"></a>part 1: block layer</h3><h4 id="part-1A-block-manager"><a href="#part-1A-block-manager" class="headerlink" title="part 1A: block manager"></a>part 1A: block manager</h4><p>在这一部分，我们需要实现block manager，来进行block的读写和清除</p><p>阅读<code>manager.h</code>和几个构造函数，我们得知block manager的结构为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BlockManager</span>&#123;<br>    <span class="hljs-type">const</span> usize block_sz = <span class="hljs-number">4096</span>         <span class="hljs-comment">// block的大小，也就是4KB</span><br>    u8 *block_data                      <span class="hljs-comment">// 这里管理的是整个磁盘的所有data</span><br>    usize block_cnt                     <span class="hljs-comment">// 整个磁盘有多少block，因此在根据block id进行读写时，要进行判断</span><br>    <span class="hljs-type">bool</span> in_memory                      <span class="hljs-comment">// lab1用不到</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在实现<code>write_block</code>, <code>write_partial_block</code>和<code>zero_block</code>函数时，利用<code>std::memcpy</code>将data写入到<code>block_data</code>对应的位置即可（这里不用管<code>block_data</code>的状态），注意以下几点：</p><ul><li>判断<code>block_id</code>是否超出<code>block_cnt</code></li><li>在<code>write_partial_block</code>中，要额外判断<code>offset + len</code>是否超出<code>block_sz</code></li><li>在<code>zero_block</code>中，直接使用<code>std::memset</code>将block设置为全零即可（这里和上课讲的不太一样，上课时讲的是覆写block，而这里会进行清零）</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">BlockManager::write_block</span><span class="hljs-params">(<span class="hljs-type">block_id_t</span> block_id, <span class="hljs-type">const</span> u8 *data)</span></span><br><span class="hljs-function">    -&gt; ChfsNullResult </span>&#123;<br>  <br>  <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Implement this function.</span><br>  <span class="hljs-comment">// 检查是否越界</span><br>  <span class="hljs-built_in">CHFS_ASSERT</span>(block_id &lt; <span class="hljs-keyword">this</span>-&gt;block_cnt, <span class="hljs-string">&quot;Invalid block id&quot;</span>);<br>  <span class="hljs-comment">// data最多只写入block_sz个字节</span><br>  std::<span class="hljs-built_in">memcpy</span>(<span class="hljs-keyword">this</span>-&gt;block_data + block_id * <span class="hljs-keyword">this</span>-&gt;block_sz, data, <span class="hljs-keyword">this</span>-&gt;block_sz);<br><br>  <span class="hljs-keyword">return</span> KNullOk;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">BlockManager::write_partial_block</span><span class="hljs-params">(<span class="hljs-type">block_id_t</span> block_id, <span class="hljs-type">const</span> u8 *data,</span></span><br><span class="hljs-params"><span class="hljs-function">                                       usize offset, usize len)</span></span><br><span class="hljs-function">    -&gt; ChfsNullResult </span>&#123;<br>  <br>  <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Implement this function.</span><br>  <span class="hljs-built_in">CHFS_ASSERT</span>(block_id &lt; <span class="hljs-keyword">this</span>-&gt;block_cnt, <span class="hljs-string">&quot;Invalid block id&quot;</span>);<br>  <span class="hljs-comment">// 检查offset和len是否合法</span><br>  <span class="hljs-built_in">CHFS_ASSERT</span>(offset + len &lt;= <span class="hljs-keyword">this</span>-&gt;block_sz, <span class="hljs-string">&quot;Invalid offset or length&quot;</span>);<br>  std::<span class="hljs-built_in">memcpy</span>(<span class="hljs-keyword">this</span>-&gt;block_data + block_id * <span class="hljs-keyword">this</span>-&gt;block_sz + offset, data, len);<br><br>  <span class="hljs-keyword">return</span> KNullOk;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">BlockManager::zero_block</span><span class="hljs-params">(<span class="hljs-type">block_id_t</span> block_id)</span> -&gt; ChfsNullResult </span>&#123;<br>  <br>  <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Implement this function.</span><br>  <span class="hljs-built_in">CHFS_ASSERT</span>(block_id &lt; <span class="hljs-keyword">this</span>-&gt;block_cnt, <span class="hljs-string">&quot;Invalid block id&quot;</span>);<br>  <span class="hljs-comment">// 全部置零</span><br>  std::<span class="hljs-built_in">memset</span>(<span class="hljs-keyword">this</span>-&gt;block_data + block_id * <span class="hljs-keyword">this</span>-&gt;block_sz, <span class="hljs-number">0</span>, <span class="hljs-keyword">this</span>-&gt;block_sz);<br><br>  <span class="hljs-keyword">return</span> KNullOk;<br>&#125;<br></code></pre></td></tr></table></figure><p>而<code>read_block</code>函数直接反向<code>std::memcpy</code>即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">BlockManager::read_block</span><span class="hljs-params">(<span class="hljs-type">block_id_t</span> block_id, u8 *data)</span> -&gt; ChfsNullResult </span>&#123;<br><br>  <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Implement this function.</span><br>  <span class="hljs-built_in">CHFS_ASSERT</span>(block_id &lt; <span class="hljs-keyword">this</span>-&gt;block_cnt, <span class="hljs-string">&quot;Invalid block id&quot;</span>);<br>  std::<span class="hljs-built_in">memcpy</span>(data, <span class="hljs-keyword">this</span>-&gt;block_data + block_id * <span class="hljs-keyword">this</span>-&gt;block_sz, <span class="hljs-keyword">this</span>-&gt;block_sz);<br><br>  <span class="hljs-keyword">return</span> KNullOk;<br>&#125;<br></code></pre></td></tr></table></figure><p>这一部分只需要几次<code>ASSERT</code>和几次<code>std::memcpy</code>即可实现，现在可以通过以下单元测试了：</p><ul><li><code>BlockManagerTest.ReadWritePageTest</code></li><li><code>BlockManagerTest.ZeroTest</code></li><li><code>BlockManagerTest.InMemoryTest</code></li></ul><h4 id="part-1B-block-allocator"><a href="#part-1B-block-allocator" class="headerlink" title="part 1B: block allocator"></a>part 1B: block allocator</h4><p>在这一部分，我们需要实现block allocator，根据block bitmap来决定分配哪个block</p><p>还是阅读<code>allocator.h</code>，我们知道block bitmap被存储在多个连续的block里面，即区间<code>[bitmap_block_id, bitmap_block_id + bitmap_block_cnt - 1]</code>，注意以下几点：</p><ul><li>由于是使用bit来存储block是否被使用，因此需要注意byte和bit的转换，即<code>KBitsPerByte</code></li><li>bitmap的最后一个block不一定被使用完，需要分类讨论，并使用<code>last_block_num</code></li></ul><p>再进入<code>bitmap.h</code>，活用以下函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">Bitmap</span>(u8 *data, usize payload)                                     <span class="hljs-comment">// 将读取进入buffer的block内容构造为一个bitmap，便于调用api</span><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">set</span><span class="hljs-params">(usize index)</span>                                               <span class="hljs-comment">// 用于allocate</span></span><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">clear</span><span class="hljs-params">(usize index)</span>                                             <span class="hljs-comment">// 用于deallocate</span></span><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">check</span><span class="hljs-params">(usize index)</span> -&gt; <span class="hljs-type">bool</span>                                     <span class="hljs-comment">// 用于错误处理</span></span><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">find_first_free</span><span class="hljs-params">()</span> -&gt; std::optional&lt;usize&gt;                      <span class="hljs-comment">// 用于allocate</span></span><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">find_first_free_w_bound</span><span class="hljs-params">(usize bits)</span> -&gt; std::optional&lt;usize&gt;    <span class="hljs-comment">// 用于allocate时的最后一个bitmap block</span></span><br></code></pre></td></tr></table></figure><p>参考已经写好的代码，我们其实可以留意到如何进行block的读写，即使用一个buffer来存储内容，届时我们只需要处理buffer.data即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::vector&lt;u8&gt; <span class="hljs-title">buffer</span><span class="hljs-params">(bm-&gt;block_size())</span></span>;<br>bm-&gt;<span class="hljs-built_in">read_block</span>(bid, buffer.<span class="hljs-built_in">data</span>());<br>bm-&gt;<span class="hljs-built_in">write_block</span>(bid, buffer.<span class="hljs-built_in">data</span>());<br></code></pre></td></tr></table></figure><p>接下来实现<code>allocate</code>函数，首先我们进行分类讨论，利用<code>Bitmap</code>类来寻找第一个空的bit</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (i == <span class="hljs-keyword">this</span>-&gt;bitmap_block_cnt - <span class="hljs-number">1</span>) &#123;<br>  <span class="hljs-comment">// If current block is the last block of the bitmap.</span><br><br>  <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Find the first free bit of current bitmap block</span><br>  <span class="hljs-comment">// and store it in `res`.</span><br>  <span class="hljs-comment">// 对于最后一个bitmap block，只搜索last_block_num个bit，这里使用bitmap.h中的相关api</span><br>  res = <span class="hljs-built_in">Bitmap</span>(buffer.<span class="hljs-built_in">data</span>(), bm-&gt;<span class="hljs-built_in">block_size</span>())<br>            .<span class="hljs-built_in">find_first_free_w_bound</span>(<span class="hljs-keyword">this</span>-&gt;last_block_num);<br>  <br>&#125; <span class="hljs-keyword">else</span> &#123;<br><br>  <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Find the first free bit of current bitmap block</span><br>  <span class="hljs-comment">// and store it in `res`.</span><br>  <span class="hljs-comment">// 而其他bitmap block，搜索全部bit</span><br>  res = <span class="hljs-built_in">Bitmap</span>(buffer.<span class="hljs-built_in">data</span>(), bm-&gt;<span class="hljs-built_in">block_size</span>()).<span class="hljs-built_in">find_first_free</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>考虑到我们通过一个循环来遍历bitmap的所有block，因此当<code>res</code>为真时，我们再进行分配，这里分为几步：</p><ul><li>将bitmap的对应位置设为1，使用前面提到的<code>set</code>函数</li><li>将bitmap写回对应的block，怎么读的就怎么写</li><li>计算出要返回的block id，这里就要注意bit和byte的转换了</li></ul><p>实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// The block id of the allocated block.</span><br><span class="hljs-type">block_id_t</span> retval = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">block_id_t</span>&gt;(<span class="hljs-number">0</span>);<br><br><span class="hljs-comment">// <span class="hljs-doctag">TODO:</span></span><br><span class="hljs-comment">// 1. Set the free bit we found to 1 in the bitmap.</span><br><span class="hljs-function">Bitmap <span class="hljs-title">bitmap</span><span class="hljs-params">(buffer.data(), bm-&gt;block_size())</span></span>;<br>bitmap.<span class="hljs-built_in">set</span>(*res);<br><span class="hljs-comment">// 2. Flush the changed bitmap block back to the block manager.</span><br>bm-&gt;<span class="hljs-built_in">write_block</span>(i + <span class="hljs-keyword">this</span>-&gt;bitmap_block_id, buffer.<span class="hljs-built_in">data</span>());<br><span class="hljs-comment">// 3. Calculate the value of `retval`.</span><br>retval = i * (bm-&gt;<span class="hljs-built_in">block_size</span>() * KBitsPerByte) + *res;<br><br><span class="hljs-keyword">return</span> <span class="hljs-built_in">ChfsResult</span>&lt;<span class="hljs-type">block_id_t</span>&gt;(retval);<br></code></pre></td></tr></table></figure><p>接下来实现<code>deallocate</code>函数，其实就是根据bid找到对应的bitmap block，进行<code>clear</code>即可，善用除数和余数定位，步骤如下：</p><ul><li>使用<code>block_id / (bm-&gt;block_size() * KBitsPerByte)</code>和<code>block_id % (bm-&gt;block_size() * KBitsPerByte)</code>定位到是第几个bitmap block的第几个bit，并<code>read_block</code>，在这一部分我们需要使用<code>check</code>函数来判断是否invalid</li><li>使用<code>clear</code>函数置零，再<code>write_block</code></li></ul><p>实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Implement this function.</span><br><span class="hljs-comment">// 1. According to `block_id`, zero the bit in the bitmap.</span><br><span class="hljs-function">std::vector&lt;u8&gt; <span class="hljs-title">buffer</span><span class="hljs-params">(bm-&gt;block_size())</span></span>;<br><span class="hljs-comment">// 每个bitmap block管理block_sz * 8个数据块</span><br>bm-&gt;<span class="hljs-built_in">read_block</span>(<span class="hljs-keyword">this</span>-&gt;bitmap_block_id + block_id / (bm-&gt;<span class="hljs-built_in">block_size</span>() * KBitsPerByte), buffer.<span class="hljs-built_in">data</span>()).<span class="hljs-built_in">unwrap</span>();<br><span class="hljs-function">Bitmap <span class="hljs-title">bitmap</span><span class="hljs-params">(buffer.data(), bm-&gt;block_size())</span></span>;<br><span class="hljs-comment">// 如果该位已经是0了，说明已经被释放</span><br><span class="hljs-keyword">if</span> (!bitmap.<span class="hljs-built_in">check</span>(block_id % (bm-&gt;<span class="hljs-built_in">block_size</span>() * KBitsPerByte))) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">ChfsNullResult</span>(ErrorType::INVALID_ARG);<br>&#125;<br>bitmap.<span class="hljs-built_in">clear</span>(block_id % (bm-&gt;<span class="hljs-built_in">block_size</span>() * KBitsPerByte));<br><span class="hljs-comment">// 2. Flush the changed bitmap block back to the block manager.</span><br><span class="hljs-comment">// unwrap()用于处理ChfsNullResult</span><br>bm-&gt;<span class="hljs-built_in">write_block</span>(<span class="hljs-keyword">this</span>-&gt;bitmap_block_id + block_id / (bm-&gt;<span class="hljs-built_in">block_size</span>() * KBitsPerByte), buffer.<span class="hljs-built_in">data</span>()).<span class="hljs-built_in">unwrap</span>();<br><span class="hljs-comment">// 3. Return ChfsNullResult(ErrorType::INVALID_ARG) </span><br><span class="hljs-comment">//    if you find `block_id` is invalid (e.g. already freed).</span><br></code></pre></td></tr></table></figure><p>现在我们可以通过以下单元测试了：</p><ul><li><code>BlockAllocatorTest.Allocation</code></li></ul><h3 id="part-2-inode-layer"><a href="#part-2-inode-layer" class="headerlink" title="part 2: inode layer"></a>part 2: inode layer</h3><h4 id="part-2A-inode-and-inode-manager"><a href="#part-2A-inode-and-inode-manager" class="headerlink" title="part 2A: inode and inode manager"></a>part 2A: inode and inode manager</h4><p>首先分析一下inode层的架构：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">| Super block | Inode Table | Inode allocation bitmap | Block allocation bitmap | Other data blocks |<br></code></pre></td></tr></table></figure><p>其实和课上的区别就是inode table不再直接存储inode，而是存储inode id和block id的映射关系，也就是说，inode也被当作block处理了</p><p>这里注意inode table和inode bitmap都是存储的raw_id，而暴露给上层的都是logic_id，因此活用<code>RAW_2_LOGIC</code>和<code>LOGIC_2_RAW</code>即可，不过没搞清楚也无所谓，注释会告诉你的</p><p>几个架构的区间为：</p><ul><li>inode table: <code>[1, n_table_blocks]</code>，这是因为有一个super block</li><li>inode allocation bitmap: <code>[1 + n_table_blocks, 1 + n_table_blocks + n_bitmap_blocks]</code></li></ul><p>接下来就来实现几个函数，首先是<code>allocate_inode</code>，代码已经实现了遍历inode bitmap来找到<code>free_idx</code>了，同时也给inode分配好了bid，因此步骤如下：</p><ul><li>实现inode block的写入：创建一个<code>Inode</code>实例，利用构造函数将<code>type</code>刷进去，再使用<code>flush_to_buffer</code>函数将这个inode刷进buffer里面（详见<code>inode.h</code>），最后将buffer写入bid对应的block里面</li><li>实现inode table的写入：使用<code>set_table</code>函数将raw_id存进去,raw_id的计算类似于block bitmap</li><li>返回logic_id</li></ul><p>实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// <span class="hljs-doctag">TODO:</span></span><br><span class="hljs-comment">// 1. Initialize the inode with the given type.</span><br><span class="hljs-comment">// 使用buffer存储inode数据</span><br><span class="hljs-function">std::vector&lt;u8&gt; <span class="hljs-title">buffer</span><span class="hljs-params">(bm-&gt;block_size())</span></span>;<br><span class="hljs-function">Inode <span class="hljs-title">inode</span><span class="hljs-params">(type, bm-&gt;block_size())</span></span>;<br>inode.<span class="hljs-built_in">flush_to_buffer</span>(buffer.<span class="hljs-built_in">data</span>());<br><span class="hljs-comment">// 将buffer的内容写入到bid指定的block中</span><br><span class="hljs-keyword">auto</span> write_res = bm-&gt;<span class="hljs-built_in">write_block</span>(bid, buffer.<span class="hljs-built_in">data</span>());<br><span class="hljs-keyword">if</span> (write_res.<span class="hljs-built_in">is_err</span>()) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">ChfsResult</span>&lt;<span class="hljs-type">inode_id_t</span>&gt;(write_res.<span class="hljs-built_in">unwrap_error</span>());<br>&#125;<br><span class="hljs-comment">// 2. Setup the inode table.</span><br><span class="hljs-comment">// 先根据free_idx和count计算出inode id</span><br><span class="hljs-type">inode_id_t</span> raw_id = count * (bm-&gt;<span class="hljs-built_in">block_size</span>() * KBitsPerByte) + free_idx.<span class="hljs-built_in">value</span>();<br><span class="hljs-comment">// 根据inode id计算出inode index</span><br><span class="hljs-type">inode_id_t</span> logic_id = <span class="hljs-built_in">RAW_2_LOGIC</span>(raw_id);<br><span class="hljs-comment">// 实现bid和inode index的映射关系</span><br><span class="hljs-keyword">auto</span> set_res = <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">set_table</span>(raw_id, bid);<br><span class="hljs-keyword">if</span> (set_res.<span class="hljs-built_in">is_err</span>()) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">ChfsResult</span>&lt;<span class="hljs-type">inode_id_t</span>&gt;(set_res.<span class="hljs-built_in">unwrap_error</span>());<br>&#125;<br><span class="hljs-comment">// 3. Return the id of the allocated inode.</span><br><span class="hljs-keyword">return</span> <span class="hljs-built_in">ChfsResult</span>&lt;<span class="hljs-type">inode_id_t</span>&gt;(logic_id);<br><span class="hljs-comment">//    You may have to use the `RAW_2_LOGIC` macro</span><br><span class="hljs-comment">//    to get the result inode id.</span><br></code></pre></td></tr></table></figure><p>接下来是<code>free_inode</code>，这里提供的是logic_id，注意转换，步骤如下：</p><ul><li>清除inode table：将bid设置为<code>KInvalidBlockID</code>即可，参考<code>manager.h</code></li><li>清除inode bitmap：和1B部分的<code>deallocate</code>基本一致，遗憾的是inode manager没有提供block allocator的接口，所以重复这段代码，注意下区间定位即可</li></ul><p>实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// <span class="hljs-doctag">TODO:</span></span><br><span class="hljs-comment">// 1. Clear the inode table entry.</span><br><span class="hljs-comment">//    You may have to use macro `LOGIC_2_RAW`</span><br><span class="hljs-comment">//    to get the index of inode table from `id`.</span><br><span class="hljs-type">inode_id_t</span> raw_id = <span class="hljs-built_in">LOGIC_2_RAW</span>(id);<br><span class="hljs-comment">// 直接将该entry设置为Invalid</span><br><span class="hljs-keyword">auto</span> set_res = <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">set_table</span>(raw_id, KInvalidBlockID);<br><span class="hljs-keyword">if</span> (set_res.<span class="hljs-built_in">is_err</span>()) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">ChfsNullResult</span>(set_res.<span class="hljs-built_in">unwrap_error</span>());<br>&#125;<br><span class="hljs-comment">// 2. Clear the inode bitmap.</span><br><span class="hljs-comment">// 寻找在inode bitmap的第几个block的第几个bit</span><br><span class="hljs-keyword">auto</span> inode_bits_per_block = bm-&gt;<span class="hljs-built_in">block_size</span>() * KBitsPerByte;<br><span class="hljs-keyword">auto</span> bitmap_block_idx = raw_id / inode_bits_per_block;<br><span class="hljs-keyword">auto</span> bit_idx = raw_id % inode_bits_per_block;<br><span class="hljs-comment">// 每次使用buffer管理读写操作</span><br><span class="hljs-function">std::vector&lt;u8&gt; <span class="hljs-title">buffer</span><span class="hljs-params">(bm-&gt;block_size())</span></span>;<br><span class="hljs-comment">// 从1开始，因为0是super block</span><br><span class="hljs-comment">// inode bitmap从1 + n_table_blocks开始，到1 + n_table_blocks + n_bitmap_blocks结束</span><br>bm-&gt;<span class="hljs-built_in">read_block</span>(<span class="hljs-number">1</span> + n_table_blocks + bitmap_block_idx, buffer.<span class="hljs-built_in">data</span>()).<span class="hljs-built_in">unwrap</span>();<br><span class="hljs-function">Bitmap <span class="hljs-title">bitmap</span><span class="hljs-params">(buffer.data(), bm-&gt;block_size())</span></span>;<br>bitmap.<span class="hljs-built_in">clear</span>(bit_idx);<br>bm-&gt;<span class="hljs-built_in">write_block</span>(<span class="hljs-number">1</span> + n_table_blocks + bitmap_block_idx, buffer.<span class="hljs-built_in">data</span>()).<span class="hljs-built_in">unwrap</span>();<br></code></pre></td></tr></table></figure><p>接下来是<code>get</code>函数，在inode table查找即可，这里的inode table为一个大数组，被存放在多个block当中，所以还是使用除数和余数方法定位，并将读上来的buffer类型转换为<code>block_id_t</code>数组（类型转换非常重要，后面还会出现），实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Implement this function.</span><br><span class="hljs-comment">// Get the block id of inode whose id is `id`</span><br><span class="hljs-comment">// from the inode table. You may have to use</span><br><span class="hljs-comment">// the macro `LOGIC_2_RAW` to get the inode</span><br><span class="hljs-comment">// table index.</span><br><span class="hljs-type">inode_id_t</span> raw_id = <span class="hljs-built_in">LOGIC_2_RAW</span>(id);<br><span class="hljs-keyword">if</span> (raw_id &gt;= max_inode_supported - <span class="hljs-number">1</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">ChfsResult</span>&lt;<span class="hljs-type">block_id_t</span>&gt;(ErrorType::INVALID_ARG);<br>&#125;<br><span class="hljs-comment">// 计算在inode table的第几个block的第几个entry</span><br><span class="hljs-keyword">auto</span> inode_per_block = bm-&gt;<span class="hljs-built_in">block_size</span>() / <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">block_id_t</span>);<br><span class="hljs-keyword">auto</span> block_idx = raw_id / inode_per_block;<br><span class="hljs-keyword">auto</span> entry_idx = raw_id % inode_per_block;<br><span class="hljs-comment">// 使用buffer存储读入的block数据</span><br><span class="hljs-function">std::vector&lt;u8&gt; <span class="hljs-title">buffer</span><span class="hljs-params">(bm-&gt;block_size())</span></span>;<br><span class="hljs-comment">// 注意inode table从1开始，因为0是super block，以1 + n_table_blocks结尾</span><br>bm-&gt;<span class="hljs-built_in">read_block</span>(<span class="hljs-number">1</span> + block_idx, buffer.<span class="hljs-built_in">data</span>()).<span class="hljs-built_in">unwrap</span>();<br><span class="hljs-comment">// 实现转换，保证数组的最小单位是block_id_t</span><br><span class="hljs-type">block_id_t</span> *table = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">block_id_t</span> *&gt;(buffer.<span class="hljs-built_in">data</span>());<br>res_block_id = table[entry_idx];<br><br><span class="hljs-keyword">return</span> <span class="hljs-built_in">ChfsResult</span>&lt;<span class="hljs-type">block_id_t</span>&gt;(res_block_id);<br></code></pre></td></tr></table></figure><p>最后是<code>set_table</code>函数，和<code>get</code>函数非常相似，只不过从读<code>table[entry_idx]</code>变为<code>table[entry_idx] = bid</code>，实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Implement this function.</span><br><span class="hljs-comment">// Fill `bid` into the inode table entry</span><br><span class="hljs-comment">// whose index is `idx`.</span><br><span class="hljs-comment">// 类似于get函数，只不过是写入而不是读取</span><br><span class="hljs-keyword">if</span> (idx &gt;= max_inode_supported - <span class="hljs-number">1</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">ChfsNullResult</span>(ErrorType::INVALID_ARG);<br>&#125;<br><span class="hljs-comment">// 计算在inode table的第几个block的第几个entry</span><br><span class="hljs-keyword">auto</span> inode_per_block = bm-&gt;<span class="hljs-built_in">block_size</span>() / <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">block_id_t</span>);<br><span class="hljs-keyword">auto</span> block_idx = idx / inode_per_block;<br><span class="hljs-keyword">auto</span> entry_idx = idx % inode_per_block;<br><span class="hljs-comment">// 使用buffer存储写入的block数据</span><br><span class="hljs-function">std::vector&lt;u8&gt; <span class="hljs-title">buffer</span><span class="hljs-params">(bm-&gt;block_size())</span></span>;<br>bm-&gt;<span class="hljs-built_in">read_block</span>(<span class="hljs-number">1</span> + block_idx, buffer.<span class="hljs-built_in">data</span>()).<span class="hljs-built_in">unwrap</span>();<br><span class="hljs-comment">// 实现转换，保证数组的最小单位是block_id_t</span><br><span class="hljs-type">block_id_t</span> *table = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">block_id_t</span> *&gt;(buffer.<span class="hljs-built_in">data</span>());<br>table[entry_idx] = bid;<br>bm-&gt;<span class="hljs-built_in">write_block</span>(<span class="hljs-number">1</span> + block_idx, buffer.<span class="hljs-built_in">data</span>()).<span class="hljs-built_in">unwrap</span>();<br></code></pre></td></tr></table></figure><p>这一部分实现后，即可通过以下测试：</p><ul><li><code>InodeManagerTest.InitAndTable</code></li><li><code>InodeManagerTest.Allocation</code></li></ul><h3 id="part-3-filesystem-layer"><a href="#part-3-filesystem-layer" class="headerlink" title="part 3: filesystem layer"></a>part 3: filesystem layer</h3><p>在filesystem层，我们可以尽情使用<code>block_manager_</code>, <code>inode_manager_</code>, <code>block_allocator_</code>的相关api了</p><p>本部分的错误处理过于冗余，因此提供的代码会进行简化</p><h4 id="part-3A-create"><a href="#part-3A-create" class="headerlink" title="part 3A: create"></a>part 3A: create</h4><p>本部分实现<code>alloc_inode</code>函数，按照以下步骤即可：</p><ul><li>为inode分配一个空闲block：使用block allocator的<code>allocate</code>函数获取bid即可，注意我们的数据都经过<code>ChfsResult</code>包装过，便于进行错误检查，要想获得里面的数据，使用<code>unwrap()</code>即可</li><li>分配inode：使用inode manager的<code>allocate_inode</code>函数即可</li><li>初始化inode block：这里其实在上一步就已经实现了</li></ul><p>部分实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// <span class="hljs-doctag">TODO:</span></span><br><span class="hljs-comment">// 1. Allocate a block for the inode.</span><br><span class="hljs-keyword">auto</span> block_res = <span class="hljs-keyword">this</span>-&gt;block_allocator_-&gt;<span class="hljs-built_in">allocate</span>();<br><span class="hljs-comment">// unwrap用于获取Result的值，即获取bid，提供给allocate_inode使用</span><br><span class="hljs-type">block_id_t</span> bid = block_res.<span class="hljs-built_in">unwrap</span>();<br><span class="hljs-comment">// 2. Allocate an inode.</span><br>inode_res = <span class="hljs-keyword">this</span>-&gt;inode_manager_-&gt;<span class="hljs-built_in">allocate_inode</span>(type, bid);<br><span class="hljs-comment">// 3. Initialize the inode block</span><br><span class="hljs-comment">//    and write the block back to block manager.</span><br></code></pre></td></tr></table></figure><p>现在能通过以下单元测试了：</p><ul><li><code>BasicFileSystemTest.Init</code></li><li><code>FileSystemTest.CreateAndGetAttr</code></li></ul><h4 id="part-3B-read-and-write"><a href="#part-3B-read-and-write" class="headerlink" title="part 3B: read and write"></a>part 3B: read and write</h4><p>这部分应该是整个lab最难的部分，因为需要同时考虑direct block和indirect block（幸运的是，有足够的证据证明每个inode只有一个indirect block），因此回到<code>inode.h</code>，寻找一些和这俩有关的api，后面会用到</p><p>为了克服难题，我们需要认真阅读两个函数中已经实现的部分</p><p>首先是<code>read_file</code>函数，该函数根据inode id干了这些事：</p><ul><li>读取inode，将其变成了<code>inode_p</code>指针，注意这一阶段分配了一个<code>std::vector&lt;u8&gt; indirect_block(0)</code>，便于到时候我们缓存indirect block的内容</li><li>遍历inode存放的所有block id，分类讨论是否是indirect block来准确获得存放file的bid</li><li>根据bid进行<code>read_file</code>，追加到content中，注意这个content是一个<code>std::vector&lt;u8&gt;</code>，而不是一个<code>std::string</code>，在转换时注意类型转换</li></ul><p>我们要实现的是第2、3步，分别来说一下，首先是获取bid这一步，分类讨论：</p><ul><li>direct block：直接读取blocks数组的对应位置即可</li><li>indirect block：使用<code>get_indirect_block_id</code>函数将indirect读取进入<code>indirect_block.data()</code>这一缓冲区，将其转换成<code>block_id_t</code>数组，最后定位到数组对应位置即可，注意在定位时要减去<code>get_direct_block_num</code></li></ul><p>实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Get current block id.</span><br><span class="hljs-type">block_id_t</span> bid = KInvalidBlockID;<br><span class="hljs-keyword">if</span> (inode_p-&gt;<span class="hljs-built_in">is_direct_block</span>(read_sz / block_size)) &#123;<br>  <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Implement the case of direct block.</span><br>  <span class="hljs-comment">// 直接从inode中获取block id</span><br>  bid = inode_p-&gt;blocks[read_sz / block_size];<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Implement the case of indirect block.</span><br>  <span class="hljs-comment">// 先进入indirect block，再从indirect block中获取block id</span><br>  block_manager_-&gt;<span class="hljs-built_in">read_block</span>(inode_p-&gt;<span class="hljs-built_in">get_indirect_block_id</span>(),<br>                             indirect_block.<span class="hljs-built_in">data</span>());<br>  <span class="hljs-comment">// 将indirect_block转换为block_id_t数组</span><br>  <span class="hljs-keyword">auto</span> indirect_block_p =<br>      <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">block_id_t</span> *&gt;(indirect_block.<span class="hljs-built_in">data</span>());<br>  <span class="hljs-comment">// 在indirect block中，从direct block的数量开始找</span><br>  bid =<br>      indirect_block_p[read_sz / block_size - inode_p-&gt;<span class="hljs-built_in">get_direct_block_num</span>()];<br>&#125;<br></code></pre></td></tr></table></figure><p>然后是读取文件到content这一步，比较简单，善用内置api即可：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Read from current block and store to `content`.</span><br><span class="hljs-keyword">auto</span> read_res = <span class="hljs-keyword">this</span>-&gt;block_manager_-&gt;<span class="hljs-built_in">read_block</span>(bid, buffer.<span class="hljs-built_in">data</span>());<br><span class="hljs-comment">// content用于存放file读取的内容</span><br>content.<span class="hljs-built_in">insert</span>(content.<span class="hljs-built_in">end</span>(), buffer.<span class="hljs-built_in">data</span>(), buffer.<span class="hljs-built_in">data</span>() + sz);  <br>read_sz += sz;<br></code></pre></td></tr></table></figure><p>其次是<code>write_file</code>函数，这个函数很冗长，干了这些事：</p><ul><li>依然是读取inode</li><li>比较<code>inode_p-&gt;get_size()</code>和<code>content.size()</code>，看是否需要分配新的block或者释放多余的block（从这里就能看出，write_file是直接进行覆写），当然这里又要分类讨论是否是indirect block了</li><li>将content分block_size写入对应的block中，这里还是要分类讨论是否是indirect block</li><li>更新inode，所以我们在前面直接作用于inode_p即可，不用对inode block进行读写，<strong>但是，indirect block在这里可没更新，因此在前面必须要进行indirect block的读写</strong>（你可以理解成除了inode block以外的block平等地需要在前面就读写）</li></ul><p>我们要实现的依然是2、3步，注意分类讨论即可，由于复杂的错误处理逻辑，代码相当冗长，本攻略直接跳过了，交给代码补全吧</p><p>先说分配更多的block这一步，遍历inode里面的blocks数组的idx时：</p><ul><li>使用block allocator进行<code>allocate</code>，得到bid</li><li>根据idx判断是否是indirect block<ul><li>direct block: 直接<code>set_block_direct</code></li><li>indirect block: 使用<code>get_or_insert-indirect_block</code>分配一个indirect block，然后<code>read_block</code>得到indirect block的<code>block_id_t</code>数组，修改对应位置后<code>write_block</code></li></ul></li></ul><p>实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Implement the case of allocating more blocks.</span><br><span class="hljs-comment">// 1. Allocate a block.</span><br><span class="hljs-keyword">auto</span> res = <span class="hljs-keyword">this</span>-&gt;block_allocator_-&gt;<span class="hljs-built_in">allocate</span>();<br><span class="hljs-type">block_id_t</span> bid = res.<span class="hljs-built_in">unwrap</span>();<br><span class="hljs-comment">// 2. Fill the allocated block id to the inode.</span><br><span class="hljs-comment">//    You should pay attention to the case of indirect block.</span><br><span class="hljs-comment">//    You may use function `get_or_insert_indirect_block`</span><br><span class="hljs-comment">//    in the case of indirect block.</span><br><span class="hljs-comment">// 分类讨论是否是direct block</span><br><span class="hljs-keyword">if</span> (inode_p-&gt;<span class="hljs-built_in">is_direct_block</span>(idx)) &#123;<br>  <span class="hljs-comment">// Direct block</span><br>  inode_p-&gt;<span class="hljs-built_in">set_block_direct</span>(idx, bid);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-comment">// Indirect block</span><br>  <span class="hljs-keyword">auto</span> indirect_res =<br>      inode_p-&gt;<span class="hljs-built_in">get_or_insert_indirect_block</span>(<span class="hljs-keyword">this</span>-&gt;block_allocator_);<br>  <span class="hljs-comment">// 读取indirect block内容到indirect_block</span><br>  <span class="hljs-keyword">auto</span> read_res = <span class="hljs-keyword">this</span>-&gt;block_manager_-&gt;<span class="hljs-built_in">read_block</span>(<br>      inode_p-&gt;<span class="hljs-built_in">get_indirect_block_id</span>(), indirect_block.<span class="hljs-built_in">data</span>());<br>  <span class="hljs-comment">// 将indirect_block转换为block_id_t数组</span><br>  <span class="hljs-keyword">auto</span> indirect_block_p =<br>      <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">block_id_t</span> *&gt;(indirect_block.<span class="hljs-built_in">data</span>());<br>  <span class="hljs-comment">// 在indirect block中，从direct block的数量开始找</span><br>  indirect_block_p[idx - inode_p-&gt;<span class="hljs-built_in">get_direct_block_num</span>()] = bid;<br>  <span class="hljs-comment">// 将修改后的indirect block写回block manager</span><br>  <span class="hljs-comment">// 而inode本身暂时不用写回磁盘，等最后一起写回</span><br>  <span class="hljs-keyword">auto</span> write_res = <span class="hljs-keyword">this</span>-&gt;block_manager_-&gt;<span class="hljs-built_in">write_block</span>(<br>      inode_p-&gt;<span class="hljs-built_in">get_indirect_block_id</span>(), indirect_block.<span class="hljs-built_in">data</span>());<br><br>&#125;<br></code></pre></td></tr></table></figure><p>释放多余的block就是将对应的位置变为KInvalidBlockID即可，变化不大，注意获取到bid进行deallocate即可。我们不用管indirect block本身释放的问题，因为代码已经实现了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (inode_p-&gt;<span class="hljs-built_in">is_direct_block</span>(idx)) &#123;<br><br>  <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Free the direct extra block.</span><br>  <span class="hljs-type">block_id_t</span> bid = inode_p-&gt;blocks[idx];<br>  <span class="hljs-keyword">auto</span> res = <span class="hljs-keyword">this</span>-&gt;block_allocator_-&gt;<span class="hljs-built_in">deallocate</span>(bid);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><br>  <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Free the indirect extra block.</span><br>  <span class="hljs-comment">// 进入到indirect block，回收里面存放的block</span><br>  <span class="hljs-keyword">auto</span> indirect_block_id = inode_p-&gt;<span class="hljs-built_in">get_indirect_block_id</span>();<br>  <span class="hljs-keyword">auto</span> read_res =<br>      <span class="hljs-keyword">this</span>-&gt;block_manager_-&gt;<span class="hljs-built_in">read_block</span>(indirect_block_id, indirect_block.<span class="hljs-built_in">data</span>());<br>  <span class="hljs-keyword">auto</span> indirect_block_p =<br>      <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">block_id_t</span> *&gt;(indirect_block.<span class="hljs-built_in">data</span>());<br>  <span class="hljs-type">block_id_t</span> bid = indirect_block_p[idx - inode_p-&gt;<span class="hljs-built_in">get_direct_block_num</span>()];<br>  <span class="hljs-keyword">auto</span> res = <span class="hljs-keyword">this</span>-&gt;block_allocator_-&gt;<span class="hljs-built_in">deallocate</span>(bid);<br>  <span class="hljs-comment">// 既然之前有read_block，现在就要写回indirect block</span><br>  indirect_block_p[idx - inode_p-&gt;<span class="hljs-built_in">get_direct_block_num</span>()] = KInvalidBlockID;<br>  <span class="hljs-keyword">auto</span> write_res = <span class="hljs-keyword">this</span>-&gt;block_manager_-&gt;<span class="hljs-built_in">write_block</span>(indirect_block_id, indirect_block.<span class="hljs-built_in">data</span>());<br>&#125;<br></code></pre></td></tr></table></figure><p>最后以block_size为单位将content写入block即可（由于已经<code>std::memcpy</code>过，故我们操作的是<code>buffer.data()</code>），分类讨论是否是indirect block即可，这里和read_file区别不大：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::vector&lt;u8&gt; <span class="hljs-title">buffer</span><span class="hljs-params">(block_size)</span></span>;<br><span class="hljs-built_in">memcpy</span>(buffer.<span class="hljs-built_in">data</span>(), content.<span class="hljs-built_in">data</span>() + write_sz, sz);<br><br><span class="hljs-type">block_id_t</span> bid = KInvalidBlockID;<br><span class="hljs-keyword">if</span> (inode_p-&gt;<span class="hljs-built_in">is_direct_block</span>(block_idx)) &#123;<br><br>  <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Implement getting block id of current direct block.</span><br>  bid = inode_p-&gt;blocks[block_idx];<br><br>&#125; <span class="hljs-keyword">else</span> &#123;<br><br>  <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Implement getting block id of current indirect block.</span><br>  <span class="hljs-comment">// 先进入到indirect block，再从indirect block中获取block id</span><br>  block_manager_-&gt;<span class="hljs-built_in">read_block</span>(inode_p-&gt;<span class="hljs-built_in">get_indirect_block_id</span>(),<br>                             indirect_block.<span class="hljs-built_in">data</span>());<br>  <span class="hljs-comment">// 将indirect_block转换为block_id_t数组</span><br>  <span class="hljs-keyword">auto</span> indirect_block_p =<br>      <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">block_id_t</span> *&gt;(indirect_block.<span class="hljs-built_in">data</span>());<br>  <span class="hljs-comment">// 在indirect block中，从direct block的数量开始找</span><br>  bid = indirect_block_p[block_idx - inode_p-&gt;<span class="hljs-built_in">get_direct_block_num</span>()];<br><br>&#125;<br><br><span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Write to current block.</span><br><span class="hljs-keyword">auto</span> write_res = <span class="hljs-keyword">this</span>-&gt;block_manager_-&gt;<span class="hljs-built_in">write_block</span>(bid, buffer.<span class="hljs-built_in">data</span>());<br><br>write_sz += sz;<br>block_idx += <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>实现复杂的逻辑后，我们可以通过以下测试了：</p><ul><li><code>FileSystemTest.WriteLargeFile</code></li><li><code>FileSystemTest.SetAttr</code></li></ul><h4 id="part-3C-operations-on-directory-entries"><a href="#part-3C-operations-on-directory-entries" class="headerlink" title="part 3C: operations on directory entries"></a>part 3C: operations on directory entries</h4><p>这一部分主要就是一些<code>std::string</code>操作，比较简单，<strong>但是一定要注意，content不是string类型，因此类型转换时要相当小心</strong></p><p>关于<code>parse_directory</code>函数，它是<code>dir_list_to_string</code>的反函数（后面会用到），使用stream来分割字符串即可，注意<code>std::string</code>和<code>inode_id_t</code>的类型转换可以使用内置的<code>string_to_inode_id</code>函数即可：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">parse_directory</span><span class="hljs-params">(std::string &amp;src, std::list&lt;DirectoryEntry&gt; &amp;list)</span> </span>&#123;<br><br>  <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Implement this function.</span><br>  <span class="hljs-comment">// 使用stream来分割字符串</span><br>  <span class="hljs-function">std::stringstream <span class="hljs-title">ss</span><span class="hljs-params">(src)</span></span>;<br>  std::string item;<br>  <span class="hljs-keyword">while</span> (std::<span class="hljs-built_in">getline</span>(ss, item, <span class="hljs-string">&#x27;/&#x27;</span>)) &#123;<br>    <span class="hljs-keyword">auto</span> pos = item.<span class="hljs-built_in">find</span>(<span class="hljs-string">&#x27;:&#x27;</span>);<br>    <span class="hljs-keyword">if</span> (pos != std::string::npos) &#123;<br>      DirectoryEntry entry;<br>      entry.name = item.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, pos);<br>      std::string id_str = item.<span class="hljs-built_in">substr</span>(pos + <span class="hljs-number">1</span>);<br>      entry.id = <span class="hljs-built_in">string_to_inode_id</span>(id_str);<br>      list.<span class="hljs-built_in">push_back</span>(entry); <br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>关于<code>read_directory</code>函数，其使用<code>read_file</code>函数将directory抽象成的file的<code>content.unwrap()</code>读取上来，<strong>使用<code>reinterpret_cast&lt;const char*&gt;</code>进行类型转换</strong>，最后使用<code>parse_directory</code>函数将directory变成<code>std::list&lt;DirectoryEntry&gt;</code>即可：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">read_directory</span><span class="hljs-params">(FileOperation *fs, <span class="hljs-type">inode_id_t</span> id,</span></span><br><span class="hljs-params"><span class="hljs-function">                    std::list&lt;DirectoryEntry&gt; &amp;list)</span> -&gt; ChfsNullResult </span>&#123;<br>  <br>  <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Implement this function.</span><br>  <span class="hljs-comment">// 根据inode id找到directory所在的file</span><br>  <span class="hljs-keyword">auto</span> content = fs-&gt;<span class="hljs-built_in">read_file</span>(id);<br>  <span class="hljs-keyword">if</span> (content.<span class="hljs-built_in">is_err</span>()) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">ChfsNullResult</span>(content.<span class="hljs-built_in">unwrap_error</span>());<br>  &#125;<br>  <span class="hljs-comment">// 将存储的string转换成list&lt;entry&gt;</span><br>  <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;vec = content.<span class="hljs-built_in">unwrap</span>();<br>  <span class="hljs-function">std::string <span class="hljs-title">data</span><span class="hljs-params">(<span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-type">const</span> <span class="hljs-type">char</span>*&gt;(vec.data()), vec.size())</span></span>;<br>  <span class="hljs-built_in">parse_directory</span>(data, list);<br><br>  <span class="hljs-keyword">return</span> KNullOk;<br>&#125;<br></code></pre></td></tr></table></figure><p>而<code>append_to_directory</code>主要就是直接操作<code>std::string</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">append_to_directory</span><span class="hljs-params">(std::string src, std::string filename, <span class="hljs-type">inode_id_t</span> id)</span></span><br><span class="hljs-function">    -&gt; std::string </span>&#123;<br><br>  <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Implement this function.</span><br>  <span class="hljs-comment">//       Append the new directory entry to `src`.</span><br>  <span class="hljs-comment">// 将&#x27;/&#x27;补上去</span><br>  <span class="hljs-keyword">if</span> (!src.<span class="hljs-built_in">empty</span>()) &#123;<br>    src += <span class="hljs-string">&#x27;/&#x27;</span>;<br>  &#125;<br>  src += filename + <span class="hljs-string">&#x27;:&#x27;</span> + <span class="hljs-built_in">inode_id_to_string</span>(id);<br>  <br>  <span class="hljs-keyword">return</span> src;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后<code>rm_from_directory</code>将src遍历一次，将不是filename的部分写入到返回值即可：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">rm_from_directory</span><span class="hljs-params">(std::string src, std::string filename)</span> -&gt; std::string </span>&#123;<br><br>  <span class="hljs-keyword">auto</span> res = std::<span class="hljs-built_in">string</span>(<span class="hljs-string">&quot;&quot;</span>);<br><br>  <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Implement this function.</span><br>  <span class="hljs-comment">//       Remove the directory entry from `src`.</span><br>  <span class="hljs-comment">// 使用stream来分割字符串，将不等于filename的部分重新拼接起来</span><br>  <span class="hljs-function">std::stringstream <span class="hljs-title">ss</span><span class="hljs-params">(src)</span></span>;<br>  std::string item;<br>  <span class="hljs-type">bool</span> first = <span class="hljs-literal">true</span>;<br>  <span class="hljs-keyword">while</span> (std::<span class="hljs-built_in">getline</span>(ss, item, <span class="hljs-string">&#x27;/&#x27;</span>)) &#123;<br>    <span class="hljs-keyword">auto</span> pos = item.<span class="hljs-built_in">find</span>(<span class="hljs-string">&#x27;:&#x27;</span>);<br>    <span class="hljs-keyword">if</span> (pos != std::string::npos) &#123;<br>      std::string name = item.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, pos);<br>      <span class="hljs-keyword">if</span> (name != filename) &#123;<br>        <span class="hljs-keyword">if</span> (!first) &#123;<br>          res += <span class="hljs-string">&#x27;/&#x27;</span>;<br>        &#125;<br>        res += item;<br>        first = <span class="hljs-literal">false</span>;<br>      &#125;<br>    &#125;<br>  &#125; <br><br>  <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在我们可以通过以下测试了：</p><ul><li><code>FileSystemBase.Utilities</code></li><li><code>FileSystemBase.UtilitiesRemove</code></li><li><code>FileSystemTest.DirectOperationAdd</code></li></ul><h4 id="part-3D-combine-directory-and-file-together"><a href="#part-3D-combine-directory-and-file-together" class="headerlink" title="part 3D: combine directory and file together"></a>part 3D: combine directory and file together</h4><p>这部分主要是操作directory抽象成的file，活用上一部分的几个函数即可，还是注意<code>content.unwrap()</code>的类型转换即可，本攻略依然忽略部分冗余的错误处理以简化逻辑</p><p>首先<code>lookup</code>函数要求我们使用<code>read_directory</code>函数获得<code>std::list&lt;DirectoryEntry&gt;</code>，遍历这个list即可：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">FileOperation::lookup</span><span class="hljs-params">(<span class="hljs-type">inode_id_t</span> id, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name)</span></span><br><span class="hljs-function">    -&gt; ChfsResult&lt;<span class="hljs-type">inode_id_t</span>&gt; </span>&#123;<br>  std::list&lt;DirectoryEntry&gt; list;<br><br>  <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Implement this function.</span><br>  <span class="hljs-comment">// 根据inode id找到directory所在的file</span><br>  <span class="hljs-keyword">auto</span> read_res = <span class="hljs-built_in">read_directory</span>(<span class="hljs-keyword">this</span>, id, list);<br>  <span class="hljs-comment">// 在list中寻找name对应的entry</span><br>  <span class="hljs-keyword">auto</span> it = std::<span class="hljs-built_in">find_if</span>(list.<span class="hljs-built_in">begin</span>(), list.<span class="hljs-built_in">end</span>(),<br>                         [name](<span class="hljs-type">const</span> DirectoryEntry &amp;entry) &#123;<br>                           <span class="hljs-keyword">return</span> entry.name == name;<br>                         &#125;);<br>  <span class="hljs-keyword">if</span> (it != list.<span class="hljs-built_in">end</span>()) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">ChfsResult</span>&lt;<span class="hljs-type">inode_id_t</span>&gt;(it-&gt;id);<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">ChfsResult</span>&lt;<span class="hljs-type">inode_id_t</span>&gt;(ErrorType::NotExist);<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来<code>mk_helper</code>函数分为以下几步：</p><ul><li>使用<code>lookup</code>函数判断是否已经在里面</li><li>为这个文件分配新的inode</li><li>将新的<code>filename &lt;-&gt; inode num</code>映射关系写回directory即可（当然这里步骤重复了，你可以不使用lookup函数，这样可以少一次<code>read_directory</code>；或者使用<code>append_to_directory</code>简化代码也可以）</li></ul><p>实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">FileOperation::mk_helper</span><span class="hljs-params">(<span class="hljs-type">inode_id_t</span> id, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name, InodeType type)</span></span><br><span class="hljs-function">    -&gt; ChfsResult&lt;<span class="hljs-type">inode_id_t</span>&gt; </span>&#123;<br><br>  <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span></span><br>  <span class="hljs-comment">// 1. Check if `name` already exists in the parent.</span><br>  <span class="hljs-comment">//    If already exist, return ErrorType::AlreadyExist.</span><br>  <span class="hljs-comment">// 直接使用lookup函数</span><br>  <span class="hljs-keyword">auto</span> lookup_res = <span class="hljs-built_in">lookup</span>(id, name);<br>  <span class="hljs-comment">// 排除掉已存在和其他错误</span><br>  <span class="hljs-keyword">if</span> (lookup_res.<span class="hljs-built_in">is_ok</span>()) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">ChfsResult</span>&lt;<span class="hljs-type">inode_id_t</span>&gt;(ErrorType::AlreadyExist);<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (lookup_res.<span class="hljs-built_in">unwrap_error</span>() != ErrorType::NotExist) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">ChfsResult</span>&lt;<span class="hljs-type">inode_id_t</span>&gt;(lookup_res.<span class="hljs-built_in">unwrap_error</span>());<br>  &#125;<br>  <span class="hljs-comment">// 2. Create the new inode.</span><br>  <span class="hljs-keyword">auto</span> alloc_res = <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">alloc_inode</span>(type);<br>  <span class="hljs-type">inode_id_t</span> new_inode_id = alloc_res.<span class="hljs-built_in">unwrap</span>();<br>  <span class="hljs-comment">// 3. Append the new entry to the parent directory.</span><br>  <span class="hljs-comment">// 使用read directory函数得到list</span><br>  <span class="hljs-keyword">auto</span> list = std::<span class="hljs-built_in">list</span>&lt;DirectoryEntry&gt;();<br>  <span class="hljs-keyword">auto</span> read_res = <span class="hljs-built_in">read_directory</span>(<span class="hljs-keyword">this</span>, id, list);<br>  <span class="hljs-comment">// 将新inode添加到目录中</span><br>  list.<span class="hljs-built_in">push_back</span>(DirectoryEntry&#123;std::<span class="hljs-built_in">string</span>(name), new_inode_id&#125;);<br>  <span class="hljs-comment">// 将list转换成string</span><br>  std::string data = <span class="hljs-built_in">dir_list_to_string</span>(list);<br>  <span class="hljs-comment">// 将string写回到文件中</span><br>  <span class="hljs-function">std::vector&lt;u8&gt; <span class="hljs-title">new_content</span><span class="hljs-params">(data.begin(), data.end())</span></span>;<br>  <span class="hljs-keyword">auto</span> write_res = <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">write_file</span>(id, new_content);<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">ChfsResult</span>&lt;<span class="hljs-type">inode_id_t</span>&gt;(new_inode_id);<br><br>  <span class="hljs-comment">// return ChfsResult&lt;inode_id_t&gt;(static_cast&lt;inode_id_t&gt;(0));</span><br>&#125;<br></code></pre></td></tr></table></figure><p>最后是<code>unlink</code>函数，步骤如下：</p><ul><li>使用<code>lookup</code>函数找到inode id来<code>remove_file</code>（参考<code>operations.h</code>）</li><li>使用<code>read_directory</code>得到list，删除filename对应的条目后写回文件即可（类似于<code>mk_helper</code>的最后一步，当然也可以使用<code>rm_from_directory</code>简化代码）</li></ul><p>实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">FileOperation::unlink</span><span class="hljs-params">(<span class="hljs-type">inode_id_t</span> parent, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name)</span></span><br><span class="hljs-function">    -&gt; ChfsNullResult </span>&#123;<br><br>  <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> </span><br>  <span class="hljs-comment">// 1. Remove the file, you can use the function `remove_file`</span><br>  <span class="hljs-comment">// 使用lookup找到对应的inode id</span><br>  <span class="hljs-keyword">auto</span> lookup_res = <span class="hljs-built_in">lookup</span>(parent, name);<br>  <span class="hljs-type">inode_id_t</span> target_id = lookup_res.<span class="hljs-built_in">unwrap</span>();<br>  <span class="hljs-keyword">auto</span> remove_res = <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">remove_file</span>(target_id);<br>  <span class="hljs-comment">// 2. Remove the entry from the directory.</span><br>  <span class="hljs-comment">// 使用read directory函数得到list</span><br>  <span class="hljs-keyword">auto</span> list = std::<span class="hljs-built_in">list</span>&lt;DirectoryEntry&gt;();<br>  <span class="hljs-keyword">auto</span> read_res = <span class="hljs-built_in">read_directory</span>(<span class="hljs-keyword">this</span>, parent, list);<br>  <span class="hljs-comment">// 在list中删除对应的entry</span><br>  list.<span class="hljs-built_in">remove_if</span>([name](<span class="hljs-type">const</span> DirectoryEntry &amp;entry) &#123;<br>    <span class="hljs-keyword">return</span> entry.name == name;<br>  &#125;);<br>  <span class="hljs-comment">// 将list转换成string</span><br>  std::string data = <span class="hljs-built_in">dir_list_to_string</span>(list);<br>  <span class="hljs-comment">// 将string写回到文件中</span><br>  <span class="hljs-function">std::vector&lt;u8&gt; <span class="hljs-title">new_content</span><span class="hljs-params">(data.begin(), data.end())</span></span>;<br>  <span class="hljs-keyword">auto</span> write_res = <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">write_file</span>(parent, new_content);<br>  <span class="hljs-keyword">return</span> KNullOk;<br>&#125;<br></code></pre></td></tr></table></figure><p>完成最后一部分后，可以通过以下单元测试：</p><ul><li><code>FileSystemTest.mkdir</code></li></ul><p>跑完所有单元测试后，跑跑集成测试即可</p><p>总结一下这个lab，难度不大，步骤注释都有写，根据头文件熟悉api即可，注意两个坑：</p><ul><li>write_file一定要在读取indirect block后及时写回</li><li><code>std:vector&lt;u8&gt;</code>转换成<code>std::string</code>时，一定要使用<code>reinterpret_cast&lt;const char*&gt;</code>，这样<code>std::string</code>才能正确解读<code>u8 -&gt; char</code></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机学习</category>
      
      <category>se专业课</category>
      
      <category>cse</category>
      
      <category>lab</category>
      
    </categories>
    
    
    <tags>
      
      <tag>se</tag>
      
      <tag>cse</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSE_lecture3:File System 2</title>
    <link href="/2025/09/23/CSE-lecture3-File-System-2/"/>
    <url>/2025/09/23/CSE-lecture3-File-System-2/</url>
    
    <content type="html"><![CDATA[<h2 id="File-System-API-and-Disk-I-O"><a href="#File-System-API-and-Disk-I-O" class="headerlink" title="File System API and Disk I&#x2F;O"></a>File System API and Disk I&#x2F;O</h2><h3 id="implement-the-file-system-API"><a href="#implement-the-file-system-API" class="headerlink" title="implement the file system API"></a>implement the file system API</h3><p>API有以下几个：</p><ul><li><code>CHDIR</code>（即cd）, <code>MKDIR</code></li><li><code>CREAT</code>, <code>LINK</code>, <code>UNLINK</code>, <code>RENAME</code></li><li><code>SYMLINK</code></li><li><code>MOUNT</code>, <code>UNMOUNT</code>（读取super block）</li><li><code>OPEN</code>, <code>READ</code>, <code>WRITE</code>, <code>APPEND</code>, <code>CLOSE</code></li><li><code>SYNC</code>（将内存数据放到磁盘上）</li></ul><p>这些API通过system call暴露给用户</p><p>区分一下<code>open()</code>和<code>fopen()</code>：</p><ul><li>open是来自操作系统的system call，而fopen是c语言规范中libc的一个API</li><li>open返回一个fd，而fopen返回一个指向文件的指针</li><li>只有fopen在windows和linux上都同名，而open不见得</li><li>fopen具备更好的性能，因为fopen使用了一个buffer I&#x2F;O，可能并没有直接写入磁盘</li></ul><p>inode是file的metadata，里面除了上节课讲的几个之外，还有：</p><ul><li>owner id: 用于权限控制</li><li>types of permission: 谁有权限，有哪些权限（mode: read, write, execute）</li><li>time stamps: access time（管理read）, modify time（管理write）, change of time（管理link）</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span></span><br><span class="hljs-class">    <span class="hljs-title">integer</span> <span class="hljs-title">block_nums</span>[<span class="hljs-title">N</span>]</span><br><span class="hljs-class">    <span class="hljs-title">integer</span> <span class="hljs-title">size</span></span><br><span class="hljs-class">    <span class="hljs-title">integer</span> <span class="hljs-title">type</span></span><br><span class="hljs-class">    <span class="hljs-title">integer</span> <span class="hljs-title">refcnt</span></span><br><span class="hljs-class">    <span class="hljs-title">integer</span> <span class="hljs-title">userid</span></span><br><span class="hljs-class">    <span class="hljs-title">integer</span> <span class="hljs-title">groupid</span></span><br><span class="hljs-class">    <span class="hljs-title">integer</span> <span class="hljs-title">mode</span></span><br><span class="hljs-class">    <span class="hljs-title">integer</span> <span class="hljs-title">atime</span></span><br><span class="hljs-class">    <span class="hljs-title">integer</span> <span class="hljs-title">mtime</span></span><br><span class="hljs-class">    <span class="hljs-title">integer</span> <span class="hljs-title">ctime</span></span><br></code></pre></td></tr></table></figure><p>open时的过程为：</p><ul><li>通过id和mode检查是否有打开的权限</li><li>更新atime</li><li>返回fd</li></ul><p>每个进程默认有三个fd，分别管理stdin(0), stdout(1), stderr(2)，fd还可以通知一些device，这是因为这些device本质都是文件</p><p>为什么使用fd而不是inode pointer？</p><ul><li>为了安全不让你了解kernel的数据结构，实现os和应用的隔离</li><li>同时让文件修改全权交给kernel，实现non-bypassability</li><li>对于同一个文件，不同的操作对应的fd不一样</li></ul><p>fd要求返回当前可用fd中最小的那个，而这就导致了当open过多时要加锁，导致性能下降</p><p>文件被打开时，file cursor默认指向0的位置，而read和write时，cursor向前移动，同时read和write也是从当前cursor开始的，使用<code>SEEK</code>来任意移动file cursor</p><p>sharing file cursor: 父进程将fd传给子进程，在写log时有用；not sharing file cursor: 两个进程打开同一个文件</p><p>使用fd_table和file_table维护file cursor（这些都是in memory的），其中file_table全局，而file_table里面的refcnt与inode里面的区分，而是表明有多少进程共享同一个index，而当refcnt &#x3D; 0时回收资源</p><img src="/2025/09/23/CSE-lecture3-File-System-2/c8230670407bcb77627aae41d91fc0ac.png" class="" title="fd_table &amp; file_table"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python">procedure OPEN(string filename, integer flags, integer mod) -&gt; integer<br>    inode_number &lt;- PATH_TO_INODE_NUMBER(filename, wd)<br>    <span class="hljs-keyword">if</span> inode_number = FAILURE <span class="hljs-keyword">and</span> flags = O_CREATE then     <span class="hljs-comment"># 创建文件？</span><br>        inode_number &lt;- CREATE(filename, mode)<br>    <span class="hljs-keyword">if</span> inode_number = FAILURE then<br>        <span class="hljs-keyword">return</span> FAILURE<br>    inode &lt;- INODE_NUMBER_TO_INODE(inode_number)<br>    <span class="hljs-keyword">if</span> PERMITTED(inode, flags) then                         <span class="hljs-comment"># 是否具备权限？</span><br>        file_index &lt;- INSERT(file_table, inode_number)<br>        fd &lt;- FIND_UNUSED_ENTRY(fd_table)                   <span class="hljs-comment"># 在fd_table寻找最小空闲fd</span><br>        fd_table[fd] &lt;- file_index                          <span class="hljs-comment"># 将fd和file index关联起来</span><br>        <span class="hljs-keyword">return</span> fd<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> FAILURE<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python">procedure READ(integer fd, character[] &amp;buf, integer n) -&gt; integer<br>    file_index &lt;- fd_table[fd]<br>    cursor &lt;- file_table[file_index].cursor<br>    inode &lt;- INODE_NUMBER_TO_INODE(file_table[file_index].inode_number)<br>    m &lt;- MINIMUM(inode.size - cursor, n)<br>    atime of inode &lt;- now()<br>    <span class="hljs-keyword">if</span> m = <span class="hljs-number">0</span> then <span class="hljs-keyword">return</span> END_OF_FILE<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">from</span> <span class="hljs-number">0</span> to m - <span class="hljs-number">1</span> do<br>        b &lt;- INODE_NUMBER_TO_BLOCK(cursor + i, inode_number)<br>        COPY(b, buf, MINIMUN(m - i, BLOCKSIZE))<br>        i &lt;- i + MINIMUM(m - i, BLOCKSIZE)<br>    file_table[file_index].cursor &lt;- cursor + m<br>    <span class="hljs-keyword">return</span> m<br></code></pre></td></tr></table></figure><p>每次<code>OPEN</code>, <code>READ</code>, <code>CREATION</code>时到底调用了多少次read和write？见以下两张图</p><img src="/2025/09/23/CSE-lecture3-File-System-2/3cf6e0694a37bc72f0029c1ca4bd0e68.png" class="" title="open &amp; read timeline"><p>每次READ时都要在inode里面write，很麻烦，因此添加参数<code>-no-atime</code>，并在close的时候再一并更新atime</p><img src="/2025/09/23/CSE-lecture3-File-System-2/6d38a963e25efe49cbd6d2831a2c03a1.png" class="" title="creation timeline"><p>注意在create到bar inode时要先read再write，这是因为write的粒度都是4KB，而inode只有1KB，因此只能先读上来4KB；而create最后foo inode因为先前已经read过了，所以就只用write了；像bar inode[0]就直接write了，因为直接write 4KB就行</p><p>以下三个写操作顺序，哪个最合理？检查什么时候断电，权衡后选择第一个，但也不完美</p><ul><li>update block bitmap, write new data, update inode(size and pointer): 1后断电，浪费一个block；2后断电，白写了data，还是浪费一个block</li><li>update block bitmap, update inode(size and pointer), write new data: 2后断电，等价于访问旧的数据，非常危险</li><li>update inode(size and pointer), update block bitmap, write new data: 1后断电，inode里面的pointer指向一个还没覆写的block，有可能读到旧的数据，非常危险</li></ul><p>SYNC将cache写入磁盘，避免断电时数据丢失</p><p>delete after open but before close: inode在close前不会回收即可</p><p>rename有一个更好的方案：</p><ol><li><code>LINK(from_name, to_name)</code>: 注意这里是to_name的inode num被修改成from_name的，然后refcnt变为2</li><li><code>UNLINK(from_name)</code>: refcnt变回1</li></ol><p>在1和2之间断电，至少保证了from_name和to_name指向同一个文件</p><h3 id="other-file-systems-not-inode"><a href="#other-file-systems-not-inode" class="headerlink" title="other file systems(not inode)"></a>other file systems(not inode)</h3><ul><li>方法1：使用连续的block存储文件</li><li>方法2：使用linked list，即FAT(file allcation table)：<img src="/2025/09/23/CSE-lecture3-File-System-2/a4dc455cd7c99c1613c5948ed6f6c6c4.png" class="" title="FAT"><ul><li>FAT为一个linked list，和block一一对应，这导致FAT的容错性差</li><li>file number为list起始位置得索引</li><li>将空的block视为一个大文件，对应一个free list</li><li>写入文件时，从free list中获取空闲的block，并将它们link起来</li><li>FAT的目录包含了file name, file number, next，因此也不支持硬链接，根目录在sector 0<img src="/2025/09/23/CSE-lecture3-File-System-2/2f79725c8cae374f6bddb0845b3dc3eb.png" class="" title="directory in FAT"></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机学习</category>
      
      <category>se专业课</category>
      
      <category>cse</category>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>se</tag>
      
      <tag>cse</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSE_lecture2:File System 1</title>
    <link href="/2025/09/21/CSE-lecture2-File-System-1/"/>
    <url>/2025/09/21/CSE-lecture2-File-System-1/</url>
    
    <content type="html"><![CDATA[<h2 id="From-single-to-distributed-inode-based-File-System"><a href="#From-single-to-distributed-inode-based-File-System" class="headerlink" title="From single to distributed: inode-based File System"></a>From single to distributed: inode-based File System</h2><p>使用不同的存储系统来对应不同的服务：scalable file system, scalable database, scalable key-value store，其中key-value store存放不必精确的数据，定期更新就行，而database用于精确存放准确的数据</p><img src="/2025/09/21/CSE-lecture2-File-System-1/f168499e6e2c216911f11ae3f177bf53.png" class="" title="架构"><h3 id="single-node-inode-based-filesystem"><a href="#single-node-inode-based-filesystem" class="headerlink" title="single-node inode-based filesystem"></a>single-node inode-based filesystem</h3><p>文件包含两个特性：durable, name</p><img src="/2025/09/21/CSE-lecture2-File-System-1/0f669c904929ad467e9ef39d73689358.png" class="" title="文件的实现"><p>disk driver的抽象：</p><ul><li>分为一个一个的sector（早期512B，现在为4KB），注意sector为磁盘扇区的概念，而block为操作系统的概念</li><li>API为read和write</li><li>需要进一步抽象成file system，如果是直接分配sector index，会出现难以寻找空闲sector，难以放大文件，难以命名，可用性和安全性都不足</li></ul><h3 id="inode-7-software-layers"><a href="#inode-7-software-layers" class="headerlink" title="inode: 7 software layers"></a>inode: 7 software layers</h3><h4 id="L1-block-layer"><a href="#L1-block-layer" class="headerlink" title="L1: block layer"></a>L1: block layer</h4><p>提供block id，得到4KB数据；或者提供block id和要写的数据，将其写入到对应的block，即实现block number-&gt;block data</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">procedure BLOCK_NUMBER_TO_BLOCK(integer b) -&gt; block<br>    <span class="hljs-keyword">return</span> devices[b]<br></code></pre></td></tr></table></figure><p>为什么使用block而非sector？因为file system的最小单位是block，而磁盘的最小单位是sector，只是恰好这俩大小一致罢了，而这是可以调整的</p><p>如何决定block size？权衡efficiency和utilization，以及内部的碎片</p><p>如何得知block size？使用磁盘开头的super block记录metadata，super block包含block size, num of free blocks, a list of free blocks, etc.</p><p>使用bitmap for free blocks记录哪些block被用过，哪些没有</p><img src="/2025/09/21/CSE-lecture2-File-System-1/95d6c1a886a13c3019898be5d3f29abb.png" class="" title="block layer"><h4 id="L2-file-layer"><a href="#L2-file-layer" class="headerlink" title="L2: file layer"></a>L2: file layer</h4><p>记录某一个文件使用了哪些block，即inode，包含block_nums[N]和size，size为精确值，从而保证了安全性（之前回收的文件不会清零），其中N可以不用太大，当文件过大时，使用indirect block解决，而当文件过小时，其实可以直接存在inode里面，并修改type</p><img src="/2025/09/21/CSE-lecture2-File-System-1/b11191fe13bc85fb45260278566f86d0.png" class="" title="indirect block"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">procedure INODE_TO_BLOCK(integer offset, inode i) -&gt; block<br>    o &lt;- offset / BLOCKSIZE<br>    b &lt;- INDEX_TO_BLOCK_NUMBER(i, o)<br>    <span class="hljs-keyword">return</span> BLOCK_NUMBER_TO_BLOCK(b)<br><br>procedure INDEX_TO_BLOCK_NUMBER(inode i, integer index) -&gt; integer<br>    <span class="hljs-keyword">return</span> i.block_nums[index]<br></code></pre></td></tr></table></figure><h4 id="L3-inode-number-layer"><a href="#L3-inode-number-layer" class="headerlink" title="L3: inode number layer"></a>L3: inode number layer</h4><p>实现inode num-&gt;inode，即inode table，是一个大数组</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">procedure INODE_NUMBER_TO_INODE(integer num) -&gt; inode<br>    <span class="hljs-keyword">return</span> inode_table[num]<br></code></pre></td></tr></table></figure><img src="/2025/09/21/CSE-lecture2-File-System-1/6af3e44202425edaa4ac21d28e617156.png" class="" title="inode table"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">procedure INODE_NUMBER_TO_BLOCK(integer offset, integer inode_number) -&gt; block<br>    inode i = INODE_NUMBER_TO_INODE(inode_number)<br>    o &lt;- offset / BLOCKSIZE<br>    b &lt;- INDEX_TO_BLOCK_NUMBER(i, o)<br>    <span class="hljs-keyword">return</span> BLOCK_NUMBER_TO_BLOCK(b)<br></code></pre></td></tr></table></figure><h4 id="L4-file-name-layer"><a href="#L4-file-name-layer" class="headerlink" title="L4: file name layer"></a>L4: file name layer</h4><p>实现file name和inode number的一一对应关系，存放在directory，而这个directory也抽象成file，存放在inode中，因此inode内部增加type来区分目录和普通文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python">procedure NAME_TO_INODE(string filename, integer <span class="hljs-built_in">dir</span>) -&gt; integer<br>    <span class="hljs-keyword">return</span> LOOKUP(<span class="hljs-built_in">dir</span>, filename)<br><br>procedure LOOKUP(string filename, integer <span class="hljs-built_in">dir</span>) -&gt; integer<br>    block b<br>    inode i = INODE_NUMBER_TO_INODE(<span class="hljs-built_in">dir</span>)<br>    <span class="hljs-keyword">if</span> i.<span class="hljs-built_in">type</span> != DIRECTORY then <span class="hljs-keyword">return</span> FAILURE<br>    <span class="hljs-keyword">for</span> offset <span class="hljs-keyword">from</span> <span class="hljs-number">0</span> to i.size - <span class="hljs-number">1</span> do<br>        b &lt;- INODE_NUMBER_TO_BLOCK(offset, <span class="hljs-built_in">dir</span>)<br>        <span class="hljs-keyword">if</span> STRING_MATCH(filename, b) then<br>            <span class="hljs-keyword">return</span> INODE_NUMBER(filename, b)<br>        offset &lt;- offset + BLOCKSIZE<br>    <span class="hljs-keyword">return</span> FAILURE<br></code></pre></td></tr></table></figure><h4 id="L5-path-name-layer"><a href="#L5-path-name-layer" class="headerlink" title="L5: path name layer"></a>L5: path name layer</h4><p>层次化的directory为path，直接层层递归即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">procedure PATH_TO_INODE_NUMBER(string path, integer <span class="hljs-built_in">dir</span>) -&gt; integer<br>    <span class="hljs-keyword">if</span> PLAIN_NAME(path) <span class="hljs-keyword">return</span> NAME_TO_INODE_NUMBER(path, <span class="hljs-built_in">dir</span>)<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-built_in">dir</span> &lt;- LOOKUP(FIRST(path), <span class="hljs-built_in">dir</span>)<br>        path &lt;- REST(path)<br>        <span class="hljs-keyword">return</span> PATH_TO_INODE_NUMBER(path, <span class="hljs-built_in">dir</span>)<br></code></pre></td></tr></table></figure><h5 id="Links"><a href="#Links" class="headerlink" title="Links"></a>Links</h5><p>link让不同的文件名指向相同的inode num，而unlink取消filename和inode num之间的联系，这是hard link，而hard link不能跨文件系统建立，否则会出现inode num冲突</p><p>在inode里面添加一项refcnt，link时+1，unlink时-1，当refcnt &#x3D; 0时才清除这个inode对应的file</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span></span><br><span class="hljs-class">    <span class="hljs-title">integer</span> <span class="hljs-title">block_nums</span>[<span class="hljs-title">N</span>]</span><br><span class="hljs-class">    <span class="hljs-title">integer</span> <span class="hljs-title">size</span></span><br><span class="hljs-class">    <span class="hljs-title">integer</span> <span class="hljs-title">type</span></span><br><span class="hljs-class">    <span class="hljs-title">integer</span> <span class="hljs-title">refcnt</span></span><br></code></pre></td></tr></table></figure><p>link不能构成环，否则会导致内存泄漏，因此规定目录不能link，除了两个例外：<code>.</code>和 <code>..</code>这两个hard link</p><img src="/2025/09/21/CSE-lecture2-File-System-1/3f524b6babd481f7da974ba72d96dc6e.png" class="" title="no cycle for link"><h5 id="renaming"><a href="#renaming" class="headerlink" title="renaming"></a>renaming</h5><p>编辑文件时会创建一个临时文件，重命名时，顺序为：</p><ol><li><code>UNLINK(to_name)</code></li><li><code>LINK(from_name, to_name)</code></li><li><code>UNLINK(from_name)</code></li></ol><p>但如果计算机在1和2之间突然断电呢？这会使得to_name丢失。因此要保证原子性操作</p><h4 id="L6-absolute-path-name-layer"><a href="#L6-absolute-path-name-layer" class="headerlink" title="L6: absolute path name layer"></a>L6: absolute path name layer</h4><p>引入根目录<code>/</code>，其中<code>/.</code>和<code>/..</code>依然是根目录</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">procedure GENERATEPATH_TO_INODE_NUMBER(string path) -&gt; integer<br>    <span class="hljs-keyword">if</span> path[<span class="hljs-number">0</span>] = <span class="hljs-string">&quot;/&quot;</span> <span class="hljs-keyword">return</span> PATH_TO_INODE_NUMBER(path, <span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> PATH_TO_INODE_NUMBER(path, wd)<br></code></pre></td></tr></table></figure><p>参考一个例子来理解file system layers，约定俗成root在inode table的第一个位置</p><img src="/2025/09/21/CSE-lecture2-File-System-1/b0743f32e0ad6521c0344a432de87d33.png" class="" title="an example"><img src="/2025/09/21/CSE-lecture2-File-System-1/44b20884d3907caa236f17a905ecf9b7.png" class="" title="dump a directory"><h4 id="L7-symbolic-link-layer"><a href="#L7-symbolic-link-layer" class="headerlink" title="L7: symbolic link layer"></a>L7: symbolic link layer</h4><img src="/2025/09/21/CSE-lecture2-File-System-1/d44dfec3bb652eb23a7c445b1c6bd7b1.png" class="" title="dump a symbolic link"><p>区分hard link和soft link：</p><ul><li>hard link强调两个filename都指向同一个inode num，而soft link强调一个filename指向另一个filename，当文件被删除时，hard link连接的文件能够正常访问，而soft link连接的文件会打不开（注意谁指向谁）</li><li>hard link不能跨文件系统建立，而soft link可以，甚至soft link可以指向不存在的文件，并同时新建一个inode</li></ul><p>inode中有一个新的名叫symbolic link的type，该文件打开时显示的是指向的文件名，需要再一次打开指向的文件名，正如图片中的8代表<code>/tmp/abc</code>长8个字节，这是因为<code>s-link</code>文件存放的就是<code>/tmp/abc</code>这个文件名（查看时使用<code>readlink</code>或者<code>ls -l</code>指令，而<code>cat</code>会直接读取到被链接文件的内容）</p><p>假设有<code>soft link: /CSE-web -&gt; /Scholarly/programs/www</code>，当我运行<code>cd CSE-web</code>后运行<code>cd ..</code>，是回到根目录，因为<code>..</code>被bash截获，记录old pwd，以实现human-friendly，如果不想通过逻辑路径而是通过物理路径，请使用<code>cd -P ..</code></p><p>总结以下几点：</p><ul><li>file name不是file的一部分，而inode可以通过hard link而拥有多个名字</li><li>hard link之间平等，没有先后顺序的区别</li><li>directory的大小很小，这是因为directory只存放映射关系，而不是包含了里面所有文件的大小，应当认为folder是一种错误的理解</li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机学习</category>
      
      <category>se专业课</category>
      
      <category>cse</category>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>se</tag>
      
      <tag>cse</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hot100整理之python版</title>
    <link href="/2025/09/14/hot100%E6%95%B4%E7%90%86%E4%B9%8Bpython%E7%89%88/"/>
    <url>/2025/09/14/hot100%E6%95%B4%E7%90%86%E4%B9%8Bpython%E7%89%88/</url>
    
    <content type="html"><![CDATA[<h2 id="hot100整理之python版"><a href="#hot100整理之python版" class="headerlink" title="hot100整理之python版"></a>hot100整理之python版</h2><h3 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h3><h4 id="最长连续序列"><a href="#最长连续序列" class="headerlink" title="最长连续序列"></a>最长连续序列</h4><blockquote><p>给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。<br>请你设计并实现时间复杂度为 O(n) 的算法解决此问题。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">longestConsecutive</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        res = <span class="hljs-number">0</span><br>        st = <span class="hljs-built_in">set</span>(nums)  <span class="hljs-comment"># 使用哈希集合，从而使查找为O(1)</span><br>        <span class="hljs-comment"># 这里不能遍历nums，否则会多次处理相等的元素</span><br>        <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> st:<br>            <span class="hljs-keyword">if</span> num - <span class="hljs-number">1</span> <span class="hljs-keyword">in</span> st:   <span class="hljs-comment"># 从最小的开始</span><br>                <span class="hljs-keyword">continue</span><br>            last = num + <span class="hljs-number">1</span><br>            <span class="hljs-keyword">while</span> last <span class="hljs-keyword">in</span> st:<br>                last = last + <span class="hljs-number">1</span><br>            res = <span class="hljs-built_in">max</span>(res, last - num)<br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><h3 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h3><h4 id="盛最多水的容器"><a href="#盛最多水的容器" class="headerlink" title="盛最多水的容器"></a>盛最多水的容器</h4><blockquote><p>给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。<br>找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。<br>返回容器可以储存的最大水量。<br>说明：你不能倾斜容器。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maxArea</span>(<span class="hljs-params">self, height: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        left, right = <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(height) - <span class="hljs-number">1</span><br>        res = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> left != right:<br>            h = <span class="hljs-built_in">min</span>(height[left], height[right])<br>            w = right - left<br>            res = <span class="hljs-built_in">max</span>(res, h * w)<br>            <span class="hljs-keyword">if</span> height[left] &lt; height[right]:<br>                left += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                right -= <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><h4 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a>三数之和</h4><blockquote><p>给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i !&#x3D; j、i !&#x3D; k 且 j !&#x3D; k ，同时还满足 nums[i] + nums[j] + nums[k] &#x3D;&#x3D; 0 。请你返回所有和为 0 且不重复的三元组。<br>注意：答案中不可以包含重复的三元组。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">threeSum</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:<br>        res = []<br>        nums.sort()<br>        <span class="hljs-keyword">for</span> i, num <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(nums):<br>            <span class="hljs-keyword">if</span> num &gt; <span class="hljs-number">0</span>: <span class="hljs-comment"># 剪枝</span><br>                <span class="hljs-keyword">break</span><br>            <span class="hljs-keyword">if</span> i &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> nums[i] == nums[i - <span class="hljs-number">1</span>]:    <span class="hljs-comment"># 去重</span><br>                <span class="hljs-keyword">continue</span><br>            <span class="hljs-comment"># 双指针收缩</span><br>            j = i + <span class="hljs-number">1</span><br>            k = <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span><br>            <span class="hljs-keyword">while</span> j &lt; k:<br>                <span class="hljs-built_in">sum</span> = nums[i] + nums[j] + nums[k]<br>                <span class="hljs-keyword">if</span> <span class="hljs-built_in">sum</span> &gt; <span class="hljs-number">0</span>:<br>                    k -= <span class="hljs-number">1</span><br>                <span class="hljs-keyword">elif</span> <span class="hljs-built_in">sum</span> &lt; <span class="hljs-number">0</span>:<br>                    j += <span class="hljs-number">1</span><br>                <span class="hljs-keyword">else</span>:<br>                    res.append([nums[i], nums[j], nums[k]])<br>                    <span class="hljs-comment"># 去重</span><br>                    <span class="hljs-keyword">while</span> j &lt; k <span class="hljs-keyword">and</span> nums[j] == nums[j + <span class="hljs-number">1</span>]:<br>                        j += <span class="hljs-number">1</span><br>                    <span class="hljs-keyword">while</span> j &lt; k <span class="hljs-keyword">and</span> nums[k] == nums[k - <span class="hljs-number">1</span>]:<br>                        k -= <span class="hljs-number">1</span><br>                    j += <span class="hljs-number">1</span><br>                    k -= <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> res<br><br></code></pre></td></tr></table></figure><h4 id="接雨水"><a href="#接雨水" class="headerlink" title="接雨水"></a>接雨水</h4><blockquote><p>给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">trap</span>(<span class="hljs-params">self, height: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        n = <span class="hljs-built_in">len</span>(height)<br>        <span class="hljs-keyword">if</span> n &lt;= <span class="hljs-number">2</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        <span class="hljs-comment"># 使用单调栈记录索引，从栈顶到栈底单调递增，从而找到凹槽</span><br>        stack = []<br>        stack.append(<span class="hljs-number">0</span>)<br>        res = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n):<br>            top = stack[-<span class="hljs-number">1</span>]<br>            <span class="hljs-keyword">while</span> stack <span class="hljs-keyword">and</span> height[top] &lt; height[i]:<br>                mid = stack.pop()<br>                <span class="hljs-keyword">if</span> stack:<br>                    left = stack[-<span class="hljs-number">1</span>]<br>                    h = <span class="hljs-built_in">min</span>(height[left], height[i]) - height[mid]<br>                    w = i - left - <span class="hljs-number">1</span><br>                    res += h * w<br>                    top = stack[-<span class="hljs-number">1</span>]<br>            stack.append(i)<br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><h4 id="无重复字符的最长子串"><a href="#无重复字符的最长子串" class="headerlink" title="无重复字符的最长子串"></a>无重复字符的最长子串</h4><blockquote><p>给定一个字符串 s ，请你找出其中不含有重复字符的 最长 子串 的长度。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">lengthOfLongestSubstring</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        slow = fast = <span class="hljs-number">0</span><br>        st = <span class="hljs-built_in">set</span>()<br>        res = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> fast != <span class="hljs-built_in">len</span>(s):<br>            <span class="hljs-keyword">if</span> s[fast] <span class="hljs-keyword">in</span> st:<br>                <span class="hljs-comment"># 出现重复元素，将重复元素及其之前的元素全部清除</span><br>                <span class="hljs-keyword">while</span> s[slow] != s[fast]:<br>                    st.remove(s[slow])<br>                    slow += <span class="hljs-number">1</span><br>                slow += <span class="hljs-number">1</span>   <span class="hljs-comment"># 移动到重复元素的下一位</span><br>                fast += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                st.add(s[fast])<br>                fast += <span class="hljs-number">1</span><br>            res = <span class="hljs-built_in">max</span>(res, fast - slow)<br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><h4 id="找到字符串中所有字母异位词"><a href="#找到字符串中所有字母异位词" class="headerlink" title="找到字符串中所有字母异位词"></a>找到字符串中所有字母异位词</h4><blockquote><p>给定两个字符串 s 和 p，找到 s 中所有 p 的 异位词 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">findAnagrams</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span>, p: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>        counter = Counter(p)    <span class="hljs-comment"># 统计p中元素出现的频率</span><br>        res = []<br>        left = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> right, c <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(s):<br>            counter[c] -= <span class="hljs-number">1</span> <span class="hljs-comment"># s中出现就减一，减到零说明找到</span><br>            <span class="hljs-keyword">while</span> counter[c] &lt; <span class="hljs-number">0</span>:   <span class="hljs-comment"># c出现过多</span><br>                counter[s[left]] += <span class="hljs-number">1</span><br>                left += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> right - left + <span class="hljs-number">1</span> == <span class="hljs-built_in">len</span>(p):  <span class="hljs-comment"># 没有超出的了，说明s子串与p构成异位词</span><br>                res.append(left)<br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><h3 id="子串"><a href="#子串" class="headerlink" title="子串"></a>子串</h3><h4 id="和为-K-的子数组"><a href="#和为-K-的子数组" class="headerlink" title="和为 K 的子数组"></a>和为 K 的子数组</h4><blockquote><p>给你一个整数数组 nums 和一个整数 k ，请你统计并返回 该数组中和为 k 的子数组的个数 。<br>子数组是数组中元素的连续非空序列。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">subarraySum</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-comment"># 哈希表键为前缀和，值为该前缀和的个数，遍历查找s[j] - s[i] = k，即统计有多少以j结尾的子数组</span><br>        res = <span class="hljs-built_in">sum</span> = <span class="hljs-number">0</span><br>        cnt = defaultdict(<span class="hljs-built_in">int</span>)<br>        cnt[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> nums:<br>            <span class="hljs-built_in">sum</span> += num  <span class="hljs-comment"># 统计当前前缀和，即s[j]</span><br>            res += cnt[<span class="hljs-built_in">sum</span> - k] <span class="hljs-comment"># 寻找所有的s[i]</span><br>            cnt[<span class="hljs-built_in">sum</span>] += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><h4 id="滑动窗口最大值"><a href="#滑动窗口最大值" class="headerlink" title="滑动窗口最大值"></a>滑动窗口最大值</h4><blockquote><p>给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。<br>返回 滑动窗口中的最大值 。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maxSlidingWindow</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>        <span class="hljs-comment"># 使用单调队列，队列单调递减，从而保证队首为最大值</span><br>        <span class="hljs-comment"># 同时在其后面出现的次大值不会消亡，而其前面比最大值小的会消亡</span><br>        <span class="hljs-comment"># 考虑到滑动窗口右移，左边消亡的值没有留下的意义</span><br>        res = [<span class="hljs-number">0</span>] * (<span class="hljs-built_in">len</span>(nums) - k + <span class="hljs-number">1</span>)<br>        q = deque()<br><br>        <span class="hljs-keyword">for</span> i, num <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(nums):<br>            <span class="hljs-keyword">while</span> q <span class="hljs-keyword">and</span> nums[q[-<span class="hljs-number">1</span>]] &lt;= num: <span class="hljs-comment"># 相等也要移除，因为前面的离开了而最大值不变</span><br>                q.pop() <span class="hljs-comment"># 维护单调性</span><br>            q.append(i)<br>            <br>            left = i - k + <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> q[<span class="hljs-number">0</span>] &lt; left: <span class="hljs-comment"># 队首离开窗口</span><br>                q.popleft()<br>            <br>            <span class="hljs-keyword">if</span> left &gt;= <span class="hljs-number">0</span>:<br>                res[left] = nums[q[<span class="hljs-number">0</span>]]<br>        <br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><h4 id="最小覆盖子串"><a href="#最小覆盖子串" class="headerlink" title="最小覆盖子串"></a>最小覆盖子串</h4><blockquote><p>给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 “” 。<br>注意：<br>对于 t 中重复字符，我们寻找的子字符串中该字符数量必须不少于 t 中该字符数量。<br>如果 s 中存在这样的子串，我们保证它是唯一的答案。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minWindow</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span>, t: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">str</span>:<br>        cnt = defaultdict(<span class="hljs-built_in">int</span>)<br>        <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> t:<br>            cnt[c] += <span class="hljs-number">1</span><br>        less = <span class="hljs-built_in">len</span>(cnt)  <span class="hljs-comment"># 记录子串中有多少字母出现次数达不到t中的出现次数</span><br><br>        resLeft, resRight = -<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(s)<br>        left = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> right, c <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(s):<br>            cnt[c] -= <span class="hljs-number">1</span> <span class="hljs-comment"># 右端点进入子串</span><br>            <span class="hljs-keyword">if</span> cnt[c] == <span class="hljs-number">0</span>:<br>                less -= <span class="hljs-number">1</span>   <span class="hljs-comment"># 达到了</span><br>            <span class="hljs-keyword">while</span> less == <span class="hljs-number">0</span>:    <span class="hljs-comment"># 已全部达到，进一步缩小</span><br>                <span class="hljs-keyword">if</span> right - left &lt; resRight - resLeft:<br>                    resLeft, resRight = left, right<br>                x = s[left]<br>                <span class="hljs-keyword">if</span> cnt[x] == <span class="hljs-number">0</span>:<br>                    less += <span class="hljs-number">1</span><br>                cnt[x] += <span class="hljs-number">1</span> <span class="hljs-comment"># 左端点移出子串</span><br>                left += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span> <span class="hljs-keyword">if</span> resLeft &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> s[resLeft : resRight + <span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><h3 id="普通数组"><a href="#普通数组" class="headerlink" title="普通数组"></a>普通数组</h3><h4 id="轮转数组"><a href="#轮转数组" class="headerlink" title="轮转数组"></a>轮转数组</h4><blockquote><p>给定一个整数数组 nums，将数组中的元素向右轮转 k 个位置，其中 k 是非负数。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">rotate</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-literal">None</span>:<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        Do not return anything, modify nums in-place instead.</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment"># 反转三次即可</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">reverse</span>(<span class="hljs-params">start: <span class="hljs-built_in">int</span>, end: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">while</span> start &lt; end:<br>                nums[start], nums[end] = nums[end], nums[start]<br>                start += <span class="hljs-number">1</span><br>                end -= <span class="hljs-number">1</span><br><br>        k %= <span class="hljs-built_in">len</span>(nums)  <span class="hljs-comment"># 否则会溢出</span><br>        reverse(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span>)<br>        reverse(<span class="hljs-number">0</span>, k - <span class="hljs-number">1</span>)<br>        reverse(k, <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><h4 id="除自身以外数组的乘积"><a href="#除自身以外数组的乘积" class="headerlink" title="除自身以外数组的乘积"></a>除自身以外数组的乘积</h4><blockquote><p>给你一个整数数组 nums，返回 数组 answer ，其中 answer[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积 。<br>题目数据 保证 数组 nums之中任意元素的全部前缀元素和后缀的乘积都在  32 位 整数范围内。<br>请 不要使用除法，且在 O(n) 时间复杂度内完成此题。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">productExceptSelf</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>        res = [<span class="hljs-number">1</span>] * <span class="hljs-built_in">len</span>(nums)<br>        <span class="hljs-comment"># 先计算后面数字的乘积</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">2</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br>            res[i] = res[i + <span class="hljs-number">1</span>] * nums[i + <span class="hljs-number">1</span>]<br>        <span class="hljs-comment"># 再乘上前面数字的乘积</span><br>        pre = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> i, x <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(nums):<br>            res[i] *= pre<br>            pre *= x<br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><h4 id="缺失的第一个正数"><a href="#缺失的第一个正数" class="headerlink" title="缺失的第一个正数"></a>缺失的第一个正数</h4><blockquote><p>给你一个未排序的整数数组 nums ，请你找出其中没有出现的最小的正整数。<br>请你实现时间复杂度为 O(n) 并且只使用常数级别额外空间的解决方案。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">firstMissingPositive</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-comment"># 通过交换位置，使得数字1在下标0处，数字2在下标1处，以此类推</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(nums)):<br>            <span class="hljs-comment"># 使用while，保证最后nums[i] = i + 1</span><br>            <span class="hljs-keyword">while</span> <span class="hljs-number">1</span> &lt;= nums[i] &lt;= <span class="hljs-built_in">len</span>(nums) <span class="hljs-keyword">and</span> nums[i] != nums[nums[i] - <span class="hljs-number">1</span>]:   <span class="hljs-comment"># 不使用nums[i] = i + 1，防止落入死循环</span><br>                j = nums[i] - <span class="hljs-number">1</span><br>                nums[i], nums[j] = nums[j], nums[i]<br>        <span class="hljs-comment"># 从小到大检查哪个正数缺失</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums)):<br>            <span class="hljs-keyword">if</span> nums[i] != i + <span class="hljs-number">1</span>:<br>                <span class="hljs-keyword">return</span> i + <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(nums) + <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h3 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h3><h4 id="矩阵置零"><a href="#矩阵置零" class="headerlink" title="矩阵置零"></a>矩阵置零</h4><blockquote><p>给定一个 m x n 的矩阵，如果一个元素为 0 ，则将其所在行和列的所有元素都设为 0 。请使用 原地 算法。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">setZeroes</span>(<span class="hljs-params">self, matrix: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-literal">None</span>:<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        Do not return anything, modify matrix in-place instead.</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        m, n = <span class="hljs-built_in">len</span>(matrix), <span class="hljs-built_in">len</span>(matrix[<span class="hljs-number">0</span>])<br>        col0 = <span class="hljs-built_in">any</span>(matrix[i][<span class="hljs-number">0</span>] == <span class="hljs-number">0</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m))<br>        row0 = <span class="hljs-built_in">any</span>(matrix[<span class="hljs-number">0</span>][j] == <span class="hljs-number">0</span> <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n))<br><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, m):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n):<br>                <span class="hljs-keyword">if</span> matrix[i][j] == <span class="hljs-number">0</span>:<br>                    matrix[i][<span class="hljs-number">0</span>] = matrix[<span class="hljs-number">0</span>][j] = <span class="hljs-number">0</span><br>        <br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, m):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n):<br>                <span class="hljs-keyword">if</span> matrix[i][<span class="hljs-number">0</span>] == <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> matrix[<span class="hljs-number">0</span>][j] == <span class="hljs-number">0</span>:<br>                    matrix[i][j] = <span class="hljs-number">0</span><br>        <br>        <span class="hljs-keyword">if</span> col0:<br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>                matrix[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span><br>        <br>        <span class="hljs-keyword">if</span> row0:<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>                matrix[<span class="hljs-number">0</span>][j] = <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h4 id="旋转图像"><a href="#旋转图像" class="headerlink" title="旋转图像"></a>旋转图像</h4><blockquote><p>给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。<br>你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">rotate</span>(<span class="hljs-params">self, matrix: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-literal">None</span>:<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        Do not return anything, modify matrix in-place instead.</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment"># 一次转置和一次行翻转</span><br>        m, n = <span class="hljs-built_in">len</span>(matrix), <span class="hljs-built_in">len</span>(matrix[<span class="hljs-number">0</span>])<br>        <span class="hljs-comment"># 转置</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i):<br>                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]<br>        <span class="hljs-comment"># 行翻转</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n // <span class="hljs-number">2</span>):<br>                matrix[i][j], matrix[i][n - <span class="hljs-number">1</span> - j] = matrix[i][n - <span class="hljs-number">1</span> - j], matrix[i][j]<br></code></pre></td></tr></table></figure><h4 id="搜索二维矩阵-II"><a href="#搜索二维矩阵-II" class="headerlink" title="搜索二维矩阵 II"></a>搜索二维矩阵 II</h4><blockquote><p>编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target 。该矩阵具有以下特性：<br>每行的元素从左到右升序排列。<br>每列的元素从上到下升序排列。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">searchMatrix</span>(<span class="hljs-params">self, matrix: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]], target: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        <span class="hljs-comment"># 使用右上角判断，以排除一定比目标值大或者一定比目标值小的部分</span><br>        i, j = <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(matrix[<span class="hljs-number">0</span>]) - <span class="hljs-number">1</span><br>        <span class="hljs-keyword">while</span> i &lt; <span class="hljs-built_in">len</span>(matrix) <span class="hljs-keyword">and</span> j &gt;= <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">if</span> matrix[i][j] == target:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>            <span class="hljs-keyword">elif</span> matrix[i][j] &gt; target:<br>                j -= <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                i += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><h3 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h3><h4 id="岛屿数量"><a href="#岛屿数量" class="headerlink" title="岛屿数量"></a>岛屿数量</h4><blockquote><p>给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。<br>岛屿总是被水包围，并且每座岛屿只能由水平方向和&#x2F;或竖直方向上相邻的陆地连接形成。<br>此外，你可以假设该网格的四条边均被水包围。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">numIslands</span>(<span class="hljs-params">self, grid: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        m, n = <span class="hljs-built_in">len</span>(grid), <span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>])<br>        <span class="hljs-comment"># 使用dfs遍历岛屿的每一块</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">i: <span class="hljs-built_in">int</span>, j: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">if</span>(i &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> i &gt;= m <span class="hljs-keyword">or</span> j &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> j &gt;= n <span class="hljs-keyword">or</span> grid[i][j] != <span class="hljs-string">&#x27;1&#x27;</span>):<br>                <span class="hljs-keyword">return</span><br>            grid[i][j] = <span class="hljs-string">&#x27;2&#x27;</span>    <span class="hljs-comment"># 2表示已经访问</span><br>            dfs(i, j - <span class="hljs-number">1</span>)<br>            dfs(i, j + <span class="hljs-number">1</span>)<br>            dfs(i - <span class="hljs-number">1</span>, j)<br>            dfs(i + <span class="hljs-number">1</span>, j)<br>        <br>        res = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>                <span class="hljs-keyword">if</span> grid[i][j] == <span class="hljs-string">&#x27;1&#x27;</span>:<br>                    dfs(i, j)<br>                    res += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><h4 id="腐烂的橘子"><a href="#腐烂的橘子" class="headerlink" title="腐烂的橘子"></a>腐烂的橘子</h4><blockquote><p>在给定的 m x n 网格 grid 中，每个单元格可以有以下三个值之一：<br>值 0 代表空单元格；<br>值 1 代表新鲜橘子；<br>值 2 代表腐烂的橘子。<br>每分钟，腐烂的橘子 周围 4 个方向上相邻 的新鲜橘子都会腐烂。<br>返回 直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 -1 。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">orangesRotting</span>(<span class="hljs-params">self, grid: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-comment"># bfs，使用队列记录新的腐烂的橘子</span><br>        fresh = <span class="hljs-number">0</span>   <span class="hljs-comment"># 记录是否将所有橘子腐烂</span><br>        res = <span class="hljs-number">0</span><br>        m, n = <span class="hljs-built_in">len</span>(grid), <span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>])<br>        q = []<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>                <span class="hljs-keyword">if</span> grid[i][j] == <span class="hljs-number">1</span>:<br>                    fresh += <span class="hljs-number">1</span><br>                <span class="hljs-keyword">elif</span> grid[i][j] == <span class="hljs-number">2</span>:<br>                    q.append((i, j))<br>        <span class="hljs-keyword">while</span> q <span class="hljs-keyword">and</span> fresh:<br>            res += <span class="hljs-number">1</span><br>            tmp = q<br>            q = []<br>            <span class="hljs-keyword">for</span> i, j <span class="hljs-keyword">in</span> tmp:<br>                <span class="hljs-keyword">for</span> x, y <span class="hljs-keyword">in</span> (i - <span class="hljs-number">1</span>, j), (i + <span class="hljs-number">1</span>, j), (i, j - <span class="hljs-number">1</span>), (i, j + <span class="hljs-number">1</span>):<br>                    <span class="hljs-keyword">if</span> <span class="hljs-number">0</span> &lt;= x &lt; m <span class="hljs-keyword">and</span> <span class="hljs-number">0</span> &lt;= y &lt; n <span class="hljs-keyword">and</span> grid[x][y] == <span class="hljs-number">1</span>:<br>                        grid[x][y] = <span class="hljs-number">2</span><br>                        fresh -= <span class="hljs-number">1</span><br>                        q.append((x, y))<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span> <span class="hljs-keyword">if</span> fresh != <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> res<br></code></pre></td></tr></table></figure><h4 id="课程表"><a href="#课程表" class="headerlink" title="课程表"></a>课程表</h4><blockquote><p>你这个学期必须选修 numCourses 门课程，记为 0 到 numCourses - 1 。<br>在选修某些课程之前需要一些先修课程。 先修课程按数组 prerequisites 给出，其中 prerequisites[i] &#x3D; [ai, bi] ，表示如果要学习课程 ai 则 必须 先学习课程  bi 。<br>例如，先修课程对 [0, 1] 表示：想要学习课程 0 ，你需要先完成课程 1 。<br>请你判断是否可能完成所有课程的学习？如果可以，返回 true ；否则，返回 false 。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">canFinish</span>(<span class="hljs-params">self, numCourses: <span class="hljs-built_in">int</span>, prerequisites: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        <span class="hljs-comment"># 三色标记法，0表示未访问，1表示正在访问，2表示已经访问</span><br>        graph = [[] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(numCourses)]<br>        <span class="hljs-keyword">for</span> a, b <span class="hljs-keyword">in</span> prerequisites:<br>            graph[b].append(a)  <span class="hljs-comment"># 使用链表表示该图</span><br>        <br>        colors = [<span class="hljs-number">0</span>] * numCourses<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">course : <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">bool</span>:<br>            colors[course] = <span class="hljs-number">1</span>  <span class="hljs-comment"># 正在访问</span><br>            <span class="hljs-keyword">for</span> nxt <span class="hljs-keyword">in</span> graph[course]:<br>                <span class="hljs-comment"># 正在访问，或者未访问的在深度搜索后出现了环</span><br>                <span class="hljs-keyword">if</span> colors[nxt] == <span class="hljs-number">1</span> <span class="hljs-keyword">or</span> colors[nxt] == <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> dfs(nxt):<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>            colors[course] = <span class="hljs-number">2</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        <br>        <span class="hljs-keyword">for</span> course <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(numCourses):<br>            <span class="hljs-keyword">if</span> colors[course] == <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> dfs(course): <span class="hljs-comment"># 有环</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><h4 id="实现-Trie-前缀树"><a href="#实现-Trie-前缀树" class="headerlink" title="实现 Trie (前缀树)"></a>实现 Trie (前缀树)</h4><blockquote><p>Trie（发音类似 “try”）或者说 前缀树 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补全和拼写检查。<br>请你实现 Trie 类：<br>Trie() 初始化前缀树对象。<br>void insert(String word) 向前缀树中插入字符串 word 。<br>boolean search(String word) 如果字符串 word 在前缀树中，返回 true（即，在检索之前已经插入）；否则，返回 false 。<br>boolean startsWith(String prefix) 如果之前已经插入的字符串 word 的前缀之一为 prefix ，返回 true ；否则，返回 false 。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-variable language_">self</span>.son = &#123;&#125;<br>        <span class="hljs-variable language_">self</span>.end = <span class="hljs-literal">False</span>    <span class="hljs-comment"># 以这个节点为结尾，组成的前缀是否构成插入的字符串</span><br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Trie</span>:<br>    <span class="hljs-comment"># 即26叉树</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-variable language_">self</span>.root = Node()<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">insert</span>(<span class="hljs-params">self, word: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-literal">None</span>:<br>        cur = <span class="hljs-variable language_">self</span>.root<br>        <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> word:<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> c <span class="hljs-keyword">in</span> cur.son:<br>                cur.son[c] = Node()<br>            cur = cur.son[c]<br>        cur.end = <span class="hljs-literal">True</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">search</span>(<span class="hljs-params">self, word: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span> <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.find(word) == <span class="hljs-number">2</span> <span class="hljs-keyword">else</span> <span class="hljs-literal">False</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">startsWith</span>(<span class="hljs-params">self, prefix: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span> <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.find(prefix) <span class="hljs-keyword">else</span> <span class="hljs-literal">False</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">find</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-comment"># 0表示未找到，1表示只找到前缀，2表示找到完整的字符串</span><br>        cur = <span class="hljs-variable language_">self</span>.root<br>        <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> s:<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> c <span class="hljs-keyword">in</span> cur.son:<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>            cur = cur.son[c]<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> <span class="hljs-keyword">if</span> cur.end <span class="hljs-keyword">else</span> <span class="hljs-number">1</span><br>        <br><br><br><span class="hljs-comment"># Your Trie object will be instantiated and called as such:</span><br><span class="hljs-comment"># obj = Trie()</span><br><span class="hljs-comment"># obj.insert(word)</span><br><span class="hljs-comment"># param_2 = obj.search(word)</span><br><span class="hljs-comment"># param_3 = obj.startsWith(prefix)</span><br></code></pre></td></tr></table></figure><h3 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h3><h4 id="电话号码的字母组合"><a href="#电话号码的字母组合" class="headerlink" title="电话号码的字母组合"></a>电话号码的字母组合</h4><blockquote><p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。<br>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">letterCombinations</span>(<span class="hljs-params">self, digits: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]:<br>        numString = [<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-string">&quot;def&quot;</span>, <span class="hljs-string">&quot;ghi&quot;</span>, <span class="hljs-string">&quot;jkl&quot;</span>, <span class="hljs-string">&quot;mno&quot;</span>, <span class="hljs-string">&quot;pqrs&quot;</span>, <span class="hljs-string">&quot;tuv&quot;</span>, <span class="hljs-string">&quot;wxyz&quot;</span>]<br>        res = []<br>        path = []<br><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">backtracking</span>(<span class="hljs-params">index: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(path) == <span class="hljs-built_in">len</span>(digits):<br>                res.append(<span class="hljs-string">&quot;&quot;</span>.join(path[:]))<br>                <span class="hljs-keyword">return</span><br>            <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> numString[<span class="hljs-built_in">int</span>(digits[index])]:<br>                path.append(c)<br>                backtracking(index + <span class="hljs-number">1</span>)<br>                path.pop()<br>        <br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> digits <span class="hljs-keyword">or</span> <span class="hljs-built_in">len</span>(digits) == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> res<br>        backtracking(<span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><h4 id="括号生成"><a href="#括号生成" class="headerlink" title="括号生成"></a>括号生成</h4><blockquote><p>数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">generateParenthesis</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]:<br>        res = []<br>        path = []   <span class="hljs-comment"># path记录左括号的索引</span><br><br>        <span class="hljs-comment"># 使用balance记录左括号数与右括号数之差，index则为上一个左括号的索引</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">backtracking</span>(<span class="hljs-params">index: <span class="hljs-built_in">int</span>, balance: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(path) == n:<br>                ans = [<span class="hljs-string">&#x27;)&#x27;</span>] * <span class="hljs-number">2</span> * n<br>                <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> path:<br>                    ans[i] = <span class="hljs-string">&#x27;(&#x27;</span><br>                res.append(<span class="hljs-string">&#x27;&#x27;</span>.join(ans))<br>                <span class="hljs-keyword">return</span><br>            <span class="hljs-comment"># 每次加入b个右括号，再加入一个左括号</span><br>            <span class="hljs-keyword">for</span> b <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(balance + <span class="hljs-number">1</span>):<br>                path.append(index + b + <span class="hljs-number">1</span>)<br>                backtracking(index + b + <span class="hljs-number">1</span>, balance - b + <span class="hljs-number">1</span>)<br>                path.pop()<br><br>        backtracking(-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><h4 id="单词搜索"><a href="#单词搜索" class="headerlink" title="单词搜索"></a>单词搜索</h4><blockquote><p>给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。<br>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">exist</span>(<span class="hljs-params">self, board: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]], word: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        m, n = <span class="hljs-built_in">len</span>(board), <span class="hljs-built_in">len</span>(board[<span class="hljs-number">0</span>])<br><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">backtracking</span>(<span class="hljs-params">i: <span class="hljs-built_in">int</span>, j: <span class="hljs-built_in">int</span>, index: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">bool</span>:<br>            <span class="hljs-keyword">if</span> board[i][j] != word[index]:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>            <br>            <span class="hljs-keyword">if</span> index == <span class="hljs-built_in">len</span>(word) - <span class="hljs-number">1</span>:  <span class="hljs-comment"># 减一是因为刚刚已判断出最后一位匹配</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>            <br>            board[i][j] = <span class="hljs-string">&#x27;0&#x27;</span>   <span class="hljs-comment"># 标记为已经访问</span><br>            <br>            <span class="hljs-keyword">for</span> x, y <span class="hljs-keyword">in</span> (i, j - <span class="hljs-number">1</span>), (i, j + <span class="hljs-number">1</span>), (i - <span class="hljs-number">1</span>, j), (i + <span class="hljs-number">1</span>, j):<br>                <span class="hljs-keyword">if</span> <span class="hljs-number">0</span> &lt;= x &lt; m <span class="hljs-keyword">and</span> <span class="hljs-number">0</span> &lt;= y &lt; n <span class="hljs-keyword">and</span> backtracking(x, y, index + <span class="hljs-number">1</span>):<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>            <br>            board[i][j] = word[index]   <span class="hljs-comment"># 回溯</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>                <span class="hljs-keyword">if</span> backtracking(i, j, <span class="hljs-number">0</span>):<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><h4 id="分割回文串"><a href="#分割回文串" class="headerlink" title="分割回文串"></a>分割回文串</h4><blockquote><p>给你一个字符串 s，请你将 s 分割成一些 子串，使每个子串都是 回文串 。返回 s 所有可能的分割方案。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">partition</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]]:<br>        res = []<br>        path = []<br><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">check</span>(<span class="hljs-params">prefix: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">bool</span>:<br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(prefix) // <span class="hljs-number">2</span>):<br>                <span class="hljs-keyword">if</span> prefix[i] != prefix[<span class="hljs-built_in">len</span>(prefix) - i - <span class="hljs-number">1</span>]:<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">backtracking</span>(<span class="hljs-params">index: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">if</span> index == <span class="hljs-built_in">len</span>(s):<br>                res.append(path[:])<br>                <span class="hljs-keyword">return</span><br><br>            prefix = []<br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(index, <span class="hljs-built_in">len</span>(s)):<br>                <span class="hljs-comment"># 构造以index开始，i结束的回文</span><br>                prefix.append(s[i])<br>                <span class="hljs-keyword">if</span> check(prefix):<br>                    path.append(<span class="hljs-string">&#x27;&#x27;</span>.join(prefix))<br>                    backtracking(i + <span class="hljs-number">1</span>)<br>                    path.pop()<br>        <br>        backtracking(<span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><h4 id="N皇后"><a href="#N皇后" class="headerlink" title="N皇后"></a>N皇后</h4><blockquote><p>按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。<br>n 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。<br>给你一个整数 n ，返回所有不同的 n 皇后问题 的解决方案。<br>每一种解法包含一个不同的 n 皇后问题 的棋子放置方案，该方案中 ‘Q’ 和 ‘.’ 分别代表了皇后和空位。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">solveNQueens</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]]:<br>        res = []<br>        board = [-<span class="hljs-number">1</span>] * n <span class="hljs-comment"># 记录皇后在每一行的第几列</span><br>        <span class="hljs-comment"># 都是从上到下的顺序</span><br>        usedCol = [<span class="hljs-literal">False</span>] * n<br>        used45 = [<span class="hljs-literal">False</span>] * (<span class="hljs-number">2</span> * n - <span class="hljs-number">1</span>)<br>        used135 = [<span class="hljs-literal">False</span>] * (<span class="hljs-number">2</span> * n - <span class="hljs-number">1</span>)<br><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">backtracking</span>(<span class="hljs-params">row: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">if</span> row == n:<br>                path = []<br>                <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>                    s = [<span class="hljs-string">&#x27;.&#x27;</span>] * n<br>                    s[board[i]] = <span class="hljs-string">&#x27;Q&#x27;</span><br>                    path.append(<span class="hljs-string">&#x27;&#x27;</span>.join(s))<br>                res.append(path[:])<br>            <br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>                <span class="hljs-keyword">if</span> usedCol[i] <span class="hljs-keyword">or</span> used45[i + row] <span class="hljs-keyword">or</span> used135[n - <span class="hljs-number">1</span> + row - i]:<br>                    <span class="hljs-keyword">continue</span><br>                board[row] = i<br>                usedCol[i] = <span class="hljs-literal">True</span><br>                used45[i + row] = <span class="hljs-literal">True</span><br>                used135[n - <span class="hljs-number">1</span> + row - i] = <span class="hljs-literal">True</span><br>                backtracking(row + <span class="hljs-number">1</span>)<br>                used135[n - <span class="hljs-number">1</span> + row - i] = <span class="hljs-literal">False</span><br>                used45[i + row] = <span class="hljs-literal">False</span><br>                usedCol[i] = <span class="hljs-literal">False</span><br>            <br>        backtracking(<span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><h4 id="最小栈"><a href="#最小栈" class="headerlink" title="最小栈"></a>最小栈</h4><blockquote><p>设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。<br>实现 MinStack 类:<br>MinStack() 初始化堆栈对象。<br>void push(int val) 将元素val推入堆栈。<br>void pop() 删除堆栈顶部的元素。<br>int top() 获取堆栈顶部的元素。<br>int getMin() 获取堆栈中的最小元素。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MinStack</span>:<br>    <span class="hljs-comment"># 栈中元素配对，前者为当前元素，后者为前缀最小值</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-variable language_">self</span>.stack = [(<span class="hljs-number">0</span>, inf)] <span class="hljs-comment"># 放一个哨兵，从而不必检查栈空</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">push</span>(<span class="hljs-params">self, val: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-literal">None</span>:<br>        <span class="hljs-variable language_">self</span>.stack.append((val, <span class="hljs-built_in">min</span>(val, <span class="hljs-variable language_">self</span>.getMin())))<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">pop</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-literal">None</span>:<br>        <span class="hljs-variable language_">self</span>.stack.pop()<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">top</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.stack[-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">getMin</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.stack[-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]<br><br><br><span class="hljs-comment"># Your MinStack object will be instantiated and called as such:</span><br><span class="hljs-comment"># obj = MinStack()</span><br><span class="hljs-comment"># obj.push(val)</span><br><span class="hljs-comment"># obj.pop()</span><br><span class="hljs-comment"># param_3 = obj.top()</span><br><span class="hljs-comment"># param_4 = obj.getMin()</span><br></code></pre></td></tr></table></figure><h4 id="字符串解码"><a href="#字符串解码" class="headerlink" title="字符串解码"></a>字符串解码</h4><blockquote><p>给定一个经过编码的字符串，返回它解码后的字符串。<br>编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。<br>你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。<br>此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。<br>测试用例保证输出的长度不会超过 105。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">decodeString</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">str</span>:<br>        <span class="hljs-comment"># 认为每出现一组[]陷入一次递归，使用栈来模拟</span><br>        res = <span class="hljs-string">&quot;&quot;</span><br>        k = <span class="hljs-number">0</span>   <span class="hljs-comment"># 记录[]前的那个数字</span><br>        stack = []<br>        <br>        <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> s:<br>            <span class="hljs-keyword">if</span> c.isalpha():<br>                res += c<br>            <span class="hljs-keyword">elif</span> c.isdigit():<br>                k = k * <span class="hljs-number">10</span> + <span class="hljs-built_in">int</span>(c)<br>            <span class="hljs-keyword">elif</span> c == <span class="hljs-string">&#x27;[&#x27;</span>:  <span class="hljs-comment"># 之前的结果入栈，防止丢失</span><br>                stack.append((res, k))<br>                res = <span class="hljs-string">&quot;&quot;</span><br>                k = <span class="hljs-number">0</span>   <span class="hljs-comment"># 因此在else处不用k = 0，因为最深的[]没有数字出现</span><br>            <span class="hljs-keyword">else</span>:   <span class="hljs-comment"># 递归结束，出栈进行拼接、</span><br>                pre_res, pre_k = stack.pop()<br>                res = pre_res + res * pre_k<br><br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><h4 id="柱状图中最大的矩形"><a href="#柱状图中最大的矩形" class="headerlink" title="柱状图中最大的矩形"></a>柱状图中最大的矩形</h4><blockquote><p>给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。<br>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">largestRectangleArea</span>(<span class="hljs-params">self, heights: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-comment"># 该单调栈从栈顶到栈底单调递减</span><br>        heights.append(-<span class="hljs-number">1</span>)  <span class="hljs-comment"># 从而保证到最后时，栈中元素都出来进行计算</span><br>        stack = [-<span class="hljs-number">1</span>]    <span class="hljs-comment"># 保证栈空时入栈</span><br>        res = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> right <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(heights)):<br>            <span class="hljs-comment"># left和right之间的所有柱子中，mid是最矮的那个，故高计算正确</span><br>            <span class="hljs-comment"># 因为mid左边的柱子中，第一个比它矮的依然在栈中，即left</span><br>            <span class="hljs-comment"># 而mid右边如果有比它矮的柱子，则mid会提前出栈</span><br>            <span class="hljs-comment"># 而left和right都比mid矮，因此宽是最大的</span><br>            <span class="hljs-keyword">while</span> heights[stack[-<span class="hljs-number">1</span>]] &gt; heights[right]:<br>                mid = stack.pop()<br>                left = stack[-<span class="hljs-number">1</span>]<br>                h = heights[mid]<br>                w = right - left - <span class="hljs-number">1</span><br>                res = <span class="hljs-built_in">max</span>(res, h * w)<br>            stack.append(right)<br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><h4 id="数组中的第K个最大元素"><a href="#数组中的第K个最大元素" class="headerlink" title="数组中的第K个最大元素"></a>数组中的第K个最大元素</h4><blockquote><p>给定整数数组 nums 和整数 k，请返回数组中第 k 个最大的元素。<br>请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。<br>你必须设计并实现时间复杂度为 O(n) 的算法解决此问题。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">findKthLargest</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">quick_select</span>(<span class="hljs-params">nums, k</span>) -&gt; <span class="hljs-built_in">int</span>:<br>            pivot = random.choice(nums) <span class="hljs-comment"># 随机选择基准数</span><br>            big, equal, small = [], [], []<br>            <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> nums:<br>                <span class="hljs-keyword">if</span> num &gt; pivot:<br>                    big.append(num)<br>                <span class="hljs-keyword">elif</span> num &lt; pivot:<br>                    small.append(num)<br>                <span class="hljs-keyword">else</span>:<br>                    equal.append(num)<br>            <span class="hljs-keyword">if</span> k &lt;= <span class="hljs-built_in">len</span>(big):<br>                <span class="hljs-keyword">return</span> quick_select(big, k)<br>            <span class="hljs-keyword">elif</span> <span class="hljs-built_in">len</span>(nums) - <span class="hljs-built_in">len</span>(small) &lt; k:<br>                <span class="hljs-keyword">return</span> quick_select(small, k - <span class="hljs-built_in">len</span>(nums) + <span class="hljs-built_in">len</span>(small))<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">return</span> pivot<br>        <span class="hljs-keyword">return</span> quick_select(nums, k)<br></code></pre></td></tr></table></figure><h4 id="前-K-个高频元素"><a href="#前-K-个高频元素" class="headerlink" title="前 K 个高频元素"></a>前 K 个高频元素</h4><blockquote><p>给你一个整数数组 nums 和一个整数 k ，请你返回其中出现频率前 k 高的元素。你可以按 任意顺序 返回答案。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">topKFrequent</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>        <span class="hljs-comment"># 使用桶排序</span><br>        <span class="hljs-comment"># step1: 使用哈希表统计每个元素出现的次数</span><br>        cnt = Counter(nums)<br>        max_cnt = <span class="hljs-built_in">max</span>(cnt.values())<br><br>        <span class="hljs-comment"># step2: 出现次数相同的元素放在同一个桶中</span><br>        buckets = [[] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(max_cnt + <span class="hljs-number">1</span>)]<br>        <span class="hljs-keyword">for</span> x, c <span class="hljs-keyword">in</span> cnt.items():<br>            buckets[c].append(x)<br>        <br>        <span class="hljs-comment"># step3: 倒序遍历buckets，从而得到答案</span><br>        res = []<br>        <span class="hljs-keyword">for</span> bucket <span class="hljs-keyword">in</span> <span class="hljs-built_in">reversed</span>(buckets):<br>            res += bucket<br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(res) == k:<br>                <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><h4 id="数据流的中位数"><a href="#数据流的中位数" class="headerlink" title="数据流的中位数"></a>数据流的中位数</h4><blockquote><p>中位数是有序整数列表中的中间值。如果列表的大小是偶数，则没有中间值，中位数是两个中间值的平均值。<br>例如 arr &#x3D; [2,3,4] 的中位数是 3 。<br>例如 arr &#x3D; [2,3] 的中位数是 (2 + 3) &#x2F; 2 &#x3D; 2.5 。<br>实现 MedianFinder 类:<br>MedianFinder() 初始化 MedianFinder 对象。<br>void addNum(int num) 将数据流中的整数 num 添加到数据结构中。<br>double findMedian() 返回到目前为止所有元素的中位数。与实际答案相差 10-5 以内的答案将被接受。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MedianFinder</span>:<br>    <span class="hljs-comment"># 分为两个堆left和right，保证left的最大值小于right的最小值的同时，维护left - right &lt;= 1</span><br>    <span class="hljs-comment"># 当left == right时，将元素添加到right中，并将right的最小值移到left中</span><br>    <span class="hljs-comment"># 当left - right == 1时，将元素添加到left中，并将left的最大值移到right中</span><br>    <span class="hljs-comment"># 使用left的最大值和right的最小值来计算中位数</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-variable language_">self</span>.left = []<br>        <span class="hljs-variable language_">self</span>.right = []<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">addNum</span>(<span class="hljs-params">self, num: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-literal">None</span>:<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(<span class="hljs-variable language_">self</span>.left) == <span class="hljs-built_in">len</span>(<span class="hljs-variable language_">self</span>.right):<br>            heapq.heappush(<span class="hljs-variable language_">self</span>.right, num)<br>            heapq.heappush(<span class="hljs-variable language_">self</span>.left, -heapq.heappop(<span class="hljs-variable language_">self</span>.right))<br>        <span class="hljs-keyword">else</span>:<br>            heapq.heappush(<span class="hljs-variable language_">self</span>.left, -num)<br>            heapq.heappush(<span class="hljs-variable language_">self</span>.right, -heapq.heappop(<span class="hljs-variable language_">self</span>.left))<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">findMedian</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">float</span>:<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(<span class="hljs-variable language_">self</span>.left) == <span class="hljs-built_in">len</span>(<span class="hljs-variable language_">self</span>.right):<br>            <span class="hljs-keyword">return</span> (-<span class="hljs-variable language_">self</span>.left[<span class="hljs-number">0</span>] + <span class="hljs-variable language_">self</span>.right[<span class="hljs-number">0</span>]) / <span class="hljs-number">2</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> -<span class="hljs-variable language_">self</span>.left[<span class="hljs-number">0</span>]<br></code></pre></td></tr></table></figure><h3 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h3><h4 id="跳跃游戏-II"><a href="#跳跃游戏-II" class="headerlink" title="跳跃游戏 II"></a>跳跃游戏 II</h4><blockquote><p>给定一个长度为 n 的 0 索引整数数组 nums。初始位置在下标 0。<br>每个元素 nums[i] 表示从索引 i 向后跳转的最大长度。换句话说，如果你在索引 i 处，你可以跳转到任意 (i + j) 处：<br>0 &lt;&#x3D; j &lt;&#x3D; nums[i] 且<br>i + j &lt; n<br>返回到达 n - 1 的最小跳跃次数。测试用例保证可以到达 n - 1。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">jump</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-comment"># 当触及到当前跳跃极限时进行跳跃，并更新覆盖范围</span><br>        <span class="hljs-comment"># 这次跳跃本质上是跳到了能触及下次跳跃极限的位置</span><br>        <span class="hljs-comment"># 这样是正确的，因为迭代器局限在当前覆盖范围之内</span><br>        <span class="hljs-comment"># nextJump表示的是在[0, curJump]这个区间里，所能达到的最远距离</span><br>        <span class="hljs-comment"># 而curJump反映的是上一次所能达到的最远距离</span><br>        <span class="hljs-comment"># 当遍历到curJump时，说明必须跳一次才能到达更远的距离了，这次跳的距离不确定</span><br>        curJump, nextJump, res, i = <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> i &lt;= curJump <span class="hljs-keyword">and</span> curJump &lt; <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span>:<br>            nextJump = <span class="hljs-built_in">max</span>(nextJump, i + nums[i])<br>            <span class="hljs-keyword">if</span> i == curJump:<br>                curJump = nextJump<br>                res += <span class="hljs-number">1</span><br>            i += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><h4 id="划分字母区间"><a href="#划分字母区间" class="headerlink" title="划分字母区间"></a>划分字母区间</h4><blockquote><p>给你一个字符串 s 。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。例如，字符串 “ababcc” 能够被分为 [“abab”, “cc”]，但类似 [“aba”, “bcc”] 或 [“ab”, “ab”, “cc”] 的划分是非法的。<br>注意，划分结果需要满足：将所有划分结果按顺序连接，得到的字符串仍然是 s 。<br>返回一个表示每个字符串片段的长度的列表。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">partitionLabels</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>        <span class="hljs-comment"># 类似于跳跃游戏，遍历字母，找到它们最后出现在哪里，当触及到边缘时，分割出一个区间</span><br>        further = [<span class="hljs-number">0</span>] * <span class="hljs-number">26</span><br>        <span class="hljs-comment"># 记录最后一次出现在哪里</span><br>        <span class="hljs-keyword">for</span> i, c <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(s):<br>            further[<span class="hljs-built_in">ord</span>(c) - <span class="hljs-number">97</span>] = i<br>        most,last = <span class="hljs-number">0</span>, -<span class="hljs-number">1</span><br>        res = []<br>        <span class="hljs-keyword">for</span> i, c <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(s):<br>            most = <span class="hljs-built_in">max</span>(most, further[<span class="hljs-built_in">ord</span>(c) - <span class="hljs-number">97</span>])<br>            <span class="hljs-keyword">if</span> i == most:<br>                res.append(most - last)<br>                last = most<br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><h4 id="完全平方数"><a href="#完全平方数" class="headerlink" title="完全平方数"></a>完全平方数</h4><blockquote><p>给你一个整数 n ，返回 和为 n 的完全平方数的最少数量 。<br>完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">numSquares</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        dp = [inf] * (n + <span class="hljs-number">1</span>)<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span><br>        i = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">while</span> i * i &lt;= n:<br>            j = i * i<br>            <span class="hljs-keyword">while</span> j &lt;= n:<br>                dp[j] = <span class="hljs-built_in">min</span>(dp[j], dp[j - i * i] + <span class="hljs-number">1</span>)<br>                j += <span class="hljs-number">1</span><br>            i += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> dp[n]<br></code></pre></td></tr></table></figure><h4 id="单词拆分"><a href="#单词拆分" class="headerlink" title="单词拆分"></a>单词拆分</h4><blockquote><p>给你一个字符串 s 和一个字符串列表 wordDict 作为字典。如果可以利用字典中出现的一个或多个单词拼接出 s 则返回 true。<br>注意：不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wordBreak</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span>, wordDict: <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]</span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        dp = [<span class="hljs-literal">False</span>] * (<span class="hljs-built_in">len</span>(s) + <span class="hljs-number">1</span>)<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(s) + <span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">for</span> word <span class="hljs-keyword">in</span> wordDict:<br>                <span class="hljs-keyword">if</span> s[i - <span class="hljs-built_in">len</span>(word): i] == word <span class="hljs-keyword">and</span> dp[i - <span class="hljs-built_in">len</span>(word)]:<br>                    dp[i] = <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">return</span> dp[<span class="hljs-built_in">len</span>(s)]<br></code></pre></td></tr></table></figure><h4 id="最长递增子序列"><a href="#最长递增子序列" class="headerlink" title="最长递增子序列"></a>最长递增子序列</h4><blockquote><p>给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。<br>子序列 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">lengthOfLIS</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-comment"># 这里的tails用于记录长度为i + 1的递增子序列的最后一个元素</span><br>        tails, res = [<span class="hljs-number">0</span>] * <span class="hljs-built_in">len</span>(nums), <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> nums:<br>            <span class="hljs-comment"># 二分查找到可以插入新的元素的递增子序列</span><br>            i, j = <span class="hljs-number">0</span>, res<br>            <span class="hljs-keyword">while</span> i &lt; j:<br>                m = (i + j) // <span class="hljs-number">2</span><br>                <span class="hljs-keyword">if</span> tails[m] &lt; num:<br>                    i = m + <span class="hljs-number">1</span><br>                <span class="hljs-keyword">else</span>:<br>                    j = m<br>            tails[i] = num<br>            <span class="hljs-keyword">if</span> j == res:<br>                res += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><h4 id="乘积最大子数组"><a href="#乘积最大子数组" class="headerlink" title="乘积最大子数组"></a>乘积最大子数组</h4><blockquote><p>给你一个整数数组 nums ，请你找出数组中乘积最大的非空连续 子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。<br>测试用例的答案是一个 32-位 整数。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maxProduct</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-comment"># dp[0]表示以i结尾的最大值，dp[1]表示最小值，从而包含到正负性</span><br>        dp = [nums[<span class="hljs-number">0</span>]] * <span class="hljs-number">2</span>       <br>        res = nums[<span class="hljs-number">0</span>]<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(nums)):<br>            dp[<span class="hljs-number">0</span>], dp[<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(nums[i], nums[i] * dp[<span class="hljs-number">0</span>], nums[i] * dp[<span class="hljs-number">1</span>]), <span class="hljs-built_in">min</span>(nums[i], nums[i] * dp[<span class="hljs-number">0</span>], nums[i] * dp[<span class="hljs-number">1</span>])<br>            res = <span class="hljs-built_in">max</span>(res, dp[<span class="hljs-number">0</span>])<br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><h4 id="分割等和子集"><a href="#分割等和子集" class="headerlink" title="分割等和子集"></a>分割等和子集</h4><blockquote><p>给你一个 只包含正整数 的 非空 数组 nums 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">canPartition</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        <span class="hljs-comment"># 即能否塞满sum / 2的背包</span><br>        <span class="hljs-comment"># dp[i]表示容量为i的最大价值</span><br>        <span class="hljs-comment"># 这里让重量等于价值，防止价值超出target</span><br>        total = <span class="hljs-built_in">sum</span>(nums)<br>        <span class="hljs-keyword">if</span> total % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        target = total // <span class="hljs-number">2</span><br>        dp = [<span class="hljs-number">0</span>] * (target + <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums)):<br>            <span class="hljs-comment"># 倒序遍历，防止提前更新数据</span><br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(target, nums[i] - <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br>                dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j - nums[i]] + nums[i])<br>            <span class="hljs-comment"># 剪枝</span><br>            <span class="hljs-keyword">if</span> dp[target] == target:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">return</span> dp[target] == target<br></code></pre></td></tr></table></figure><h4 id="最长有效括号"><a href="#最长有效括号" class="headerlink" title="最长有效括号"></a>最长有效括号</h4><blockquote><p>给你一个只包含 ‘(‘ 和 ‘)’ 的字符串，找出最长有效（格式正确且连续）括号 子串 的长度。<br>左右括号匹配，即每个左括号都有对应的右括号将其闭合的字符串是格式正确的，比如 “(()())”。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">longestValidParentheses</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-comment"># dp[i] 表示以i结尾的有效长度</span><br>        res = <span class="hljs-number">0</span><br>        dp = [<span class="hljs-number">0</span>] * <span class="hljs-built_in">len</span>(s)<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(s)):<br>            <span class="hljs-comment"># 有效的括号一定以&#x27;)&#x27;结尾</span><br>            <span class="hljs-keyword">if</span> s[i] == <span class="hljs-string">&#x27;)&#x27;</span>:<br>                <span class="hljs-keyword">if</span> s[i - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;(&#x27;</span>:<br>                    dp[i] = (dp[i - <span class="hljs-number">2</span>] <span class="hljs-keyword">if</span> i - <span class="hljs-number">2</span> &gt;= <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> <span class="hljs-number">0</span>) + <span class="hljs-number">2</span><br>                <span class="hljs-comment"># 跳过中间的有效部分后，如果不是&#x27;(&#x27;，那也就不是有效的了</span><br>                <span class="hljs-keyword">elif</span> i - dp[i - <span class="hljs-number">1</span>] - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> s[i - dp[i - <span class="hljs-number">1</span>] - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;(&#x27;</span>:<br>                    dp[i] = dp[i - <span class="hljs-number">1</span>] + (dp[i - dp[i - <span class="hljs-number">1</span>] - <span class="hljs-number">2</span>] <span class="hljs-keyword">if</span> i - dp[i - <span class="hljs-number">1</span>] - <span class="hljs-number">2</span> &gt;= <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> <span class="hljs-number">0</span>) + <span class="hljs-number">2</span><br>            res = <span class="hljs-built_in">max</span>(res, dp[i])<br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><h3 id="多维动态规划"><a href="#多维动态规划" class="headerlink" title="多维动态规划"></a>多维动态规划</h3><h4 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a>最长回文子串</h4><blockquote><p>给你一个字符串 s，找到 s 中最长的 回文 子串。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">longestPalindrome</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">str</span>:<br>        <span class="hljs-comment"># 中心扩散法，枚举中心向两边扩散到最长回文</span><br>        n = <span class="hljs-built_in">len</span>(s)<br>        res_left = res_right = <span class="hljs-number">0</span><br><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span> * n - <span class="hljs-number">1</span>):<br>            <span class="hljs-comment"># 包揽奇数回文串和偶数回文串</span><br>            l, r = i // <span class="hljs-number">2</span>, (i + <span class="hljs-number">1</span>) // <span class="hljs-number">2</span><br>            <span class="hljs-keyword">while</span> l &gt;= <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> r &lt; n <span class="hljs-keyword">and</span> s[l] == s[r]:<br>                l -= <span class="hljs-number">1</span><br>                r += <span class="hljs-number">1</span><br>            <span class="hljs-comment"># 结束时，s[l + 1]到s[r - 1]为回文串</span><br>            <span class="hljs-keyword">if</span> r - l - <span class="hljs-number">1</span> &gt; res_right - res_left:<br>                res_left, res_right = l + <span class="hljs-number">1</span>, r  <span class="hljs-comment"># 左闭右开</span><br>        <span class="hljs-keyword">return</span> s[res_left: res_right]<br></code></pre></td></tr></table></figure><h4 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h4><blockquote><p>给定两个字符串 text1 和 text2，返回这两个字符串的最长 公共子序列 的长度。如果不存在 公共子序列 ，返回 0 。<br>一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。<br>例如，”ace” 是 “abcde” 的子序列，但 “aec” 不是 “abcde” 的子序列。<br>两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">longestCommonSubsequence</span>(<span class="hljs-params">self, text1: <span class="hljs-built_in">str</span>, text2: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-comment"># 类似于编辑距离，dp[i][j]记录text[:i]和text2[:j]的最长公共子序列</span><br>        <span class="hljs-comment"># 从dp[0][0]开始，即表示两者都为空</span><br>        m, n = <span class="hljs-built_in">len</span>(text1), <span class="hljs-built_in">len</span>(text2)<br>        dp = [[<span class="hljs-number">0</span>] * (n + <span class="hljs-number">1</span>) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m + <span class="hljs-number">1</span>)]<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, m + <span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):<br>                <span class="hljs-keyword">if</span> text1[i - <span class="hljs-number">1</span>] == text2[j - <span class="hljs-number">1</span>]:<br>                    <span class="hljs-comment"># 不用考虑dp[i - 1][j]和dp[i][j - 1]的原因是，这两个只比dp[i - 1][j - 1]多一个字符</span><br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span><br>                <span class="hljs-keyword">else</span>:<br>                    dp[i][j] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>])<br>        <span class="hljs-keyword">return</span> dp[m][n]<br></code></pre></td></tr></table></figure><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><h4 id="回文链表"><a href="#回文链表" class="headerlink" title="回文链表"></a>回文链表</h4><blockquote><p>给你一个单链表的头节点 head ，请你判断该链表是否为回文链表。如果是，返回 true ；否则，返回 false 。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Definition for singly-linked list.</span><br><span class="hljs-comment"># class ListNode:</span><br><span class="hljs-comment">#     def __init__(self, val=0, next=None):</span><br><span class="hljs-comment">#         self.val = val</span><br><span class="hljs-comment">#         self.next = next</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-comment"># 从中间节点开始反转链表</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">findMid</span>(<span class="hljs-params">self, head: <span class="hljs-type">Optional</span>[ListNode]</span>) -&gt; <span class="hljs-type">Optional</span>[ListNode]:<br>        fast, slow = head, head<br>        <span class="hljs-keyword">while</span> fast <span class="hljs-keyword">and</span> fast.<span class="hljs-built_in">next</span>:<br>            fast, slow = fast.<span class="hljs-built_in">next</span>.<span class="hljs-built_in">next</span>, slow.<span class="hljs-built_in">next</span><br>        <span class="hljs-keyword">return</span> slow<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">reverseList</span>(<span class="hljs-params">self, head: <span class="hljs-type">Optional</span>[ListNode]</span>) -&gt; <span class="hljs-type">Optional</span>[ListNode]:<br>        cur, prev = head, <span class="hljs-literal">None</span><br>        <span class="hljs-keyword">while</span> cur:<br>            cur.<span class="hljs-built_in">next</span>, cur, prev = prev, cur.<span class="hljs-built_in">next</span>, cur<br>        <span class="hljs-keyword">return</span> prev<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">isPalindrome</span>(<span class="hljs-params">self, head: <span class="hljs-type">Optional</span>[ListNode]</span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        mid = <span class="hljs-variable language_">self</span>.findMid(head)<br>        head2 = <span class="hljs-variable language_">self</span>.reverseList(mid)<br>        <span class="hljs-keyword">while</span> head2:<br>            <span class="hljs-keyword">if</span> head.val != head2.val:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>            head, head2 = head.<span class="hljs-built_in">next</span>, head2.<span class="hljs-built_in">next</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><h4 id="删除链表的倒数第-N-个结点"><a href="#删除链表的倒数第-N-个结点" class="headerlink" title="删除链表的倒数第 N 个结点"></a>删除链表的倒数第 N 个结点</h4><blockquote><p>给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Definition for singly-linked list.</span><br><span class="hljs-comment"># class ListNode:</span><br><span class="hljs-comment">#     def __init__(self, val=0, next=None):</span><br><span class="hljs-comment">#         self.val = val</span><br><span class="hljs-comment">#         self.next = next</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">removeNthFromEnd</span>(<span class="hljs-params">self, head: <span class="hljs-type">Optional</span>[ListNode], n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">Optional</span>[ListNode]:<br>        <span class="hljs-comment"># 让fast先走n步</span><br>        fast, slow = head, ListNode(-<span class="hljs-number">1</span>, head)   <span class="hljs-comment"># 规避删除节点是head</span><br>        res = slow<br>        <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            fast = fast.<span class="hljs-built_in">next</span><br>        <span class="hljs-keyword">while</span> fast:<br>            fast, slow = fast.<span class="hljs-built_in">next</span>, slow.<span class="hljs-built_in">next</span><br>        slow.<span class="hljs-built_in">next</span> = slow.<span class="hljs-built_in">next</span>.<span class="hljs-built_in">next</span><br>        <span class="hljs-keyword">return</span> res.<span class="hljs-built_in">next</span><br></code></pre></td></tr></table></figure><h4 id="两两交换链表中的节点"><a href="#两两交换链表中的节点" class="headerlink" title="两两交换链表中的节点"></a>两两交换链表中的节点</h4><blockquote><p>给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Definition for singly-linked list.</span><br><span class="hljs-comment"># class ListNode:</span><br><span class="hljs-comment">#     def __init__(self, val=0, next=None):</span><br><span class="hljs-comment">#         self.val = val</span><br><span class="hljs-comment">#         self.next = next</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">swapPairs</span>(<span class="hljs-params">self, head: <span class="hljs-type">Optional</span>[ListNode]</span>) -&gt; <span class="hljs-type">Optional</span>[ListNode]:<br>        <span class="hljs-comment"># 递归</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> head <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> head.<span class="hljs-built_in">next</span>:<br>            <span class="hljs-keyword">return</span> head<br>        cur = head.<span class="hljs-built_in">next</span><br>        head.<span class="hljs-built_in">next</span> = <span class="hljs-variable language_">self</span>.swapPairs(cur.<span class="hljs-built_in">next</span>)<br>        cur.<span class="hljs-built_in">next</span> = head<br>        <span class="hljs-keyword">return</span> cur<br></code></pre></td></tr></table></figure><h4 id="K-个一组翻转链表"><a href="#K-个一组翻转链表" class="headerlink" title="K 个一组翻转链表"></a>K 个一组翻转链表</h4><blockquote><p>给你链表的头节点 head ，每 k 个节点一组进行翻转，请你返回修改后的链表。<br>k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。<br>你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Definition for singly-linked list.</span><br><span class="hljs-comment"># class ListNode:</span><br><span class="hljs-comment">#     def __init__(self, val=0, next=None):</span><br><span class="hljs-comment">#         self.val = val</span><br><span class="hljs-comment">#         self.next = next</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">reverseKGroup</span>(<span class="hljs-params">self, head: <span class="hljs-type">Optional</span>[ListNode], k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">Optional</span>[ListNode]:<br>        n = <span class="hljs-number">0</span>   <span class="hljs-comment"># 获取长度</span><br>        cur = head<br>        <span class="hljs-keyword">while</span> cur:<br>            cur = cur.<span class="hljs-built_in">next</span><br>            n += <span class="hljs-number">1</span><br>        prev, cur = <span class="hljs-literal">None</span>, head<br>        dum = ListNode(-<span class="hljs-number">1</span>, head)<br>        start = dum<br>        <span class="hljs-keyword">while</span> n &gt;= k:<br>            n -= k<br>            <span class="hljs-comment"># k个一组进行链表反转</span><br>            <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(k):<br>                cur.<span class="hljs-built_in">next</span>, cur, prev = prev, cur.<span class="hljs-built_in">next</span>, cur<br>            <span class="hljs-comment"># start为反转链表的前一节点，cur此时落在下一个反转链表的开头，prev为本次反转链表的开头</span><br>            start.<span class="hljs-built_in">next</span>.<span class="hljs-built_in">next</span>, start.<span class="hljs-built_in">next</span>, start = cur, prev, start.<span class="hljs-built_in">next</span><br>        <span class="hljs-keyword">return</span> dum.<span class="hljs-built_in">next</span><br></code></pre></td></tr></table></figure><h4 id="随机链表的复制"><a href="#随机链表的复制" class="headerlink" title="随机链表的复制"></a>随机链表的复制</h4><blockquote><p>给你一个长度为 n 的链表，每个节点包含一个额外增加的随机指针 random ，该指针可以指向链表中的任何节点或空节点。<br>构造这个链表的 深拷贝。 深拷贝应该正好由 n 个 全新 节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的 next 指针和 random 指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。复制链表中的指针都不应指向原链表中的节点 。<br>例如，如果原链表中有 X 和 Y 两个节点，其中 X.random –&gt; Y 。那么在复制链表中对应的两个节点 x 和 y ，同样有 x.random –&gt; y 。<br>返回复制链表的头节点。<br>用一个由 n 个节点组成的链表来表示输入&#x2F;输出中的链表。每个节点用一个 [val, random_index] 表示：<br>val：一个表示 Node.val 的整数。<br>random_index：随机指针指向的节点索引（范围从 0 到 n-1）；如果不指向任何节点，则为  null 。<br>你的代码 只 接受原链表的头节点 head 作为传入参数。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string"># Definition for a Node.</span><br><span class="hljs-string">class Node:</span><br><span class="hljs-string">    def __init__(self, x: int, next: &#x27;Node&#x27; = None, random: &#x27;Node&#x27; = None):</span><br><span class="hljs-string">        self.val = int(x)</span><br><span class="hljs-string">        self.next = next</span><br><span class="hljs-string">        self.random = random</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">copyRandomList</span>(<span class="hljs-params">self, head: <span class="hljs-string">&#x27;Optional[Node]&#x27;</span></span>) -&gt; <span class="hljs-string">&#x27;Optional[Node]&#x27;</span>:<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> head:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>            <br>        <span class="hljs-comment"># step1: 将原链表和新链表交错在一起</span><br>        cur = head<br>        <span class="hljs-keyword">while</span> cur:<br>            cur.<span class="hljs-built_in">next</span>, cur = Node(cur.val, cur.<span class="hljs-built_in">next</span>), cur.<span class="hljs-built_in">next</span><br>        <br>        <span class="hljs-comment"># step2: 遍历链表找到random，利用交错的特性来完成random的拷贝</span><br>        cur = head<br>        <span class="hljs-keyword">while</span> cur:<br>            <span class="hljs-keyword">if</span> cur.random:<br>                <span class="hljs-comment"># 进行拷贝</span><br>                cur.<span class="hljs-built_in">next</span>.random = cur.random.<span class="hljs-built_in">next</span><br>            cur = cur.<span class="hljs-built_in">next</span>.<span class="hljs-built_in">next</span><br>        <br>        <span class="hljs-comment"># step3: 分离出新链表</span><br>        cur = head.<span class="hljs-built_in">next</span><br>        <span class="hljs-keyword">while</span> cur.<span class="hljs-built_in">next</span>:<br>            cur.<span class="hljs-built_in">next</span>, cur = cur.<span class="hljs-built_in">next</span>.<span class="hljs-built_in">next</span>, cur.<span class="hljs-built_in">next</span>.<span class="hljs-built_in">next</span><br>        <span class="hljs-keyword">return</span> head.<span class="hljs-built_in">next</span><br></code></pre></td></tr></table></figure><h4 id="排序链表"><a href="#排序链表" class="headerlink" title="排序链表"></a>排序链表</h4><blockquote><p>给你链表的头结点 head ，请将其按 升序 排列并返回 排序后的链表 。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Definition for singly-linked list.</span><br><span class="hljs-comment"># class ListNode:</span><br><span class="hljs-comment">#     def __init__(self, val=0, next=None):</span><br><span class="hljs-comment">#         self.val = val</span><br><span class="hljs-comment">#         self.next = next</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-comment"># 使用分治来反复平分链表，再归并排序</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">middleNode</span>(<span class="hljs-params">self, head: <span class="hljs-type">Optional</span>[ListNode]</span>) -&gt; <span class="hljs-type">Optional</span>[ListNode]:<br>        slow, fast, prev = head, head, <span class="hljs-literal">None</span><br>        <span class="hljs-keyword">while</span> fast <span class="hljs-keyword">and</span> fast.<span class="hljs-built_in">next</span>:<br>            prev, slow, fast = slow, slow.<span class="hljs-built_in">next</span>, fast.<span class="hljs-built_in">next</span>.<span class="hljs-built_in">next</span><br>        prev.<span class="hljs-built_in">next</span> = <span class="hljs-literal">None</span>    <span class="hljs-comment"># 断开两个链表的连接</span><br>        <span class="hljs-keyword">return</span> slow<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">mergeTwoLists</span>(<span class="hljs-params">self, head1: <span class="hljs-type">Optional</span>[ListNode], head2: <span class="hljs-type">Optional</span>[ListNode]</span>) -&gt; <span class="hljs-type">Optional</span>[ListNode]:<br>        dum = ListNode(-<span class="hljs-number">1</span>)<br>        cur = dum<br>        <span class="hljs-keyword">while</span> head1 <span class="hljs-keyword">and</span> head2:<br>            <span class="hljs-keyword">if</span> head1.val &lt; head2.val:<br>                cur.<span class="hljs-built_in">next</span> = head1<br>                head1 = head1.<span class="hljs-built_in">next</span><br>            <span class="hljs-keyword">else</span>:<br>                cur.<span class="hljs-built_in">next</span> = head2<br>                head2 = head2.<span class="hljs-built_in">next</span><br>            cur = cur.<span class="hljs-built_in">next</span><br>        cur.<span class="hljs-built_in">next</span> = head1 <span class="hljs-keyword">if</span> head1 <span class="hljs-keyword">else</span> head2<br>        <span class="hljs-keyword">return</span> dum.<span class="hljs-built_in">next</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">sortList</span>(<span class="hljs-params">self, head: <span class="hljs-type">Optional</span>[ListNode]</span>) -&gt; <span class="hljs-type">Optional</span>[ListNode]:<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> head <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> head.<span class="hljs-built_in">next</span>:<br>            <span class="hljs-keyword">return</span> head<br>        <br>        head2 = <span class="hljs-variable language_">self</span>.middleNode(head)<br><br>        <span class="hljs-comment"># 保证两个子链表排好序</span><br>        head = <span class="hljs-variable language_">self</span>.sortList(head)<br>        head2 = <span class="hljs-variable language_">self</span>.sortList(head2)<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.mergeTwoLists(head, head2)<br></code></pre></td></tr></table></figure><h4 id="合并-K-个升序链表"><a href="#合并-K-个升序链表" class="headerlink" title="合并 K 个升序链表"></a>合并 K 个升序链表</h4><blockquote><p>给你一个链表数组，每个链表都已经按升序排列。<br>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Definition for singly-linked list.</span><br><span class="hljs-comment"># class ListNode:</span><br><span class="hljs-comment">#     def __init__(self, val=0, next=None):</span><br><span class="hljs-comment">#         self.val = val</span><br><span class="hljs-comment">#         self.next = next</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-comment"># 两两一组，四四一组，以此类推进行自底向上的合并</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">mergeTwoLists</span>(<span class="hljs-params">self, list1: <span class="hljs-type">Optional</span>[ListNode], list2: <span class="hljs-type">Optional</span>[ListNode]</span>) -&gt; <span class="hljs-type">Optional</span>[ListNode]:<br>        dum = ListNode(-<span class="hljs-number">1</span>)<br>        cur = dum<br>        <span class="hljs-keyword">while</span> list1 <span class="hljs-keyword">and</span> list2:<br>            <span class="hljs-keyword">if</span> list1.val &lt; list2.val:<br>                cur.<span class="hljs-built_in">next</span> = list1<br>                list1 = list1.<span class="hljs-built_in">next</span><br>            <span class="hljs-keyword">else</span>:<br>                cur.<span class="hljs-built_in">next</span> = list2<br>                list2 = list2.<span class="hljs-built_in">next</span><br>            cur = cur.<span class="hljs-built_in">next</span><br>        cur.<span class="hljs-built_in">next</span> = list1 <span class="hljs-keyword">if</span> list1 <span class="hljs-keyword">else</span> list2<br>        <span class="hljs-keyword">return</span> dum.<span class="hljs-built_in">next</span><br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">mergeKLists</span>(<span class="hljs-params">self, lists: <span class="hljs-type">List</span>[<span class="hljs-type">Optional</span>[ListNode]]</span>) -&gt; <span class="hljs-type">Optional</span>[ListNode]:<br>        m = <span class="hljs-built_in">len</span>(lists)<br>        <span class="hljs-keyword">if</span> m == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>        step = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">while</span> step &lt; m:<br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, m - step, step * <span class="hljs-number">2</span>):<br>                lists[i] = <span class="hljs-variable language_">self</span>.mergeTwoLists(lists[i], lists[i + step])<br>            step *= <span class="hljs-number">2</span><br>        <span class="hljs-keyword">return</span> lists[<span class="hljs-number">0</span>]<br></code></pre></td></tr></table></figure><h4 id="LRU缓存"><a href="#LRU缓存" class="headerlink" title="LRU缓存"></a>LRU缓存</h4><blockquote><p>请你设计并实现一个满足  LRU (最近最少使用) 缓存 约束的数据结构。<br>实现 LRUCache 类：<br>LRUCache(int capacity) 以 正整数 作为容量 capacity 初始化 LRU 缓存<br>int get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。<br>void put(int key, int value) 如果关键字 key 已经存在，则变更其数据值 value ；如果不存在，则向缓存中插入该组 key-value 。如果插入操作导致关键字数量超过 capacity ，则应该 逐出 最久未使用的关键字。<br>函数 get 和 put 必须以 O(1) 的平均时间复杂度运行。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, key = <span class="hljs-number">0</span>, value = <span class="hljs-number">0</span></span>):<br>        <span class="hljs-variable language_">self</span>.key = key<br>        <span class="hljs-variable language_">self</span>.value = value<br>        <span class="hljs-variable language_">self</span>.prev = <span class="hljs-literal">None</span><br>        <span class="hljs-variable language_">self</span>.<span class="hljs-built_in">next</span> = <span class="hljs-literal">None</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LRUCache</span>:<br>    <span class="hljs-comment"># 双向环形链表+字典快速查找</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, capacity: <span class="hljs-built_in">int</span></span>):<br>        <span class="hljs-variable language_">self</span>.capacity = capacity<br>        <span class="hljs-variable language_">self</span>.dum = Node()<br>        <span class="hljs-variable language_">self</span>.dum.prev = <span class="hljs-variable language_">self</span>.dum    <span class="hljs-comment"># 为最后一个，即即将过期的那个</span><br>        <span class="hljs-variable language_">self</span>.dum.<span class="hljs-built_in">next</span> = <span class="hljs-variable language_">self</span>.dum    <span class="hljs-comment"># 为第一个，即才访问的那个</span><br>        <span class="hljs-variable language_">self</span>.diction = &#123;&#125;<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get</span>(<span class="hljs-params">self, key: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        node = <span class="hljs-variable language_">self</span>.getNode(key)<br>        <span class="hljs-keyword">return</span> node.value <span class="hljs-keyword">if</span> node <span class="hljs-keyword">else</span> -<span class="hljs-number">1</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">put</span>(<span class="hljs-params">self, key: <span class="hljs-built_in">int</span>, value: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-literal">None</span>:<br>        node = <span class="hljs-variable language_">self</span>.getNode(key)<br>        <span class="hljs-keyword">if</span> node:<br>            <span class="hljs-comment"># 更新value</span><br>            node.value = value<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-variable language_">self</span>.diction[key] = node = Node(key, value)<br>            <span class="hljs-variable language_">self</span>.push_front(node)<br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(<span class="hljs-variable language_">self</span>.diction) &gt; <span class="hljs-variable language_">self</span>.capacity:<br>                last_node = <span class="hljs-variable language_">self</span>.dum.prev<br>                <span class="hljs-keyword">del</span> <span class="hljs-variable language_">self</span>.diction[last_node.key]<br>                <span class="hljs-variable language_">self</span>.remove(last_node)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">getNode</span>(<span class="hljs-params">self, key: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">Optional</span>[Node]:<br>        <span class="hljs-keyword">if</span> key <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> <span class="hljs-variable language_">self</span>.diction:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>        node = <span class="hljs-variable language_">self</span>.diction[key]<br>        <span class="hljs-comment"># 使用过，放在最前面</span><br>        <span class="hljs-variable language_">self</span>.remove(node)<br>        <span class="hljs-variable language_">self</span>.push_front(node)<br>        <span class="hljs-keyword">return</span> node<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">remove</span>(<span class="hljs-params">self, node: Node</span>) -&gt; <span class="hljs-literal">None</span>:<br>        node.prev.<span class="hljs-built_in">next</span>, node.<span class="hljs-built_in">next</span>.prev = node.<span class="hljs-built_in">next</span>, node.prev<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">push_front</span>(<span class="hljs-params">self, node: Node</span>) -&gt; <span class="hljs-literal">None</span>:<br>        node.prev, node.<span class="hljs-built_in">next</span>, <span class="hljs-variable language_">self</span>.dum.<span class="hljs-built_in">next</span>.prev, <span class="hljs-variable language_">self</span>.dum.<span class="hljs-built_in">next</span> = <span class="hljs-variable language_">self</span>.dum, <span class="hljs-variable language_">self</span>.dum.<span class="hljs-built_in">next</span>, node, node   <span class="hljs-comment"># 注意从左到右依次赋值</span><br>        <br><br><br><span class="hljs-comment"># Your LRUCache object will be instantiated and called as such:</span><br><span class="hljs-comment"># obj = LRUCache(capacity)</span><br><span class="hljs-comment"># param_1 = obj.get(key)</span><br><span class="hljs-comment"># obj.put(key,value)</span><br></code></pre></td></tr></table></figure><h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><h4 id="对称二叉树"><a href="#对称二叉树" class="headerlink" title="对称二叉树"></a>对称二叉树</h4><blockquote><p>给你一个二叉树的根节点 root ， 检查它是否轴对称。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Definition for a binary tree node.</span><br><span class="hljs-comment"># class TreeNode:</span><br><span class="hljs-comment">#     def __init__(self, val=0, left=None, right=None):</span><br><span class="hljs-comment">#         self.val = val</span><br><span class="hljs-comment">#         self.left = left</span><br><span class="hljs-comment">#         self.right = right</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">isSymmetric</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">check</span>(<span class="hljs-params">left: <span class="hljs-type">Optional</span>[TreeNode], right: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-built_in">bool</span>:<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> left <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> right:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>            <span class="hljs-keyword">elif</span> left <span class="hljs-keyword">and</span> right:<br>                <span class="hljs-keyword">if</span> left.val != right.val:<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>                outside = check(left.left, right.right)<br>                inside = check(left.right, right.left)<br>                <span class="hljs-keyword">return</span> outside <span class="hljs-keyword">and</span> inside<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">return</span> check(root.left, root.right)<br></code></pre></td></tr></table></figure><h4 id="二叉树的直径"><a href="#二叉树的直径" class="headerlink" title="二叉树的直径"></a>二叉树的直径</h4><blockquote><p>给你一棵二叉树的根节点，返回该树的 直径 。<br>二叉树的 直径 是指树中任意两个节点之间最长路径的 长度 。这条路径可能经过也可能不经过根节点 root 。<br>两节点之间路径的 长度 由它们之间边数表示。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Definition for a binary tree node.</span><br><span class="hljs-comment"># class TreeNode:</span><br><span class="hljs-comment">#     def __init__(self, val=0, left=None, right=None):</span><br><span class="hljs-comment">#         self.val = val</span><br><span class="hljs-comment">#         self.left = left</span><br><span class="hljs-comment">#         self.right = right</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">diameterOfBinaryTree</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-comment"># 链为叶子节点到当前节点之间的长度，直径为左右两子树的最长链之和</span><br>        res = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">computeChain</span>(<span class="hljs-params">root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:<br>                <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br>            leftChain = computeChain(root.left) + <span class="hljs-number">1</span><br>            rightChain = computeChain(root.right) + <span class="hljs-number">1</span><br>            <span class="hljs-keyword">nonlocal</span> res<br>            res = <span class="hljs-built_in">max</span>(res, leftChain + rightChain)<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(leftChain, rightChain)<br>        computeChain(root)<br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><h4 id="二叉树的层序遍历"><a href="#二叉树的层序遍历" class="headerlink" title="二叉树的层序遍历"></a>二叉树的层序遍历</h4><blockquote><p>给你二叉树的根节点 root ，返回其节点值的 层序遍历 。 （即逐层地，从左到右访问所有节点）。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Definition for a binary tree node.</span><br><span class="hljs-comment"># class TreeNode:</span><br><span class="hljs-comment">#     def __init__(self, val=0, left=None, right=None):</span><br><span class="hljs-comment">#         self.val = val</span><br><span class="hljs-comment">#         self.left = left</span><br><span class="hljs-comment">#         self.right = right</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">levelOrder</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:<br>        res = []<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:<br>            <span class="hljs-keyword">return</span> res<br>        q = deque()<br>        q.append(root)<br>        <span class="hljs-comment"># 使用队列辅助</span><br>        <span class="hljs-keyword">while</span> q:<br>            path = []<br>            <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(q)): <span class="hljs-comment"># 当前层的节点数</span><br>                node = q.popleft()<br>                path.append(node.val)<br>                <span class="hljs-keyword">if</span> node.left:<br>                    q.append(node.left)<br>                <span class="hljs-keyword">if</span> node.right:<br>                    q.append(node.right)<br>            res.append(path)<br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><h4 id="二叉树展开为链表"><a href="#二叉树展开为链表" class="headerlink" title="二叉树展开为链表"></a>二叉树展开为链表</h4><blockquote><p>给你二叉树的根结点 root ，请你将它展开为一个单链表：<br>展开后的单链表应该同样使用 TreeNode ，其中 right 子指针指向链表中下一个结点，而左子指针始终为 null 。<br>展开后的单链表应该与二叉树 先序遍历 顺序相同。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Definition for a binary tree node.</span><br><span class="hljs-comment"># class TreeNode:</span><br><span class="hljs-comment">#     def __init__(self, val=0, left=None, right=None):</span><br><span class="hljs-comment">#         self.val = val</span><br><span class="hljs-comment">#         self.left = left</span><br><span class="hljs-comment">#         self.right = right</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    head = <span class="hljs-literal">None</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">flatten</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-literal">None</span>:<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        Do not return anything, modify root in-place instead.</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment"># 将先序遍历倒过来，从而倒着将树整理成链表</span><br>        <span class="hljs-comment"># 每次使用头插法即可</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:<br>            <span class="hljs-keyword">return</span> root<br>        <span class="hljs-variable language_">self</span>.flatten(root.right)<br>        <span class="hljs-variable language_">self</span>.flatten(root.left)<br>        root.left = <span class="hljs-literal">None</span><br>        root.right = <span class="hljs-variable language_">self</span>.head<br>        <span class="hljs-variable language_">self</span>.head = root<br></code></pre></td></tr></table></figure><h4 id="从前序与中序遍历序列构造二叉树"><a href="#从前序与中序遍历序列构造二叉树" class="headerlink" title="从前序与中序遍历序列构造二叉树"></a>从前序与中序遍历序列构造二叉树</h4><blockquote><p>给定两个整数数组 preorder 和 inorder ，其中 preorder 是二叉树的先序遍历， inorder 是同一棵树的中序遍历，请构造二叉树并返回其根节点。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Definition for a binary tree node.</span><br><span class="hljs-comment"># class TreeNode:</span><br><span class="hljs-comment">#     def __init__(self, val=0, left=None, right=None):</span><br><span class="hljs-comment">#         self.val = val</span><br><span class="hljs-comment">#         self.left = left</span><br><span class="hljs-comment">#         self.right = right</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">buildTree</span>(<span class="hljs-params">self, preorder: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], inorder: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">Optional</span>[TreeNode]:<br>        <span class="hljs-comment"># 使用哈希表预处理中序遍历，便于快速查找位置，节约时间</span><br>        index = &#123;x: i <span class="hljs-keyword">for</span> i, x <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(inorder)&#125;<br><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">findNode</span>(<span class="hljs-params">pre_l: <span class="hljs-built_in">int</span>, pre_r: <span class="hljs-built_in">int</span>, in_l: <span class="hljs-built_in">int</span>, in_r: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">Optional</span>[TreeNode]:<br>            <span class="hljs-keyword">if</span> pre_l &gt; pre_r:  <span class="hljs-comment"># 空节点</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>            start = preorder[pre_l]<br>            root = TreeNode(start)<br>            mid = index[start]<br>            left_len, right_len = mid - in_l, in_r - mid<br>            root.left = findNode(pre_l + <span class="hljs-number">1</span>, pre_l + left_len, in_l, mid - <span class="hljs-number">1</span>)<br>            root.right = findNode(pre_r - right_len + <span class="hljs-number">1</span>, pre_r, mid + <span class="hljs-number">1</span>, in_r)<br>            <span class="hljs-keyword">return</span> root<br>        <br>        <span class="hljs-keyword">return</span> findNode(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(preorder) - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(inorder) - <span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><h4 id="路径总和-III"><a href="#路径总和-III" class="headerlink" title="路径总和 III"></a>路径总和 III</h4><blockquote><p>给定一个二叉树的根节点 root ，和一个整数 targetSum ，求该二叉树里节点值之和等于 targetSum 的 路径 的数目。<br>路径 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Definition for a binary tree node.</span><br><span class="hljs-comment"># class TreeNode:</span><br><span class="hljs-comment">#     def __init__(self, val=0, left=None, right=None):</span><br><span class="hljs-comment">#         self.val = val</span><br><span class="hljs-comment">#         self.left = left</span><br><span class="hljs-comment">#         self.right = right</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">pathSum</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode], targetSum: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-comment"># 类比和为K的子数组，使用哈希表，键为前缀和，值为个数</span><br>        res = <span class="hljs-number">0</span><br>        cnt = defaultdict(<span class="hljs-built_in">int</span>)<br>        cnt[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">recursive</span>(<span class="hljs-params">node: <span class="hljs-type">Optional</span>[TreeNode], s: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> node:<br>                <span class="hljs-keyword">return</span><br><br>            <span class="hljs-keyword">nonlocal</span> res<br>            s += node.val   <span class="hljs-comment"># 以该节点结尾的当前前缀和</span><br>            res += cnt[s - targetSum]<br>            cnt[s] += <span class="hljs-number">1</span><br><br>            recursive(node.left, s)<br>            recursive(node.right, s)<br>            cnt[s] -= <span class="hljs-number">1</span> <span class="hljs-comment"># 回溯，因此数量减一</span><br>        <br>        recursive(root, <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><h4 id="二叉树的最近公共祖先"><a href="#二叉树的最近公共祖先" class="headerlink" title="二叉树的最近公共祖先"></a>二叉树的最近公共祖先</h4><blockquote><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。<br>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Definition for a binary tree node.</span><br><span class="hljs-comment"># class TreeNode:</span><br><span class="hljs-comment">#     def __init__(self, x):</span><br><span class="hljs-comment">#         self.val = x</span><br><span class="hljs-comment">#         self.left = None</span><br><span class="hljs-comment">#         self.right = None</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">lowestCommonAncestor</span>(<span class="hljs-params">self, root: <span class="hljs-string">&#x27;TreeNode&#x27;</span>, p: <span class="hljs-string">&#x27;TreeNode&#x27;</span>, q: <span class="hljs-string">&#x27;TreeNode&#x27;</span></span>) -&gt; <span class="hljs-string">&#x27;TreeNode&#x27;</span>:<br>        <span class="hljs-comment"># 后序遍历自底向上</span><br>        <span class="hljs-comment"># 只返回p, q, None, 或者它们共同的祖先</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root <span class="hljs-keyword">or</span> root == p <span class="hljs-keyword">or</span> root == q:<br>            <span class="hljs-keyword">return</span> root<br>        left, right = <span class="hljs-variable language_">self</span>.lowestCommonAncestor(root.left, p, q), <span class="hljs-variable language_">self</span>.lowestCommonAncestor(root.right, p, q)<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> left <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> right:  <span class="hljs-comment"># 都为空，说明p,q都没出现</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>        <span class="hljs-keyword">if</span> left <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> right:  <span class="hljs-comment"># 其中一个不为空，说明已经找到或者只找到一个</span><br>            <span class="hljs-keyword">return</span> left<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> left <span class="hljs-keyword">and</span> right:<br>            <span class="hljs-keyword">return</span> right<br>        <span class="hljs-keyword">if</span> left <span class="hljs-keyword">and</span> right:  <span class="hljs-comment"># 左右各一个，说明当前节点为公共祖先</span><br>            <span class="hljs-keyword">return</span> root<br></code></pre></td></tr></table></figure><h4 id="二叉树中的最大路径和"><a href="#二叉树中的最大路径和" class="headerlink" title="二叉树中的最大路径和"></a>二叉树中的最大路径和</h4><blockquote><p>二叉树中的 路径 被定义为一条节点序列，序列中每对相邻节点之间都存在一条边。同一个节点在一条路径序列中 至多出现一次 。该路径 至少包含一个 节点，且不一定经过根节点。<br>路径和 是路径中各节点值的总和。<br>给你一个二叉树的根节点 root ，返回其 最大路径和 。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Definition for a binary tree node.</span><br><span class="hljs-comment"># class TreeNode:</span><br><span class="hljs-comment">#     def __init__(self, val=0, left=None, right=None):</span><br><span class="hljs-comment">#         self.val = val</span><br><span class="hljs-comment">#         self.left = left</span><br><span class="hljs-comment">#         self.right = right</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maxPathSum</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-comment"># 同样是只算链的和</span><br>        res = -inf<br><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">computeChain</span>(<span class="hljs-params">node: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> node:<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>            left_chain = computeChain(node.left)<br>            right_chain = computeChain(node.right)<br>            <span class="hljs-keyword">nonlocal</span> res<br>            res = <span class="hljs-built_in">max</span>(res, left_chain + right_chain + node.val)<br>            <span class="hljs-comment"># 链可以没有元素，res计算时保证了node.val，从而保证路径中至少有一个节点，而链不用，因此和0比较</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(<span class="hljs-built_in">max</span>(left_chain, right_chain) + node.val, <span class="hljs-number">0</span>)<br>        <br>        computeChain(root)<br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><h3 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h3><h4 id="多数元素"><a href="#多数元素" class="headerlink" title="多数元素"></a>多数元素</h4><blockquote><p>给定一个大小为 n 的数组 nums ，返回其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n&#x2F;2 ⌋ 的元素。<br>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">majorityElement</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-comment"># 使用擂台比较，考虑到严格众数比其他数加起来都多，它一定会留到最后</span><br>        res = hp = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> nums:<br>            <span class="hljs-comment"># 每次hp = 0将该数字作为擂主，直到出现次数抵消，开启新擂主</span><br>            <span class="hljs-keyword">if</span> hp == <span class="hljs-number">0</span>:<br>                res, hp = x, <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                hp += <span class="hljs-number">1</span> <span class="hljs-keyword">if</span> x == res <span class="hljs-keyword">else</span> -<span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><h4 id="颜色分类"><a href="#颜色分类" class="headerlink" title="颜色分类"></a>颜色分类</h4><blockquote><p>给定一个包含红色、白色和蓝色、共 n 个元素的数组 nums ，原地 对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。<br>我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。<br>必须在不使用库内置的 sort 函数的情况下解决这个问题。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">sortColors</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-literal">None</span>:<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        Do not return anything, modify nums in-place instead.</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment"># 使用插入排序，将nums[i]插入到nums[:i]的序列中去</span><br>        <span class="hljs-comment"># 只用将0,1,2结尾的三个数字向后移动，因此维护它们的位置</span><br>        p0 = p1 = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i, x <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(nums):<br>            <span class="hljs-comment"># 倒着插入，从而保证覆盖</span><br>            nums[i] = <span class="hljs-number">2</span><br>            <span class="hljs-keyword">if</span> x &lt;= <span class="hljs-number">1</span>:<br>                nums[p1] = <span class="hljs-number">1</span><br>                p1 += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> x == <span class="hljs-number">0</span>:<br>                nums[p0] = <span class="hljs-number">0</span><br>                p0 += <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h4 id="下一个排列"><a href="#下一个排列" class="headerlink" title="下一个排列"></a>下一个排列</h4><blockquote><p>整数数组的一个 排列  就是将其所有成员以序列或线性顺序排列。<br>例如，arr &#x3D; [1,2,3] ，以下这些都可以视作 arr 的排列：[1,2,3]、[1,3,2]、[3,1,2]、[2,3,1] 。<br>整数数组的 下一个排列 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 下一个排列 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。<br>例如，arr &#x3D; [1,2,3] 的下一个排列是 [1,3,2] 。<br>类似地，arr &#x3D; [2,3,1] 的下一个排列是 [3,1,2] 。<br>而 arr &#x3D; [3,2,1] 的下一个排列是 [1,2,3] ，因为 [3,2,1] 不存在一个字典序更大的排列。<br>给你一个整数数组 nums ，找出 nums 的下一个排列。<br>必须 原地 修改，只允许使用额外常数空间。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">nextPermutation</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-literal">None</span>:<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        Do not return anything, modify nums in-place instead.</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        n = <span class="hljs-built_in">len</span>(nums)<br>        <span class="hljs-comment"># step1: 从右向左找到第一个小于右侧相邻数字的数x，此时x右边单调递减</span><br>        i = n - <span class="hljs-number">2</span><br>        <span class="hljs-keyword">while</span> i &gt;= <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> nums[i] &gt;= nums[i + <span class="hljs-number">1</span>]:<br>            i -= <span class="hljs-number">1</span><br><br>        <span class="hljs-comment"># step2: 找到x右边最小的大于x的数字y，进行交换，此时单调递减不变</span><br>        <span class="hljs-comment"># 注意如果step1没找到，说明已经是最大排列</span><br>        <span class="hljs-keyword">if</span> i &gt;= <span class="hljs-number">0</span>:<br>            j = n - <span class="hljs-number">1</span><br>            <span class="hljs-keyword">while</span> nums[j] &lt;= nums[i]:<br>                j -= <span class="hljs-number">1</span><br>            nums[i], nums[j] = nums[j], nums[i]<br><br>        <span class="hljs-comment"># step3: 反转y右边的数，变成最小排列</span><br>        left, right = i + <span class="hljs-number">1</span>, n - <span class="hljs-number">1</span><br>        <span class="hljs-keyword">while</span> left &lt; right:<br>            nums[left], nums[right] = nums[right], nums[left]<br>            left += <span class="hljs-number">1</span><br>            right -= <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h4 id="寻找重复数"><a href="#寻找重复数" class="headerlink" title="寻找重复数"></a>寻找重复数</h4><blockquote><p>给定一个包含 n + 1 个整数的数组 nums ，其数字都在 [1, n] 范围内（包括 1 和 n），可知至少存在一个重复的整数。<br>假设 nums 只有 一个重复的整数 ，返回 这个重复的数 。<br>你设计的解决方案必须 不修改 数组 nums 且只用常量级 O(1) 的额外空间。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">findDuplicate</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-comment"># 使用环形链表，假设当前元素为i，则其指向nums[i]</span><br>        <span class="hljs-comment"># 环的入口的下标就是重复元素，因为进入环需要有元素指向该下标，而环内也有元素指向该下标</span><br>        <span class="hljs-comment"># 而nums[0] != 0，因此不用担心自环</span><br>        slow, fast = <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>            fast = nums[fast]<br>            fast = nums[fast]<br>            slow = nums[slow]<br>            <span class="hljs-keyword">if</span> fast == slow:<br>                <span class="hljs-keyword">break</span><br>        slow = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> fast != slow:<br>            fast = nums[fast]<br>            slow = nums[slow]<br>        <span class="hljs-keyword">return</span> slow<br></code></pre></td></tr></table></figure><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><h4 id="在排序数组中查找元素的第一个和最后一个位置"><a href="#在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="在排序数组中查找元素的第一个和最后一个位置"></a>在排序数组中查找元素的第一个和最后一个位置</h4><blockquote><p>给你一个按照非递减顺序排列的整数数组 nums，和一个目标值 target。请你找出给定目标值在数组中的开始位置和结束位置。<br>如果数组中不存在目标值 target，返回 [-1, -1]。<br>你必须设计并实现时间复杂度为 O(log n) 的算法解决此问题。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">searchRange</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], target: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>        <span class="hljs-comment"># 寻找最小的满足nums[i] &gt;= target的下标，因此可能溢出len，也可能不存在target，后续用此进行判断</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">lower_bound</span>(<span class="hljs-params">t: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>            left, right = <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span><br>            <span class="hljs-keyword">while</span> left &lt;= right:<br>                mid = (left + right) // <span class="hljs-number">2</span><br>                <span class="hljs-keyword">if</span> nums[mid] &gt;= t:<br>                    right = mid - <span class="hljs-number">1</span><br>                <span class="hljs-keyword">else</span>:<br>                    left = mid + <span class="hljs-number">1</span><br>            <span class="hljs-keyword">return</span> left <span class="hljs-comment"># 此时left = right + 1，因此返回left</span><br>        <br>        start = lower_bound(target)<br>        <span class="hljs-comment"># 借lower_bound函数的漏洞判断存在与否</span><br>        <span class="hljs-keyword">if</span> start == <span class="hljs-built_in">len</span>(nums) <span class="hljs-keyword">or</span> nums[start] != target:<br>            <span class="hljs-keyword">return</span> [-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>]<br>        <span class="hljs-comment"># 因为都是整数，故+1找下一位</span><br>        end = lower_bound(target + <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> [start, end - <span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><h4 id="搜索旋转排序数组"><a href="#搜索旋转排序数组" class="headerlink" title="搜索旋转排序数组"></a>搜索旋转排序数组</h4><blockquote><p>整数数组 nums 按升序排列，数组中的值 互不相同 。<br>在传递给函数之前，nums 在预先未知的某个下标 k（0 &lt;&#x3D; k &lt; nums.length）上进行了 向左旋转，使数组变为 [nums[k], nums[k+1], …, nums[n-1], nums[0], nums[1], …, nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 下标 3 上向左旋转后可能变为 [4,5,6,7,0,1,2] 。<br>给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。<br>你必须设计一个时间复杂度为 O(log n) 的算法解决此问题。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">search</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], target: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-comment"># 通过比较x与nums[-1]来判断x在第一段还是第二段</span><br>        <span class="hljs-comment"># check函数用以判断target是否在mid的左边（或者相等）</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">check</span>(<span class="hljs-params">i: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">bool</span>:<br>            x = nums[i]<br>            <span class="hljs-keyword">if</span> x &gt; nums[-<span class="hljs-number">1</span>]:    <span class="hljs-comment"># 在第一段，此时target也必须在第一段</span><br>                <span class="hljs-keyword">return</span> target &gt; nums[-<span class="hljs-number">1</span>] <span class="hljs-keyword">and</span> x &gt;= target<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">return</span> target &gt; nums[-<span class="hljs-number">1</span>] <span class="hljs-keyword">or</span> x &gt;= target<br>        <br>        left, right = <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span><br>        <span class="hljs-keyword">while</span> left &lt; right:<br>            mid = (left + right) // <span class="hljs-number">2</span><br>            <span class="hljs-keyword">if</span> check(mid):<br>                right = mid<br>            <span class="hljs-keyword">else</span>:<br>                left = mid + <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> right <span class="hljs-keyword">if</span> nums[right] == target <span class="hljs-keyword">else</span> -<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h4 id="寻找两个正序数组的中位数"><a href="#寻找两个正序数组的中位数" class="headerlink" title="寻找两个正序数组的中位数"></a>寻找两个正序数组的中位数</h4><blockquote><p>给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。<br>算法的时间复杂度应该为 O(log (m+n)) 。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">findMedianSortedArrays</span>(<span class="hljs-params">self, nums1: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], nums2: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">float</span>:<br>        <span class="hljs-comment"># 均分两个数组合并在一起的数组，从而利用前数组的最大值和后数组的最小值求得中位数</span><br>        <span class="hljs-comment"># 从枚举nums1中有多少元素在前数组中，到二分查找</span><br>        <span class="hljs-comment"># 这里需要保证nums1长度小于nums2，防止j变为负数</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums1) &gt; <span class="hljs-built_in">len</span>(nums2):<br>            nums1, nums2 = nums2, nums1<br>        m, n = <span class="hljs-built_in">len</span>(nums1), <span class="hljs-built_in">len</span>(nums2)<br>        <span class="hljs-comment"># 计算有多少元素在前数组中</span><br>        left, right = <span class="hljs-number">0</span>, m<br>        <span class="hljs-keyword">while</span> left &lt;= right:<br>            i = (left + right) // <span class="hljs-number">2</span> <span class="hljs-comment"># nums1中有多少元素在前数组中</span><br>            j = (m + n + <span class="hljs-number">1</span>) // <span class="hljs-number">2</span> - i    <span class="hljs-comment"># 规定奇数时前数组比后数组多一个元素</span><br>            nums1_left = nums1[i - <span class="hljs-number">1</span>] <span class="hljs-keyword">if</span> i &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> <span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;-inf&#x27;</span>)<br>            nums1_right = nums1[i] <span class="hljs-keyword">if</span> i &lt; m <span class="hljs-keyword">else</span> <span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;inf&#x27;</span>)<br>            nums2_left = nums2[j - <span class="hljs-number">1</span>] <span class="hljs-keyword">if</span> j &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> <span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;-inf&#x27;</span>)<br>            nums2_right = nums2[j] <span class="hljs-keyword">if</span> j &lt; n <span class="hljs-keyword">else</span> <span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;inf&#x27;</span>)<br>            <span class="hljs-keyword">if</span> nums1_left &lt;= nums2_right <span class="hljs-keyword">and</span> nums2_left &lt;= nums1_right:<br>                left_max = <span class="hljs-built_in">max</span>(nums1_left, nums2_left)<br>                right_min = <span class="hljs-built_in">min</span>(nums1_right, nums2_right)<br>                <span class="hljs-keyword">if</span> (m + n) % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>:<br>                    <span class="hljs-keyword">return</span> (left_max + right_min) / <span class="hljs-number">2</span><br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-keyword">return</span> left_max<br>            <span class="hljs-keyword">elif</span> nums1_left &lt; nums2_right:   <span class="hljs-comment"># 太小，多选</span><br>                left = i + <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:   <span class="hljs-comment"># 太大，少选</span><br>                right = i - <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
      <category>hot100</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>hot100</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode所需python相关api整理</title>
    <link href="/2025/09/14/leetcode%E6%89%80%E9%9C%80python%E7%9B%B8%E5%85%B3api%E6%95%B4%E7%90%86/"/>
    <url>/2025/09/14/leetcode%E6%89%80%E9%9C%80python%E7%9B%B8%E5%85%B3api%E6%95%B4%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="Python-刷-LeetCode时常用的-list-方法"><a href="#Python-刷-LeetCode时常用的-list-方法" class="headerlink" title="Python 刷 LeetCode时常用的 list 方法"></a>Python 刷 LeetCode时常用的 list 方法</h1><hr><h2 id="1-列表创建与访问"><a href="#1-列表创建与访问" class="headerlink" title="1. 列表创建与访问"></a>1. 列表创建与访问</h2><ul><li>创建：<code>nums = [1, 2, 3]</code></li><li>访问单个元素：<code>nums[0]</code>，<code>nums[-1]</code></li><li>切片：<code>nums[1:3]</code>，<code>nums[:]</code>，<code>nums[::-1]</code>（逆序）</li></ul><hr><h2 id="2-增加元素"><a href="#2-增加元素" class="headerlink" title="2. 增加元素"></a>2. 增加元素</h2><ul><li>尾部添加：<code>nums.append(x)</code></li><li>任意位置插入：<code>nums.insert(i, x)</code></li><li>合并另一个列表：<code>nums.extend([4,5])</code></li></ul><hr><h2 id="3-删除元素"><a href="#3-删除元素" class="headerlink" title="3. 删除元素"></a>3. 删除元素</h2><ul><li>删除末尾并返回：<code>nums.pop()</code></li><li>删除指定位置：<code>nums.pop(i)</code></li><li>删除指定值（第一个出现的）：<code>nums.remove(x)</code></li></ul><hr><h2 id="4-查找与统计"><a href="#4-查找与统计" class="headerlink" title="4. 查找与统计"></a>4. 查找与统计</h2><ul><li>查找值下标：<code>nums.index(x)</code></li><li>统计某值出现次数：<code>nums.count(x)</code></li></ul><hr><h2 id="5-排序与反转"><a href="#5-排序与反转" class="headerlink" title="5. 排序与反转"></a>5. 排序与反转</h2><ul><li>原地排序：<code>nums.sort()</code></li><li>返回新排序列表：<code>sorted(nums)</code></li><li>原地反转：<code>nums.reverse()</code></li><li>返回逆序新列表：<code>nums[::-1]</code></li></ul><hr><h2 id="6-长度和遍历"><a href="#6-长度和遍历" class="headerlink" title="6. 长度和遍历"></a>6. 长度和遍历</h2><ul><li>长度：<code>len(nums)</code></li><li>遍历：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> nums:<br>    <span class="hljs-comment"># do something</span><br></code></pre></td></tr></table></figure></li></ul><hr><h2 id="7-列表推导式（高频）"><a href="#7-列表推导式（高频）" class="headerlink" title="7. 列表推导式（高频）"></a>7. 列表推导式（高频）</h2><ul><li>过滤和变换：<code>[x*x for x in nums if x &gt; 0]</code></li></ul><hr><h2 id="8-常见技巧"><a href="#8-常见技巧" class="headerlink" title="8. 常见技巧"></a>8. 常见技巧</h2><ul><li>判断元素是否存在：<code>x in nums</code></li><li>列表拼接：<code>nums1 + nums2</code></li><li>拷贝列表：<code>nums[:]</code> 或 <code>nums.copy()</code></li><li>清空列表：<code>nums.clear()</code></li><li>多维列表：<code>matrix = [[0]*n for _ in range(m)]</code> （二维矩阵常用）</li></ul><hr><p>这些方法覆盖了<strong>绝大多数 LeetCode 刷题中的 list 场景</strong>，如数组遍历、搜索、排序、滑动窗口、双指针等题型。</p><h1 id="Python-刷-LeetCode时常用的元组（tuple）用法"><a href="#Python-刷-LeetCode时常用的元组（tuple）用法" class="headerlink" title="Python 刷 LeetCode时常用的元组（tuple）用法"></a>Python 刷 LeetCode时常用的元组（tuple）用法</h1><hr><h2 id="1-创建元组"><a href="#1-创建元组" class="headerlink" title="1. 创建元组"></a>1. 创建元组</h2><ul><li>多个元素：<code>t = (a, b)</code></li><li>单元素：<code>t = (a,)</code>  # 注意逗号</li></ul><hr><h2 id="2-常见场景"><a href="#2-常见场景" class="headerlink" title="2. 常见场景"></a>2. 常见场景</h2><h3 id="1）坐标-区间表示"><a href="#1）坐标-区间表示" class="headerlink" title="1）坐标&#x2F;区间表示"></a>1）坐标&#x2F;区间表示</h3><ul><li>用元组表示二维坐标或区间：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">point = (x, y)<br>interval = (start, end)<br></code></pre></td></tr></table></figure></li></ul><h3 id="2）哈希表-集合的键"><a href="#2）哈希表-集合的键" class="headerlink" title="2）哈希表&#x2F;集合的键"></a>2）哈希表&#x2F;集合的键</h3><ul><li>元组不可变，可作为字典或集合的键（常用于 visited 集合）：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">visited = <span class="hljs-built_in">set</span>()<br>visited.add((x, y))    <span class="hljs-comment"># 二维坐标去重</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="3）函数一次返回多个值"><a href="#3）函数一次返回多个值" class="headerlink" title="3）函数一次返回多个值"></a>3）函数一次返回多个值</h3>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">min_max</span>(<span class="hljs-params">nums</span>):<br>    <span class="hljs-keyword">return</span> (<span class="hljs-built_in">min</span>(nums), <span class="hljs-built_in">max</span>(nums))<br>mi, ma = min_max(arr)<br></code></pre></td></tr></table></figure><h3 id="4）遍历时解包"><a href="#4）遍历时解包" class="headerlink" title="4）遍历时解包"></a>4）遍历时解包</h3>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> x, y <span class="hljs-keyword">in</span> points:<br>    <span class="hljs-comment"># x, y为元组元素</span><br></code></pre></td></tr></table></figure><h3 id="5）与-enumerate-配合"><a href="#5）与-enumerate-配合" class="headerlink" title="5）与 enumerate 配合"></a>5）与 enumerate 配合</h3>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> i, num <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(nums):<br>    <span class="hljs-comment"># i是索引，num是值</span><br></code></pre></td></tr></table></figure><hr><h2 id="3-基本操作"><a href="#3-基本操作" class="headerlink" title="3. 基本操作"></a>3. 基本操作</h2><ul><li>访问元素：<code>t[0]</code></li><li>解包：<code>a, b = t</code></li><li>长度：<code>len(t)</code></li><li>遍历：<code>for x in t: ...</code></li></ul><hr><h2 id="4-其他"><a href="#4-其他" class="headerlink" title="4. 其他"></a>4. 其他</h2><ul><li>元组<strong>不可变</strong>，不能增删改</li><li>可嵌套元组，如 <code>((x1, y1), (x2, y2))</code></li></ul><hr><p>这些用法覆盖了 LeetCode 刷题最常见的元组场景，<br>如坐标去重、状态记录、批量返回等。</p><h1 id="Python-刷-LeetCode时常用的哈希表（dict）API"><a href="#Python-刷-LeetCode时常用的哈希表（dict）API" class="headerlink" title="Python 刷 LeetCode时常用的哈希表（dict）API"></a>Python 刷 LeetCode时常用的哈希表（dict）API</h1><hr><h2 id="1-创建哈希表（字典）"><a href="#1-创建哈希表（字典）" class="headerlink" title="1. 创建哈希表（字典）"></a>1. 创建哈希表（字典）</h2><ul><li>直接创建：<code>d = &#123;&#125;</code> 或 <code>d = &#123;&#39;a&#39;: 1, &#39;b&#39;: 2&#125;</code></li><li>用推导式：<code>d = &#123;x: x*x for x in nums&#125;</code></li></ul><hr><h2 id="2-访问和赋值"><a href="#2-访问和赋值" class="headerlink" title="2. 访问和赋值"></a>2. 访问和赋值</h2><ul><li>查找键值：<code>d[key]</code></li><li>新增或更新：<code>d[key] = value</code></li><li>安全查找（不存在返回默认值）：<code>d.get(key, default)</code><ul><li>如：<code>d.get(&#39;c&#39;, 0)</code>，如果’c’不存在则返回0</li></ul></li></ul><hr><h2 id="3-删除操作"><a href="#3-删除操作" class="headerlink" title="3. 删除操作"></a>3. 删除操作</h2><ul><li>删除键：<code>del d[key]</code></li><li>弹出并返回键值：<code>d.pop(key, default)</code>  <ul><li>如：<code>d.pop(&#39;a&#39;, 0)</code>，不存在则返回0</li></ul></li></ul><hr><h2 id="4-遍历哈希表"><a href="#4-遍历哈希表" class="headerlink" title="4. 遍历哈希表"></a>4. 遍历哈希表</h2><ul><li>遍历所有键：<code>for k in d:</code></li><li>遍历所有值：<code>for v in d.values():</code></li><li>遍历所有键值对：<code>for k, v in d.items():</code></li></ul><hr><h2 id="5-统计计数（高频）"><a href="#5-统计计数（高频）" class="headerlink" title="5. 统计计数（高频）"></a>5. 统计计数（高频）</h2><ul><li>用 <code>collections.Counter</code> 统计元素频次：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> Counter<br>freq = Counter(nums)<br><span class="hljs-comment"># freq[x] 即 x 的出现次数</span><br></code></pre></td></tr></table></figure></li></ul><hr><h2 id="6-默认值哈希表（高频）"><a href="#6-默认值哈希表（高频）" class="headerlink" title="6. 默认值哈希表（高频）"></a>6. 默认值哈希表（高频）</h2><ul><li>用 <code>collections.defaultdict</code> 自动初始化：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> defaultdict<br>d = defaultdict(<span class="hljs-built_in">int</span>)        <span class="hljs-comment"># 默认值为0</span><br>d2 = defaultdict(<span class="hljs-built_in">list</span>)      <span class="hljs-comment"># 默认值为[]</span><br>d[key] += <span class="hljs-number">1</span>                 <span class="hljs-comment"># 可直接累加计数</span><br></code></pre></td></tr></table></figure></li></ul><hr><h2 id="7-判断键是否存在"><a href="#7-判断键是否存在" class="headerlink" title="7. 判断键是否存在"></a>7. 判断键是否存在</h2><ul><li><code>if key in d:</code></li></ul><hr><h2 id="8-其他常用API"><a href="#8-其他常用API" class="headerlink" title="8. 其他常用API"></a>8. 其他常用API</h2><ul><li>键集合：<code>d.keys()</code></li><li>值集合：<code>d.values()</code></li><li>键值对集合：<code>d.items()</code></li><li>获取长度：<code>len(d)</code></li></ul><hr><h2 id="9-LeetCode常见题型应用"><a href="#9-LeetCode常见题型应用" class="headerlink" title="9. LeetCode常见题型应用"></a>9. LeetCode常见题型应用</h2><ul><li>计数统计：如“多数元素”“异位词”等</li><li>哈希去重：如“存在重复元素”</li><li>记录索引：如“两数之和”</li><li>滑动窗口：窗口内元素频次统计</li><li>状态记录：如“动态规划”状态压缩</li></ul><hr><p>以上API和技巧覆盖了 LeetCode 刷题哈希表的<strong>绝大多数场景</strong>，  </p><h1 id="Python-刷-LeetCode时常用的字符串API"><a href="#Python-刷-LeetCode时常用的字符串API" class="headerlink" title="Python 刷 LeetCode时常用的字符串API"></a>Python 刷 LeetCode时常用的字符串API</h1><hr><h2 id="1-创建和访问"><a href="#1-创建和访问" class="headerlink" title="1. 创建和访问"></a>1. 创建和访问</h2><ul><li>创建：<code>s = &quot;hello&quot;</code></li><li>访问：<code>s[0]</code>，<code>s[-1]</code>，<code>s[1:4]</code>（切片）</li></ul><hr><h2 id="2-遍历字符串"><a href="#2-遍历字符串" class="headerlink" title="2. 遍历字符串"></a>2. 遍历字符串</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> s:<br>    <span class="hljs-comment"># c是每个字符</span><br></code></pre></td></tr></table></figure><hr><h2 id="3-长度和查找"><a href="#3-长度和查找" class="headerlink" title="3. 长度和查找"></a>3. 长度和查找</h2><ul><li>长度：<code>len(s)</code></li><li>查找子串：<code>s.find(substr)</code>（找不到返回-1）</li><li>子串计数：<code>s.count(substr)</code></li><li>包含判断：<code>substr in s</code></li></ul><hr><h2 id="4-分割与拼接"><a href="#4-分割与拼接" class="headerlink" title="4. 分割与拼接"></a>4. 分割与拼接</h2><ul><li>分割：<code>s.split(sep)</code>（如空格、逗号等）</li><li>去除首尾空格：<code>s.strip()</code></li><li>拼接：<code>&#39; &#39;.join(list_of_str)</code>（用空格连接）</li></ul><hr><h2 id="5-替换与修改"><a href="#5-替换与修改" class="headerlink" title="5. 替换与修改"></a>5. 替换与修改</h2><ul><li>替换：<code>s.replace(old, new)</code></li><li>大小写转换：<code>s.lower()</code>，<code>s.upper()</code></li><li>判断字母&#x2F;数字：<code>s.isalpha()</code>，<code>s.isdigit()</code></li></ul><hr><h2 id="6-反转字符串"><a href="#6-反转字符串" class="headerlink" title="6. 反转字符串"></a>6. 反转字符串</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">s[::-<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><hr><h2 id="7-排序"><a href="#7-排序" class="headerlink" title="7. 排序"></a>7. 排序</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&#x27;&#x27;</span>.join(<span class="hljs-built_in">sorted</span>(s))   <span class="hljs-comment"># 字符排序后组成新字符串</span><br></code></pre></td></tr></table></figure><hr><h2 id="8-字符转数字与数字转字符"><a href="#8-字符转数字与数字转字符" class="headerlink" title="8. 字符转数字与数字转字符"></a>8. 字符转数字与数字转字符</h2><ul><li>字符转ASCII：<code>ord(c)</code></li><li>ASCII转字符：<code>chr(n)</code></li></ul><hr><h2 id="9-常见LeetCode题型场景"><a href="#9-常见LeetCode题型场景" class="headerlink" title="9. 常见LeetCode题型场景"></a>9. 常见LeetCode题型场景</h2><ul><li>字符计数：<code>collections.Counter(s)</code></li><li>判断回文：<code>s == s[::-1]</code></li><li>滑动窗口：用切片分割子串</li><li>异位词：<code>sorted(s1) == sorted(s2)</code></li></ul><hr><p>这些API和技巧覆盖了 LeetCode 字符串处理的<strong>高频场景</strong></p><h1 id="LeetCode常用数据结构转换（Python）"><a href="#LeetCode常用数据结构转换（Python）" class="headerlink" title="LeetCode常用数据结构转换（Python）"></a>LeetCode常用数据结构转换（Python）</h1><hr><h2 id="1-字符串和列表"><a href="#1-字符串和列表" class="headerlink" title="1. 字符串和列表"></a>1. 字符串和列表</h2><ul><li><p>字符串 → 列表（字符列表）  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">s = <span class="hljs-string">&quot;abcde&quot;</span><br>lst = <span class="hljs-built_in">list</span>(s)       <span class="hljs-comment"># [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;]</span><br></code></pre></td></tr></table></figure></li><li><p>列表 → 字符串  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">lst = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>]<br>s = <span class="hljs-string">&#x27;&#x27;</span>.join(lst)    <span class="hljs-comment"># &#x27;abc&#x27;</span><br></code></pre></td></tr></table></figure></li></ul><hr><h2 id="2-列表和集合"><a href="#2-列表和集合" class="headerlink" title="2. 列表和集合"></a>2. 列表和集合</h2><ul><li><p>列表 → 集合（去重&#x2F;查找快）  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">nums = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br>st = <span class="hljs-built_in">set</span>(nums)      <span class="hljs-comment"># &#123;1, 2, 3&#125;</span><br></code></pre></td></tr></table></figure></li><li><p>集合 → 列表  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">st = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<br>nums = <span class="hljs-built_in">list</span>(st)     <span class="hljs-comment"># [1, 2, 3]，顺序不保证</span><br></code></pre></td></tr></table></figure></li></ul><hr><h2 id="3-列表和元组"><a href="#3-列表和元组" class="headerlink" title="3. 列表和元组"></a>3. 列表和元组</h2><ul><li><p>列表 → 元组（不可变）  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">nums = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br>t = <span class="hljs-built_in">tuple</span>(nums)     <span class="hljs-comment"># (1, 2, 3)</span><br></code></pre></td></tr></table></figure></li><li><p>元组 → 列表  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">t = (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br>nums = <span class="hljs-built_in">list</span>(t)      <span class="hljs-comment"># [1, 2, 3]</span><br></code></pre></td></tr></table></figure></li></ul><hr><h2 id="4-字符串和集合"><a href="#4-字符串和集合" class="headerlink" title="4. 字符串和集合"></a>4. 字符串和集合</h2><ul><li>字符串 → 集合（唯一字符）  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">s = <span class="hljs-string">&quot;leetcode&quot;</span><br>st = <span class="hljs-built_in">set</span>(s)         <span class="hljs-comment"># &#123;&#x27;l&#x27;, &#x27;e&#x27;, &#x27;t&#x27;, &#x27;c&#x27;, &#x27;o&#x27;, &#x27;d&#x27;&#125;</span><br></code></pre></td></tr></table></figure></li></ul><hr><h2 id="5-列表和字典（或Counter）"><a href="#5-列表和字典（或Counter）" class="headerlink" title="5. 列表和字典（或Counter）"></a>5. 列表和字典（或Counter）</h2><ul><li><p>列表 → Counter（统计频次，非常高频）  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> Counter<br>nums = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br>counter = Counter(nums)   <span class="hljs-comment"># &#123;1:1, 2:2, 3:1&#125;</span><br></code></pre></td></tr></table></figure></li><li><p>列表 → 字典（如映射索引）  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">nums = [<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>]<br>idx_map = &#123;v: i <span class="hljs-keyword">for</span> i, v <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(nums)&#125;  <span class="hljs-comment"># &#123;10:0, 20:1, 30:2&#125;</span><br></code></pre></td></tr></table></figure></li></ul><hr><h2 id="6-字典和列表"><a href="#6-字典和列表" class="headerlink" title="6. 字典和列表"></a>6. 字典和列表</h2><ul><li><p>字典 → 键列表  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">d = &#123;<span class="hljs-string">&#x27;a&#x27;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;b&#x27;</span>: <span class="hljs-number">2</span>&#125;<br>keys = <span class="hljs-built_in">list</span>(d.keys())     <span class="hljs-comment"># [&#x27;a&#x27;, &#x27;b&#x27;]</span><br></code></pre></td></tr></table></figure></li><li><p>字典 → 值列表  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">values = <span class="hljs-built_in">list</span>(d.values()) <span class="hljs-comment"># [1, 2]</span><br></code></pre></td></tr></table></figure></li></ul><hr><h2 id="7-其他常用转换"><a href="#7-其他常用转换" class="headerlink" title="7. 其他常用转换"></a>7. 其他常用转换</h2><ul><li><p>二维列表 → 一维列表  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">grid = [[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]]<br>flat = [x <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> grid <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> row]   <span class="hljs-comment"># [1,2,3,4]</span><br></code></pre></td></tr></table></figure></li><li><p>列表元素类型转换  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">nums = [<span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>]<br>int_nums = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, nums))           <span class="hljs-comment"># [1, 2, 3]</span><br></code></pre></td></tr></table></figure></li></ul><hr><h2 id="8-应用场景举例"><a href="#8-应用场景举例" class="headerlink" title="8. 应用场景举例"></a>8. 应用场景举例</h2><ul><li>去重：列表 → 集合</li><li>统计频次：列表&#x2F;字符串 → Counter</li><li>索引映射：列表 → 字典</li><li>判断唯一性：<code>len(set(lst)) == len(lst)</code></li><li>恢复字符串：字符列表 → 字符串</li><li>枚举所有字符：字符串 → 列表&#x2F;集合</li></ul><hr><p>这些转换覆盖了 LeetCode 刷题<strong>绝大多数高频场景</strong></p><h1 id="Python-刷-LeetCode时常用的-range-API"><a href="#Python-刷-LeetCode时常用的-range-API" class="headerlink" title="Python 刷 LeetCode时常用的 range API"></a>Python 刷 LeetCode时常用的 range API</h1><hr><h2 id="1-基本用法"><a href="#1-基本用法" class="headerlink" title="1. 基本用法"></a>1. 基本用法</h2><ul><li><p><code>range(stop)</code><br>从0到stop-1  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>):    <span class="hljs-comment"># i = 0,1,2,3,4</span><br></code></pre></td></tr></table></figure></li><li><p><code>range(start, stop)</code><br>从start到stop-1  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>, <span class="hljs-number">6</span>): <span class="hljs-comment"># i = 2,3,4,5</span><br></code></pre></td></tr></table></figure></li><li><p><code>range(start, stop, step)</code><br>从start到stop-1，步长为step  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-number">10</span>, <span class="hljs-number">2</span>): <span class="hljs-comment"># i = 0,2,4,6,8</span><br></code></pre></td></tr></table></figure></li></ul><hr><h2 id="2-高频场景"><a href="#2-高频场景" class="headerlink" title="2. 高频场景"></a>2. 高频场景</h2><ul><li><p><strong>遍历数组&#x2F;字符串下标</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums)):<br>    <span class="hljs-comment"># nums[i]</span><br></code></pre></td></tr></table></figure></li><li><p><strong>倒序遍历</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums)-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br>    <span class="hljs-comment"># nums[i]</span><br></code></pre></td></tr></table></figure></li><li><p><strong>枚举区间（如滑动窗口）</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> l <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, n - k + <span class="hljs-number">1</span>):<br>    window = nums[l:l+k]<br></code></pre></td></tr></table></figure></li><li><p><strong>枚举所有二元组&#x2F;多元组</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i+<span class="hljs-number">1</span>, n):<br>        <span class="hljs-comment"># nums[i], nums[j]</span><br></code></pre></td></tr></table></figure></li><li><p><strong>生成列表（必须用list()）</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">lst = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>))    <span class="hljs-comment"># [0,1,2,3,4]</span><br></code></pre></td></tr></table></figure></li></ul><hr><h2 id="3-注意事项"><a href="#3-注意事项" class="headerlink" title="3. 注意事项"></a>3. 注意事项</h2><ul><li><code>range</code> 生成的是<strong>不可变序列</strong>，不是列表，要用 <code>list(range(...))</code> 转换成列表。</li><li>支持负步长，常用于倒序。</li><li>通常搭配 <code>for</code> 使用，也可直接转列表用于索引等。</li></ul><hr><h2 id="4-LeetCode题型常见用法总结"><a href="#4-LeetCode题型常见用法总结" class="headerlink" title="4. LeetCode题型常见用法总结"></a>4. LeetCode题型常见用法总结</h2><ul><li>遍历索引、枚举左&#x2F;右指针、滑动窗口、双指针、枚举排列组合等</li><li>需要索引时优先用 <code>range(len(...))</code></li><li>只遍历元素时推荐直接 <code>for x in ...</code>，如 <code>for x in nums:</code></li></ul><hr><h1 id="Python-刷-LeetCode时常用的集合（set）API"><a href="#Python-刷-LeetCode时常用的集合（set）API" class="headerlink" title="Python 刷 LeetCode时常用的集合（set）API"></a>Python 刷 LeetCode时常用的集合（set）API</h1><hr><h2 id="1-创建集合"><a href="#1-创建集合" class="headerlink" title="1. 创建集合"></a>1. 创建集合</h2><ul><li>空集合：<code>s = set()</code></li><li>由列表&#x2F;字符串创建：<code>s = set([1, 2, 3])</code>，<code>s = set(&#39;abc&#39;)</code></li></ul><hr><h2 id="2-常用操作"><a href="#2-常用操作" class="headerlink" title="2. 常用操作"></a>2. 常用操作</h2><ul><li>添加元素：<code>s.add(x)</code></li><li>删除元素：<code>s.remove(x)</code>（如果不存在会报错）</li><li>安全删除：<code>s.discard(x)</code>（不存在不报错）</li><li>判断元素是否存在：<code>x in s</code></li><li>集合大小：<code>len(s)</code></li><li>清空集合：<code>s.clear()</code></li></ul><hr><h2 id="3-高频LeetCode场景"><a href="#3-高频LeetCode场景" class="headerlink" title="3. 高频LeetCode场景"></a>3. 高频LeetCode场景</h2><ul><li><p><strong>去重</strong>：  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">nums = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br>unique = <span class="hljs-built_in">set</span>(nums)   <span class="hljs-comment"># &#123;1,2,3&#125;</span><br></code></pre></td></tr></table></figure></li><li><p><strong>哈希去重&#x2F;快速查找</strong>：  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> num <span class="hljs-keyword">in</span> seen:<br>    <span class="hljs-comment"># 已经出现过</span><br>seen.add(num)<br></code></pre></td></tr></table></figure></li><li><p><strong>记录访问状态</strong>（如BFS&#x2F;DFS&#x2F;回溯）：  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">visited = <span class="hljs-built_in">set</span>()<br>visited.add((x, y))  <span class="hljs-comment"># 二维坐标</span><br></code></pre></td></tr></table></figure></li><li><p><strong>集合运算</strong>（交集、并集、差集）：  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">s1 &amp; s2   <span class="hljs-comment"># 交集</span><br>s1 | s2   <span class="hljs-comment"># 并集</span><br>s1 - s2   <span class="hljs-comment"># 差集</span><br></code></pre></td></tr></table></figure></li></ul><hr><h2 id="4-遍历集合"><a href="#4-遍历集合" class="headerlink" title="4. 遍历集合"></a>4. 遍历集合</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> s:<br>    <span class="hljs-comment"># x是集合中的元素</span><br></code></pre></td></tr></table></figure><hr><h2 id="5-其他"><a href="#5-其他" class="headerlink" title="5. 其他"></a>5. 其他</h2><ul><li>集合元素必须是<strong>不可变类型</strong>（如数字、元组，不能是列表）</li><li>集合无序，不能索引访问</li></ul><hr><h2 id="6-常见题型应用"><a href="#6-常见题型应用" class="headerlink" title="6. 常见题型应用"></a>6. 常见题型应用</h2><ul><li>判断是否有重复元素</li><li>统计唯一元素个数</li><li>记录已访问节点&#x2F;状态</li><li>集合运算做筛选、计数等</li></ul><hr><p>这些API和技巧覆盖了 LeetCode 刷题绝大多数集合高频场景</p><h1 id="Python-刷-LeetCode时常用的-enumerate-用法"><a href="#Python-刷-LeetCode时常用的-enumerate-用法" class="headerlink" title="Python 刷 LeetCode时常用的 enumerate() 用法"></a>Python 刷 LeetCode时常用的 enumerate() 用法</h1><hr><h2 id="1-基本功能"><a href="#1-基本功能" class="headerlink" title="1. 基本功能"></a>1. 基本功能</h2><ul><li><code>enumerate(iterable)</code> 同时遍历元素和其索引（下标）。</li><li>返回一个迭代器，每次输出 <code>(索引, 元素)</code> 二元组。</li></ul><hr><h2 id="2-高频场景-1"><a href="#2-高频场景-1" class="headerlink" title="2. 高频场景"></a>2. 高频场景</h2><ul><li><p><strong>遍历列表&#x2F;字符串时要用下标和元素</strong>  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">nums = [<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>]<br><span class="hljs-keyword">for</span> i, x <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(nums):<br>    <span class="hljs-comment"># i 是索引（0,1,2），x 是值（10,20,30）</span><br></code></pre></td></tr></table></figure></li><li><p><strong>遍历二维数组时同时获得行号和行内容</strong>  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">matrix = [[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>], [<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]]<br><span class="hljs-keyword">for</span> i, row <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(matrix):<br>    <span class="hljs-comment"># i 是行号，row 是当前行</span><br></code></pre></td></tr></table></figure></li><li><p><strong>遍历字符串时获得索引和字符</strong>  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">s = <span class="hljs-string">&quot;leetcode&quot;</span><br><span class="hljs-keyword">for</span> i, c <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(s):<br>    <span class="hljs-comment"># i 是位置，c 是字符</span><br></code></pre></td></tr></table></figure></li></ul><hr><h2 id="3-带起始索引"><a href="#3-带起始索引" class="headerlink" title="3. 带起始索引"></a>3. 带起始索引</h2><ul><li><code>enumerate(iterable, start)</code> 可以指定索引起始值  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> i, x <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(nums, <span class="hljs-number">1</span>):<br>    <span class="hljs-comment"># i 从 1 开始计数</span><br></code></pre></td></tr></table></figure></li></ul><hr><h2 id="4-LeetCode题型常见应用"><a href="#4-LeetCode题型常见应用" class="headerlink" title="4. LeetCode题型常见应用"></a>4. LeetCode题型常见应用</h2><ul><li>统计、查找、标记索引</li><li>与哈希表结合记录元素位置</li><li>滑动窗口、双指针题型需要用到下标</li></ul><hr><h2 id="5-注意事项"><a href="#5-注意事项" class="headerlink" title="5. 注意事项"></a>5. 注意事项</h2><ul><li>通常写法为：<code>for i, x in enumerate(序列):</code></li><li>比 <code>for i in range(len(nums))</code> 更简洁、直观</li><li>适合需要同时用到索引和元素的场景</li></ul><hr><p>这些用法覆盖了 LeetCode 刷题绝大多数 <code>enumerate()</code> 高频场景</p><h1 id="Python-刷-LeetCode时常用的栈（stack）用法"><a href="#Python-刷-LeetCode时常用的栈（stack）用法" class="headerlink" title="Python 刷 LeetCode时常用的栈（stack）用法"></a>Python 刷 LeetCode时常用的栈（stack）用法</h1><hr><h2 id="1-栈的基本定义"><a href="#1-栈的基本定义" class="headerlink" title="1. 栈的基本定义"></a>1. 栈的基本定义</h2><ul><li>栈是一种**后进先出（LIFO）**的数据结构。</li><li>Python 没有专门的 stack 类型，通常用**列表（list）**实现。</li></ul><hr><h2 id="2-创建和基本操作"><a href="#2-创建和基本操作" class="headerlink" title="2. 创建和基本操作"></a>2. 创建和基本操作</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">stack = []        <span class="hljs-comment"># 创建空栈</span><br><br>stack.append(x)   <span class="hljs-comment"># 入栈</span><br>top = stack.pop() <span class="hljs-comment"># 出栈（弹出栈顶元素）</span><br>peek = stack[-<span class="hljs-number">1</span>]  <span class="hljs-comment"># 取栈顶元素（不弹出）</span><br></code></pre></td></tr></table></figure><hr><h2 id="3-高频LeetCode场景-1"><a href="#3-高频LeetCode场景-1" class="headerlink" title="3. 高频LeetCode场景"></a>3. 高频LeetCode场景</h2><ul><li><strong>括号匹配</strong>、<strong>逆序输出</strong>、<strong>单调栈</strong>、<strong>最近较大&#x2F;较小元素</strong>等题目</li><li>递归模拟</li><li>DFS（深度优先搜索）非递归写法</li></ul><hr><h2 id="4-单调栈模板"><a href="#4-单调栈模板" class="headerlink" title="4. 单调栈模板"></a>4. 单调栈模板</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">stack = []<br><span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> arr:<br>    <span class="hljs-keyword">while</span> stack <span class="hljs-keyword">and</span> x &lt; stack[-<span class="hljs-number">1</span>]:<br>        stack.pop()<br>    stack.append(x)<br></code></pre></td></tr></table></figure><ul><li>用于处理“下一个更小&#x2F;更大元素”问题</li></ul><hr><h2 id="5-判断栈空"><a href="#5-判断栈空" class="headerlink" title="5. 判断栈空"></a>5. 判断栈空</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> stack:<br>    <span class="hljs-comment"># 栈为空</span><br></code></pre></td></tr></table></figure><hr><h2 id="6-其他"><a href="#6-其他" class="headerlink" title="6. 其他"></a>6. 其他</h2><ul><li><code>collections.deque</code> 也可以当栈用，但 LeetCode 常用 list</li><li><code>stack.pop()</code> 若栈为空会抛异常，可用 <code>if stack:</code> 先判断</li><li>不要用 <code>insert(0, x)</code>&#x2F;<code>pop(0)</code>，那是队列操作</li></ul><hr><h2 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a>7. 总结</h2><ul><li>Python 用 list 实现栈，<code>append</code> 入栈，<code>pop</code> 出栈</li><li>高频题型：括号、单调栈、DFS等</li><li>适用于需要<strong>逆序处理</strong>或<strong>回溯</strong>的场景</li></ul><h1 id="Python-刷-LeetCode时常用的队列（queue）用法"><a href="#Python-刷-LeetCode时常用的队列（queue）用法" class="headerlink" title="Python 刷 LeetCode时常用的队列（queue）用法"></a>Python 刷 LeetCode时常用的队列（queue）用法</h1><hr><h2 id="1-队列的基本定义"><a href="#1-队列的基本定义" class="headerlink" title="1. 队列的基本定义"></a>1. 队列的基本定义</h2><ul><li>队列是一种**先进先出（FIFO）**的数据结构。</li><li>Python 标准库没有专门的 queue 类型，但常用这两种实现：<ul><li><code>collections.deque</code></li><li><code>queue.Queue</code>（多线程场景用）</li></ul></li></ul><hr><h2 id="2-用-list-实现队列（不推荐）"><a href="#2-用-list-实现队列（不推荐）" class="headerlink" title="2. 用 list 实现队列（不推荐）"></a>2. 用 list 实现队列（不推荐）</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">q = []<br>q.append(x)     <span class="hljs-comment"># 入队（到尾部）</span><br>x = q.pop(<span class="hljs-number">0</span>)    <span class="hljs-comment"># 出队（从头部）</span><br></code></pre></td></tr></table></figure><ul><li><strong>不推荐</strong>：<code>pop(0)</code> 时间复杂度 O(n)，慢！</li></ul><hr><h2 id="3-推荐用-deque-实现队列"><a href="#3-推荐用-deque-实现队列" class="headerlink" title="3. 推荐用 deque 实现队列"></a>3. 推荐用 deque 实现队列</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> deque<br><br>q = deque()<br>q.append(x)     <span class="hljs-comment"># 入队</span><br>x = q.popleft() <span class="hljs-comment"># 出队</span><br></code></pre></td></tr></table></figure><ul><li><code>popleft()</code> 时间复杂度 O(1)，高效！</li></ul><hr><h2 id="4-常见LeetCode题型"><a href="#4-常见LeetCode题型" class="headerlink" title="4. 常见LeetCode题型"></a>4. 常见LeetCode题型</h2><ul><li>BFS（广度优先搜索）模板</li><li>层序遍历</li><li>滑动窗口</li></ul><h3 id="BFS队列模板"><a href="#BFS队列模板" class="headerlink" title="BFS队列模板"></a>BFS队列模板</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> deque<br><br>q = deque()<br>q.append(start)<br>visited = <span class="hljs-built_in">set</span>([start])<br><br><span class="hljs-keyword">while</span> q:<br>    node = q.popleft()<br>    <span class="hljs-comment"># 扩展邻居</span><br>    <span class="hljs-keyword">for</span> nei <span class="hljs-keyword">in</span> graph[node]:<br>        <span class="hljs-keyword">if</span> nei <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> visited:<br>            q.append(nei)<br>            visited.add(nei)<br></code></pre></td></tr></table></figure><hr><h2 id="5-其他用法"><a href="#5-其他用法" class="headerlink" title="5. 其他用法"></a>5. 其他用法</h2><ul><li><code>len(q)</code> 获取队列长度</li><li><code>q[0]</code> 获取队首元素，不弹出</li><li><code>q.clear()</code> 清空队列</li></ul><hr><h2 id="6-多线程场景"><a href="#6-多线程场景" class="headerlink" title="6. 多线程场景"></a>6. 多线程场景</h2><ul><li>用 <code>queue.Queue</code> 更安全，支持线程同步</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> queue <span class="hljs-keyword">import</span> Queue<br><br>q = Queue()<br>q.put(x)      <span class="hljs-comment"># 入队</span><br>x = q.get()   <span class="hljs-comment"># 出队</span><br></code></pre></td></tr></table></figure><hr><h2 id="7-总结-1"><a href="#7-总结-1" class="headerlink" title="7. 总结"></a>7. 总结</h2><ul><li>刷题推荐用 <code>collections.deque</code> 实现队列</li><li><code>append</code> 入队，<code>popleft</code> 出队，O(1)效率</li><li>高频题型：BFS、层序遍历、滑动窗口</li></ul><h1 id="Python-any-及类似的聚合判断API介绍"><a href="#Python-any-及类似的聚合判断API介绍" class="headerlink" title="Python any() 及类似的聚合判断API介绍"></a>Python any() 及类似的聚合判断API介绍</h1><hr><h2 id="1-any"><a href="#1-any" class="headerlink" title="1. any()"></a>1. any()</h2><ul><li><strong>语法</strong>：<code>any(iterable)</code></li><li><strong>功能</strong>：只要迭代对象里有一个元素为真（bool(x) &#x3D;&#x3D; True），就返回 True；否则返回 False。</li><li><strong>刷题场景</strong>：判断是否“至少有一个”满足条件。</li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">nums = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>]<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">any</span>(nums))  <span class="hljs-comment"># True</span><br><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">any</span>(x &gt; <span class="hljs-number">10</span> <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> nums))  <span class="hljs-comment"># False</span><br></code></pre></td></tr></table></figure><hr><h2 id="2-all"><a href="#2-all" class="headerlink" title="2. all()"></a>2. all()</h2><ul><li><strong>语法</strong>：<code>all(iterable)</code></li><li><strong>功能</strong>：迭代对象所有元素都为真（bool(x) &#x3D;&#x3D; True）时，返回 True；否则返回 False。</li><li><strong>刷题场景</strong>：判断是否“全部”满足条件。</li></ul><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">nums = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">all</span>(nums))  <span class="hljs-comment"># True</span><br><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">all</span>(x &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> nums))  <span class="hljs-comment"># True</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">all</span>(x &gt; <span class="hljs-number">2</span> <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> nums))  <span class="hljs-comment"># False</span><br></code></pre></td></tr></table></figure><hr><h2 id="3-内置-max-min-sum"><a href="#3-内置-max-min-sum" class="headerlink" title="3. 内置 max(), min(), sum()"></a>3. 内置 max(), min(), sum()</h2><p>虽然不是布尔聚合，但常用于刷题中的“是否存在最大&#x2F;最小&#x2F;累加情况”。</p><ul><li><code>max(iterable)</code>: 返回最大值</li><li><code>min(iterable)</code>: 返回最小值</li><li><code>sum(iterable)</code>: 计算总和</li></ul><h3 id="配合条件判断"><a href="#配合条件判断" class="headerlink" title="配合条件判断"></a>配合条件判断</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">nums = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">max</span>(nums) &gt; <span class="hljs-number">2</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;有元素大于2&quot;</span>)<br></code></pre></td></tr></table></figure><hr><h2 id="4-filter"><a href="#4-filter" class="headerlink" title="4. filter()"></a>4. filter()</h2><ul><li><strong>语法</strong>：<code>filter(function, iterable)</code></li><li><strong>功能</strong>：筛选可迭代对象中满足 function 条件的元素。</li><li>常和 <code>any()</code>&#x2F;<code>all()</code> 配合判定“是否有满足条件的元素”。</li></ul><h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">nums = [<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0</span>]<br>positive_nums = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">filter</span>(<span class="hljs-keyword">lambda</span> x: x &gt; <span class="hljs-number">0</span>, nums))  <span class="hljs-comment"># [1, 3]</span><br></code></pre></td></tr></table></figure><hr><h2 id="5-内置-enumerate-zip-、map"><a href="#5-内置-enumerate-zip-、map" class="headerlink" title="5. 内置 enumerate(), zip()、map()"></a>5. 内置 enumerate(), zip()、map()</h2><p>这些不是布尔聚合，但常用于组合条件判断：</p><ul><li><code>enumerate(iterable)</code>: 获取索引和值</li><li><code>zip(a, b)</code>: 并行遍历</li><li><code>map(func, iterable)</code>: 批量映射</li></ul><h3 id="配合-any-all"><a href="#配合-any-all" class="headerlink" title="配合 any&#x2F;all"></a>配合 any&#x2F;all</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br>b = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>]<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">any</span>(x != y <span class="hljs-keyword">for</span> x, y <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(a, b)))  <span class="hljs-comment"># True, 判断是否有不相等的元素</span><br></code></pre></td></tr></table></figure><hr><h2 id="6-刷题常见场景举例"><a href="#6-刷题常见场景举例" class="headerlink" title="6. 刷题常见场景举例"></a>6. 刷题常见场景举例</h2><ul><li><strong>矩阵是否存在某个值</strong>：<code>any(val == target for row in matrix for val in row)</code></li><li><strong>全体条件满足</strong>：<code>all(x &gt;= 0 for x in nums)</code></li><li><strong>是否有重复</strong>：<code>any(nums.count(x) &gt; 1 for x in nums)</code> 或更高效用 <code>set</code></li></ul><hr><h2 id="7-其他相关函数"><a href="#7-其他相关函数" class="headerlink" title="7. 其他相关函数"></a>7. 其他相关函数</h2><ul><li><code>set()</code>: 去重后判定</li><li><code>sorted()</code>: 排序后判定</li></ul><hr><h2 id="8-总结对比"><a href="#8-总结对比" class="headerlink" title="8. 总结对比"></a>8. 总结对比</h2><table><thead><tr><th>API</th><th>判断逻辑</th><th>返回类型</th></tr></thead><tbody><tr><td>any()</td><td>至少有一个为真</td><td>bool</td></tr><tr><td>all()</td><td>全部都为真</td><td>bool</td></tr><tr><td>filter</td><td>返回符合条件的元素</td><td>可迭代对象</td></tr><tr><td>max&#x2F;min&#x2F;sum</td><td>聚合值</td><td>数值</td></tr></tbody></table><hr><blockquote><p>刷题时，<code>any()</code> 用于“存在性”判定，<code>all()</code> 用于“全体性”判定，经常和生成式搭配，写法简洁高效。</p></blockquote><h1 id="Python-的-reduce-用法介绍"><a href="#Python-的-reduce-用法介绍" class="headerlink" title="Python 的 reduce 用法介绍"></a>Python 的 <code>reduce</code> 用法介绍</h1><p><code>reduce</code> 是 Python 中一个用于将序列归约为单一值的高阶函数。它可以对序列中的元素进行累积计算，常用于累加、累乘等场景。</p><hr><h2 id="1-基本语法"><a href="#1-基本语法" class="headerlink" title="1. 基本语法"></a>1. 基本语法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> reduce<br><br>reduce(function, iterable[, initializer])<br></code></pre></td></tr></table></figure><ul><li><strong>function</strong>：二元函数（接受两个参数，如 lambda x, y: x + y）</li><li><strong>iterable</strong>：可迭代对象（如列表、元组等）</li><li><strong>initializer</strong>（可选）：指定初始值</li></ul><hr><h2 id="2-工作原理"><a href="#2-工作原理" class="headerlink" title="2. 工作原理"></a>2. 工作原理</h2><p><code>reduce</code> 会对序列的前两个元素调用函数，将结果与第三个元素继续调用函数，依次进行，直到序列处理完毕。</p><p>例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> reduce<br><br>result = reduce(<span class="hljs-keyword">lambda</span> x, y: x + y, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>])<br><span class="hljs-built_in">print</span>(result)  <span class="hljs-comment"># 输出 10</span><br></code></pre></td></tr></table></figure><p>过程：</p><ul><li>1 + 2 &#x3D; 3</li><li>3 + 3 &#x3D; 6</li><li>6 + 4 &#x3D; 10</li></ul><hr><h2 id="3-使用-initializer"><a href="#3-使用-initializer" class="headerlink" title="3. 使用 initializer"></a>3. 使用 initializer</h2><p>如果提供了 <code>initializer</code>，则它会作为第一次运算的左参数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">result = reduce(<span class="hljs-keyword">lambda</span> x, y: x + y, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], <span class="hljs-number">10</span>)<br><span class="hljs-built_in">print</span>(result)  <span class="hljs-comment"># 输出 16</span><br><span class="hljs-comment"># 10 + 1 = 11, 11 + 2 = 13, 13 + 3 = 16</span><br></code></pre></td></tr></table></figure><hr><h2 id="4-常见用途示例"><a href="#4-常见用途示例" class="headerlink" title="4. 常见用途示例"></a>4. 常见用途示例</h2><h3 id="累乘"><a href="#累乘" class="headerlink" title="累乘"></a>累乘</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> reduce<br>result = reduce(<span class="hljs-keyword">lambda</span> x, y: x * y, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>])<br><span class="hljs-built_in">print</span>(result)  <span class="hljs-comment"># 输出 24</span><br></code></pre></td></tr></table></figure><h3 id="拼接字符串"><a href="#拼接字符串" class="headerlink" title="拼接字符串"></a>拼接字符串</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">reduce(<span class="hljs-keyword">lambda</span> x, y: x + y, [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>])  <span class="hljs-comment"># 输出 &#x27;abc&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="求最大值"><a href="#求最大值" class="headerlink" title="求最大值"></a>求最大值</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">reduce(<span class="hljs-keyword">lambda</span> x, y: x <span class="hljs-keyword">if</span> x &gt; y <span class="hljs-keyword">else</span> y, [<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>])  <span class="hljs-comment"># 输出 5</span><br></code></pre></td></tr></table></figure><hr><h2 id="5-注意事项-1"><a href="#5-注意事项-1" class="headerlink" title="5. 注意事项"></a>5. 注意事项</h2><ul><li>如果序列为空且未指定 initializer，会报错。</li><li>许多简单场景可以用内置函数（如 <code>sum</code>, <code>max</code>）替代。</li><li><code>reduce</code> 在需要复杂归约时很有用。</li></ul><hr><h2 id="6-小结"><a href="#6-小结" class="headerlink" title="6. 小结"></a>6. 小结</h2><ul><li><code>reduce</code> 可以将序列归约为单一值。</li><li>适合累积、合并等复杂操作。</li><li>需要导入 <code>functools</code> 模块。</li></ul><hr><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>官方文档：<a href="https://docs.python.org/3/library/functools.html#functools.reduce">functools.reduce</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hot100整理</title>
    <link href="/2025/06/25/hot100%E6%95%B4%E7%90%86/"/>
    <url>/2025/06/25/hot100%E6%95%B4%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h3 id="hot100整理"><a href="#hot100整理" class="headerlink" title="hot100整理"></a>hot100整理</h3><h4 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h4><h5 id="最长连续序列"><a href="#最长连续序列" class="headerlink" title="最长连续序列"></a>最长连续序列</h5><blockquote><p>给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。<br>请你设计并实现时间复杂度为 O(n) 的算法解决此问题。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">longestConsecutive</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        Set&lt;Integer&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> num : nums)&#123;<br>            set.add(num);<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> num : set)&#123; <span class="hljs-comment">// 遍历set，否则超时</span><br>            <span class="hljs-keyword">if</span>(set.contains(num - <span class="hljs-number">1</span>))&#123; <span class="hljs-comment">// 从最小的开始</span><br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">last</span> <span class="hljs-operator">=</span> num + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span>(set.contains(last))&#123;<br>                last++;<br>            &#125;<br>            res = Math.max(res, last - num);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h4><h5 id="盛最多水的容器"><a href="#盛最多水的容器" class="headerlink" title="盛最多水的容器"></a>盛最多水的容器</h5><blockquote><p>给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。<br>找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。<br>返回容器可以储存的最大水量。<br>说明：你不能倾斜容器。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxArea</span><span class="hljs-params">(<span class="hljs-type">int</span>[] height)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = height.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(left &lt; right)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> Math.min(height[left], height[right]);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">w</span> <span class="hljs-operator">=</span> right - left;<br>            res = Math.max(res, h * w);<br>            <span class="hljs-keyword">if</span>(height[left] &lt; height[right])&#123;<br>                left++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                right--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a>三数之和</h5><blockquote><p>给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i !&#x3D; j、i !&#x3D; k 且 j !&#x3D; k ，同时还满足 nums[i] + nums[j] + nums[k] &#x3D;&#x3D; 0 。请你返回所有和为 0 且不重复的三元组。<br>注意：答案中不可以包含重复的三元组。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">threeSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        Arrays.sort(nums); <span class="hljs-comment">// 排序才能使用双指针</span><br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i] &gt; <span class="hljs-number">0</span>)&#123; <span class="hljs-comment">// 剪枝</span><br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>])&#123; <span class="hljs-comment">// 去重</span><br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> nums.length - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span>(left &lt; right)&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> nums[i] + nums[left] + nums[right];<br>                <span class="hljs-keyword">if</span>(sum &gt; <span class="hljs-number">0</span>)&#123;<br>                    right--;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sum &lt; <span class="hljs-number">0</span>)&#123;<br>                    left++;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    res.add(Arrays.asList(nums[i], nums[left], nums[right]));<br>                    <span class="hljs-comment">// 去重</span><br>                    <span class="hljs-keyword">while</span>(left &lt; right &amp;&amp; nums[left] == nums[left + <span class="hljs-number">1</span>])&#123;<br>                        left++;<br>                    &#125;<br>                    <span class="hljs-keyword">while</span>(left &lt; right &amp;&amp; nums[right] == nums[right - <span class="hljs-number">1</span>])&#123;<br>                        right--;<br>                    &#125;<br>                    left++;<br>                    right--;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="接雨水"><a href="#接雨水" class="headerlink" title="接雨水"></a>接雨水</h5><blockquote><p>给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">trap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] height)</span> &#123;<br>        <span class="hljs-comment">// 从栈顶到栈底单调递增，从而判断出凹槽</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> height.length;<br>        <span class="hljs-keyword">if</span>(len &lt;= <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>        Stack&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        stack.push(<span class="hljs-number">0</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; len; i++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">top</span> <span class="hljs-operator">=</span> stack.peek();<br>            <span class="hljs-keyword">while</span>(!stack.isEmpty() &amp;&amp; height[i] &gt; height[top])&#123; <span class="hljs-comment">// 出现凹槽</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> stack.pop();<br>                <span class="hljs-keyword">if</span>(!stack.isEmpty())&#123;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> stack.peek();<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> Math.min(height[left], height[i]) - height[mid];<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">w</span> <span class="hljs-operator">=</span> i - left - <span class="hljs-number">1</span>;<br>                    res += h * w;<br>                    top = stack.peek();<br>                &#125;<br>            &#125;<br>            stack.push(i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h4><h5 id="无重复字符的最长子串"><a href="#无重复字符的最长子串" class="headerlink" title="无重复字符的最长子串"></a>无重复字符的最长子串</h5><blockquote><p>给定一个字符串 s ，请你找出其中不含有重复字符的 最长 子串 的长度。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lengthOfLongestSubstring</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, fast = <span class="hljs-number">0</span>;<br>        Set&lt;Character&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br><br>        <span class="hljs-keyword">while</span>(fast &lt; s.length())&#123;<br>            <span class="hljs-keyword">if</span>(set.contains(s.charAt(fast)))&#123;<br>                <span class="hljs-keyword">while</span>(s.charAt(slow) != s.charAt(fast))&#123;<br>                    set.remove(s.charAt(slow));<br>                    slow++;<br>                &#125;<br>                slow++; <span class="hljs-comment">// 移动到重复字符后的第一位</span><br>                fast++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                set.add(s.charAt(fast));<br>                fast++;<br>            &#125; <br>            len = Math.max(len, fast - slow);<br>        &#125;<br>        <span class="hljs-keyword">return</span> len;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="找到字符串中所有字母异位词"><a href="#找到字符串中所有字母异位词" class="headerlink" title="找到字符串中所有字母异位词"></a>找到字符串中所有字母异位词</h5><blockquote><p>给定两个字符串 s 和 p，找到 s 中所有 p 的 异位词 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">findAnagrams</span><span class="hljs-params">(String s, String p)</span> &#123;<br>        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">if</span>(s.length() &lt; p.length())&#123;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br>        <span class="hljs-type">int</span>[] sCount = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">26</span>]; <span class="hljs-comment">// 利用小写字母特性</span><br>        <span class="hljs-type">int</span>[] pCount = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">26</span>];<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; p.length(); i++)&#123; <span class="hljs-comment">// 先看开头，初始化p</span><br>            sCount[s.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>            pCount[p.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(Arrays.equals(sCount, pCount))&#123;<br>            res.add(<span class="hljs-number">0</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> p.length(); i &lt; s.length(); i++)&#123;<br>            sCount[s.charAt(i - p.length()) - <span class="hljs-string">&#x27;a&#x27;</span>]--; <span class="hljs-comment">// 滑动窗口</span><br>            sCount[s.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>            <span class="hljs-keyword">if</span>(Arrays.equals(sCount, pCount))&#123;<br>                res.add(i - p.length() + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="子串"><a href="#子串" class="headerlink" title="子串"></a>子串</h4><h5 id="和为-K-的子数组"><a href="#和为-K-的子数组" class="headerlink" title="和为 K 的子数组"></a>和为 K 的子数组</h5><blockquote><p>给你一个整数数组 nums 和一个整数 k ，请你统计并返回 该数组中和为 k 的子数组的个数 。<br>子数组是数组中元素的连续非空序列。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">subarraySum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, preSum = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 哈希表的key为[0,i]之和（前缀和），value为有多少</span><br>        HashMap&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        map.put(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++)&#123;<br>            preSum += nums[i];<br>            <span class="hljs-comment">// 寻找有多少个nums[j]与num[i]的差值为k</span><br>            <span class="hljs-keyword">if</span>(map.containsKey(preSum - k))&#123;<br>                count += map.get(preSum - k);<br>            &#125;<br>            map.put(preSum, map.getOrDefault(preSum, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="滑动窗口最大值"><a href="#滑动窗口最大值" class="headerlink" title="滑动窗口最大值"></a>滑动窗口最大值</h5><blockquote><p>给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。<br>返回 滑动窗口中的最大值 。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyQueue</span> &#123; <span class="hljs-comment">// 该队列应当保证单调递减，相当于使用单调队列</span><br>    <span class="hljs-comment">// 单调队列保证最大值在离开滑动窗口前始终为里面的队首</span><br>    <span class="hljs-comment">// 而其后面出现的次大值不会消亡，在队首离开后成为最大值</span><br>    <span class="hljs-comment">// 其前面出现的次大值被最大值顶替，从而保证队首一定是最大值</span><br>    Deque&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">poll</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span>&#123; <span class="hljs-comment">// 只弹出最大值，其前面的值已消亡，其后面的值应当保留</span><br>        <span class="hljs-keyword">if</span>(!queue.isEmpty() &amp;&amp; val == queue.peek())&#123;<br>            queue.poll();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span>&#123; <span class="hljs-comment">// 消除前面的次大值，防止其到不了队首</span><br>        <span class="hljs-keyword">while</span>(!queue.isEmpty() &amp;&amp; val &gt; queue.getLast())&#123;<br>            queue.removeLast();<br>        &#125;<br>        queue.add(val);<br>    &#125;<br><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">peek</span><span class="hljs-params">()</span>&#123; <span class="hljs-comment">// 前面的操作让滑动窗口的最大值保持在队首</span><br>        <span class="hljs-keyword">return</span> queue.peek();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] maxSlidingWindow(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> nums.length - k + <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[len];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">MyQueue</span> <span class="hljs-variable">queue</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyQueue</span>();<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; k; i++)&#123; <span class="hljs-comment">// 初始化</span><br>            queue.add(nums[i]);<br>        &#125;<br>        res[index++] = queue.peek();<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> k; i &lt; nums.length; i++)&#123;<br>            queue.poll(nums[i - k]);<br>            queue.add(nums[i]);<br>            res[index++] = queue.peek();<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="最小覆盖子串"><a href="#最小覆盖子串" class="headerlink" title="最小覆盖子串"></a>最小覆盖子串</h5><blockquote><p>给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 “” 。<br>注意：<br>对于 t 中重复字符，我们寻找的子字符串中该字符数量必须不少于 t 中该字符数量。<br>如果 s 中存在这样的子串，我们保证它是唯一的答案。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">// 滑动窗口+哈希表</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">minWindow</span><span class="hljs-params">(String s, String t)</span> &#123;<br>        <span class="hljs-type">char</span>[] newS = s.toCharArray();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">resLeft</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">resRight</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">int</span>[] count = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">128</span>]; <span class="hljs-comment">// 记录字符哈希</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">remain</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 记录有哪些字母出现在t中</span><br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c : t.toCharArray())&#123;<br>            <span class="hljs-keyword">if</span>(count[c] == <span class="hljs-number">0</span>)&#123;<br>                remain++;<br>            &#125;<br>            count[c]++;<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(right &lt; s.length())&#123;<br>            <span class="hljs-comment">// 右指针移动添加元素</span><br>            <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> newS[right];<br>            count[c]--;<br>            <span class="hljs-keyword">if</span>(count[c] == <span class="hljs-number">0</span>)&#123; <span class="hljs-comment">// 这个字母在滑动窗口的数目与t中一致，remain减少以便于判断</span><br>                remain--;<br>            &#125;<br>            <br>            <span class="hljs-keyword">while</span>(remain == <span class="hljs-number">0</span>)&#123; <span class="hljs-comment">// 滑动窗口已出现所有字母，左指针移动</span><br>                <span class="hljs-keyword">if</span>(right - left &lt; resRight - resLeft)&#123;<br>                    resLeft = left;<br>                    resRight = right;<br>                &#125;<br>                c = newS[left];<br>                <span class="hljs-keyword">if</span>(count[c] == <span class="hljs-number">0</span>)&#123; <span class="hljs-comment">// 注意此时未出现在t中却出现在滑动窗口的字符count为负数</span><br>                    remain++;<br>                &#125;<br>                count[c]++;<br>                left++;<br>            &#125;<br>            <br>            right++;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> resLeft &lt; <span class="hljs-number">0</span> ? <span class="hljs-string">&quot;&quot;</span> : s.substring(resLeft, resRight + <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="普通数组"><a href="#普通数组" class="headerlink" title="普通数组"></a>普通数组</h4><h5 id="轮转数组"><a href="#轮转数组" class="headerlink" title="轮转数组"></a>轮转数组</h5><blockquote><p>给定一个整数数组 nums，将数组中的元素向右轮转 k 个位置，其中 k 是非负数。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rotate</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> nums.length;<br>        k %= len;<br>        <span class="hljs-comment">// 只需要反转三次即可</span><br>        reverse(nums, <span class="hljs-number">0</span>, len - <span class="hljs-number">1</span>);<br>        reverse(nums, <span class="hljs-number">0</span>, k - <span class="hljs-number">1</span>);<br>        reverse(nums, k, len - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reverse</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span>&#123;<br>        <span class="hljs-keyword">while</span>(i &lt; j)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> nums[j];<br>            nums[j] = nums[i];<br>            nums[i] = temp;<br>            i++;<br>            j--;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="除自身以外数组的乘积"><a href="#除自身以外数组的乘积" class="headerlink" title="除自身以外数组的乘积"></a>除自身以外数组的乘积</h5><blockquote><p>给你一个整数数组 nums，返回 数组 answer ，其中 answer[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积 。<br>题目数据 保证 数组 nums之中任意元素的全部前缀元素和后缀的乘积都在  32 位 整数范围内。<br>请 不要使用除法，且在 O(n) 时间复杂度内完成此题。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] productExceptSelf(<span class="hljs-type">int</span>[] nums) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[len];<br><br>        res[len - <span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> len - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--)&#123;<br>            res[i] = res[i + <span class="hljs-number">1</span>] * nums[i + <span class="hljs-number">1</span>]; <span class="hljs-comment">// 先计算后面所有数字的乘积</span><br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; len; i++)&#123;<br>            res[i] *= pre; <span class="hljs-comment">// 再乘上前面所有数字的乘积</span><br>            pre *= nums[i];<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="缺失的第一个正数"><a href="#缺失的第一个正数" class="headerlink" title="缺失的第一个正数"></a>缺失的第一个正数</h5><blockquote><p>给你一个未排序的整数数组 nums ，请你找出其中没有出现的最小的正整数。<br>请你实现时间复杂度为 O(n) 并且只使用常数级别额外空间的解决方案。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">firstMissingPositive</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; len; i++)&#123;<br>            <span class="hljs-comment">// 让数字1在下标0处，数字2在下标1处，以此类推</span><br>            <span class="hljs-keyword">while</span>(nums[i] &gt;= <span class="hljs-number">1</span> &amp;&amp; nums[i] &lt;= len &amp;&amp; nums[i] != nums[nums[i] - <span class="hljs-number">1</span>])&#123;<br>                <span class="hljs-comment">// 交换位置使其回到正确的位置上</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> nums[i] - <span class="hljs-number">1</span>;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> nums[i];<br>                nums[i] = nums[j];<br>                nums[j] = temp;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; len; i++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i] != i + <span class="hljs-number">1</span>)&#123; <span class="hljs-comment">// 第一个不匹配的位置就是答案</span><br>                <span class="hljs-keyword">return</span> i + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> len + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h4><h5 id="矩阵置零"><a href="#矩阵置零" class="headerlink" title="矩阵置零"></a>矩阵置零</h5><blockquote><p>给定一个 m x n 的矩阵，如果一个元素为 0 ，则将其所在行和列的所有元素都设为 0 。请使用 原地 算法。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setZeroes</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix)</span> &#123;<br>        <span class="hljs-comment">// 使用第一行和第一列来标志有无0</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> matrix.length, n = matrix[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">col0</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>, row0 = <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++)&#123;<br>            <span class="hljs-keyword">if</span>(matrix[i][<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>)&#123;<br>                col0 = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 表示第一列需要全0</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++)&#123;<br>            <span class="hljs-keyword">if</span>(matrix[<span class="hljs-number">0</span>][j] == <span class="hljs-number">0</span>)&#123;<br>                row0 = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 表示第一行需要全0</span><br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; m; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; n; j++)&#123;<br>                <span class="hljs-keyword">if</span>(matrix[i][j] == <span class="hljs-number">0</span>)&#123;<br>                    matrix[i][<span class="hljs-number">0</span>] = matrix[<span class="hljs-number">0</span>][j] = <span class="hljs-number">0</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; m; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; n; j++)&#123;<br>                <span class="hljs-keyword">if</span>(matrix[i][<span class="hljs-number">0</span>] == <span class="hljs-number">0</span> || matrix[<span class="hljs-number">0</span>][j] == <span class="hljs-number">0</span>)&#123;<br>                    matrix[i][j] = <span class="hljs-number">0</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(col0)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++)&#123;<br>                matrix[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(row0)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++)&#123;<br>                matrix[<span class="hljs-number">0</span>][j] = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="旋转图像"><a href="#旋转图像" class="headerlink" title="旋转图像"></a>旋转图像</h5><blockquote><p>给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。<br>你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rotate</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix)</span> &#123;<br>        <span class="hljs-comment">// 一次转置，一次行翻转即可</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> matrix.length;<br>        <span class="hljs-comment">// 转置</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; i; j++)&#123; <span class="hljs-comment">// 遍历对角线以下元素</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> matrix[i][j];<br>                matrix[i][j] = matrix[j][i];<br>                matrix[j][i] = temp;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 行翻转</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n / <span class="hljs-number">2</span>; j++)&#123; <span class="hljs-comment">// 遍历左半部分元素</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> matrix[i][j];<br>                matrix[i][j] = matrix[i][n - <span class="hljs-number">1</span> - j];<br>                matrix[i][n - <span class="hljs-number">1</span> - j] = temp;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="搜索二维矩阵-II"><a href="#搜索二维矩阵-II" class="headerlink" title="搜索二维矩阵 II"></a>搜索二维矩阵 II</h5><blockquote><p>编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target 。该矩阵具有以下特性：<br>每行的元素从左到右升序排列。<br>每列的元素从上到下升序排列。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">searchMatrix</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-comment">// 反复使用右上角元素排除</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> matrix[<span class="hljs-number">0</span>].length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(i &lt; matrix.length &amp;&amp; j &gt;= <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">if</span>(matrix[i][j] == target)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(matrix[i][j] &lt; target)&#123; <span class="hljs-comment">// 排除第一行</span><br>                i++;<br>            &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 排除最后一列</span><br>                j--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h4><h5 id="岛屿数量"><a href="#岛屿数量" class="headerlink" title="岛屿数量"></a>岛屿数量</h5><blockquote><p>给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。<br>岛屿总是被水包围，并且每座岛屿只能由水平方向和&#x2F;或竖直方向上相邻的陆地连接形成。<br>此外，你可以假设该网格的四条边均被水包围。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numIslands</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] grid)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; grid.length; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; grid[<span class="hljs-number">0</span>].length; j++)&#123;<br>                <span class="hljs-keyword">if</span>(grid[i][j] == <span class="hljs-string">&#x27;1&#x27;</span>)&#123; <span class="hljs-comment">// 未访问岛屿</span><br>                    dfs(grid, i, j); <span class="hljs-comment">// 将这个岛屿全部访问</span><br>                    res++;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] grid, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span>&#123;<br>        <span class="hljs-keyword">if</span>(i &lt; <span class="hljs-number">0</span> || i &gt;= grid.length || j &lt; <span class="hljs-number">0</span> || j &gt;= grid[<span class="hljs-number">0</span>].length || grid[i][j] != <span class="hljs-string">&#x27;1&#x27;</span>)&#123;<br>            <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 越界或者不是未访问岛屿</span><br>        &#125;<br>        grid[i][j] = <span class="hljs-string">&#x27;2&#x27;</span>; <span class="hljs-comment">// 2表示已访问岛屿</span><br>        <span class="hljs-comment">// 上下左右移动</span><br>        dfs(grid, i, j - <span class="hljs-number">1</span>);<br>        dfs(grid, i, j + <span class="hljs-number">1</span>);<br>        dfs(grid, i - <span class="hljs-number">1</span>, j);<br>        dfs(grid, i + <span class="hljs-number">1</span>, j);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="腐烂的橘子"><a href="#腐烂的橘子" class="headerlink" title="腐烂的橘子"></a>腐烂的橘子</h5><blockquote><p>在给定的 m x n 网格 grid 中，每个单元格可以有以下三个值之一：<br>值 0 代表空单元格；<br>值 1 代表新鲜橘子；<br>值 2 代表腐烂的橘子。<br>每分钟，腐烂的橘子 周围 4 个方向上相邻 的新鲜橘子都会腐烂。<br>返回 直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 -1 。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">// 记录移动的方向</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span>[][] DIRECTIONS = &#123;&#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;&#125;;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">orangesRotting</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        <br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> grid.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> grid[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">fresh</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 记录新鲜橘子数，以判断是否腐烂完</span><br>        List&lt;<span class="hljs-type">int</span>[]&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++)&#123;<br>                <span class="hljs-keyword">if</span>(grid[i][j] == <span class="hljs-number">1</span>)&#123;<br>                    fresh++;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(grid[i][j] == <span class="hljs-number">2</span>)&#123; <span class="hljs-comment">// 初始的腐烂的橘子</span><br>                    queue.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;i, j&#125;);<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 使用广度优先搜索bfs</span><br>        <span class="hljs-keyword">while</span>(fresh &gt; <span class="hljs-number">0</span> &amp;&amp; !queue.isEmpty())&#123;<br>            res++;<br>            List&lt;<span class="hljs-type">int</span>[]&gt; temp = queue;<br>            queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span>[] pos : temp)&#123; <span class="hljs-comment">// 遍历本层中已经腐烂的橘子</span><br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span>[] d : DIRECTIONS)&#123; <span class="hljs-comment">// 遍历方向</span><br>                    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> pos[<span class="hljs-number">0</span>] + d[<span class="hljs-number">0</span>];<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> pos[<span class="hljs-number">1</span>] + d[<span class="hljs-number">1</span>];<br>                    <span class="hljs-keyword">if</span>(i &gt;= <span class="hljs-number">0</span> &amp;&amp; i &lt; m &amp;&amp; j &gt;= <span class="hljs-number">0</span> &amp;&amp; j &lt; n &amp;&amp; grid[i][j] == <span class="hljs-number">1</span>)&#123; <span class="hljs-comment">// 新鲜橘子</span><br>                        fresh--;<br>                        grid[i][j] = <span class="hljs-number">2</span>;<br>                        queue.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;i, j&#125;); <span class="hljs-comment">// 新的一层中腐烂的橘子</span><br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> fresh &gt; <span class="hljs-number">0</span> ? -<span class="hljs-number">1</span> : res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="课程表"><a href="#课程表" class="headerlink" title="课程表"></a>课程表</h5><blockquote><p>你这个学期必须选修 numCourses 门课程，记为 0 到 numCourses - 1 。<br>在选修某些课程之前需要一些先修课程。 先修课程按数组 prerequisites 给出，其中 prerequisites[i] &#x3D; [ai, bi] ，表示如果要学习课程 ai 则 必须 先学习课程  bi 。<br>例如，先修课程对 [0, 1] 表示：想要学习课程 0 ，你需要先完成课程 1 。<br>请你判断是否可能完成所有课程的学习？如果可以，返回 true ；否则，返回 false 。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canFinish</span><span class="hljs-params">(<span class="hljs-type">int</span> numCourses, <span class="hljs-type">int</span>[][] prerequisites)</span> &#123;<br>        <span class="hljs-comment">// 拓扑排序，其实就是判断该有向图是否存在环</span><br>        <span class="hljs-comment">// 使用三色标记法</span><br>        <span class="hljs-comment">// 0：未被访问</span><br>        <span class="hljs-comment">// 1：正在访问，dfs未结束</span><br>        <span class="hljs-comment">// 2：已访问，dfs已返回</span><br>        List&lt;Integer&gt;[] graph = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>[numCourses];<br>        Arrays.setAll(graph, i -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;());<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span>[] pre : prerequisites)&#123;<br>            graph[pre[<span class="hljs-number">1</span>]].add(pre[<span class="hljs-number">0</span>]); <span class="hljs-comment">// 使用链表表示该图</span><br>        &#125;<br><br>        <span class="hljs-type">int</span>[] colors = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[numCourses];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; numCourses; i++)&#123;<br>            <span class="hljs-keyword">if</span>(colors[i] == <span class="hljs-number">0</span> &amp;&amp; dfs(i, graph, colors))&#123; <span class="hljs-comment">// 对未访问节点进行深度优先搜索</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 存在环，无法排序</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 无环，可以排序</span><br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x, List&lt;Integer&gt;[] graph, <span class="hljs-type">int</span>[] colors)</span>&#123;<br>        colors[x] = <span class="hljs-number">1</span>; <span class="hljs-comment">// 正在访问</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> y : graph[x])&#123;<br>            <span class="hljs-keyword">if</span>(colors[y] == <span class="hljs-number">1</span> || (colors[y] == <span class="hljs-number">0</span> &amp;&amp; dfs(y, graph, colors)))&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 找到环</span><br>            &#125;<br>        &#125;<br>        colors[x] = <span class="hljs-number">2</span>; <span class="hljs-comment">// 返回</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="实现-Trie-前缀树"><a href="#实现-Trie-前缀树" class="headerlink" title="实现 Trie (前缀树)"></a>实现 Trie (前缀树)</h5><blockquote><p>Trie（发音类似 “try”）或者说 前缀树 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补全和拼写检查。<br>请你实现 Trie 类：<br>Trie() 初始化前缀树对象。<br>void insert(String word) 向前缀树中插入字符串 word 。<br>boolean search(String word) 如果字符串 word 在前缀树中，返回 true（即，在检索之前已经插入）；否则，返回 false 。<br>boolean startsWith(String prefix) 如果之前已经插入的字符串 word 的前缀之一为 prefix ，返回 true ；否则，返回 false 。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Trie</span> &#123; <span class="hljs-comment">// 26叉树</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&#123;<br>        Node[] son = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>[<span class="hljs-number">26</span>];<br>        <span class="hljs-type">boolean</span> end; <span class="hljs-comment">// end表示其前缀组成了一个插入的单词</span><br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Trie</span><span class="hljs-params">()</span> &#123;<br>        <br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(String word)</span> &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> root;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c : word.toCharArray())&#123;<br>            c -= <span class="hljs-string">&#x27;a&#x27;</span>;<br>            <span class="hljs-keyword">if</span>(cur.son[c] == <span class="hljs-literal">null</span>)&#123; <span class="hljs-comment">// 插入</span><br>                cur.son[c] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>();<br>            &#125;<br>            cur = cur.son[c];<br>        &#125;<br>        cur.end = <span class="hljs-literal">true</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">search</span><span class="hljs-params">(String word)</span> &#123;<br>        <span class="hljs-keyword">return</span> find(word) == <span class="hljs-number">2</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">startsWith</span><span class="hljs-params">(String prefix)</span> &#123;<br>        <span class="hljs-keyword">return</span> find(prefix) != <span class="hljs-number">0</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">find</span><span class="hljs-params">(String word)</span>&#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> root;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c : word.toCharArray())&#123;<br>            c -= <span class="hljs-string">&#x27;a&#x27;</span>;<br>            <span class="hljs-keyword">if</span>(cur.son[c] == <span class="hljs-literal">null</span>)&#123; <span class="hljs-comment">// 没找到</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>            &#125; cur = cur.son[c];<br>        &#125;<br>        <span class="hljs-comment">// 找到，判断是否是完整的单词</span><br>        <span class="hljs-keyword">return</span> cur.end ? <span class="hljs-number">2</span> : <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your Trie object will be instantiated and called as such:</span><br><span class="hljs-comment"> * Trie obj = new Trie();</span><br><span class="hljs-comment"> * obj.insert(word);</span><br><span class="hljs-comment"> * boolean param_2 = obj.search(word);</span><br><span class="hljs-comment"> * boolean param_3 = obj.startsWith(prefix);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h4 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h4><h5 id="括号生成"><a href="#括号生成" class="headerlink" title="括号生成"></a>括号生成</h5><blockquote><p>数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;String&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-comment">// path记录左括号的索引</span><br>    List&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">generateParenthesis</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        backtracking(n, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-comment">// balance等于左括号减右括号</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> idx, <span class="hljs-type">int</span> balance)</span>&#123;<br>        <span class="hljs-keyword">if</span>(path.size() == n)&#123;<br>            <span class="hljs-type">char</span>[] temp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[<span class="hljs-number">2</span> * n];<br>            Arrays.fill(temp, <span class="hljs-string">&#x27;)&#x27;</span>);<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i : path)&#123;<br>                temp[i] = <span class="hljs-string">&#x27;(&#x27;</span>;<br>            &#125;<br>            res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(temp));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 先填i个右括号，再填一个左括号，idx - 1为上一个左括号的下标</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= balance; i++)&#123;<br>            path.add(idx + i);<br>            backtracking(n, idx + i + <span class="hljs-number">1</span>, balance - i + <span class="hljs-number">1</span>);<br>            path.removeLast();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="单词搜索"><a href="#单词搜索" class="headerlink" title="单词搜索"></a>单词搜索</h5><blockquote><p>给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。<br>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span>[][] direction = &#123;&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;&#125;;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">exist</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] board, String word)</span> &#123;<br>        <span class="hljs-type">char</span>[] w = word.toCharArray();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; board.length; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; board[<span class="hljs-number">0</span>].length; j++)&#123;<br>                <span class="hljs-keyword">if</span>(backtracking(i, j, <span class="hljs-number">0</span>, board, w))&#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span> k, <span class="hljs-type">char</span>[][] board, <span class="hljs-type">char</span>[] word)</span>&#123;<br>        <span class="hljs-keyword">if</span>(board[i][j] != word[k])&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 不匹配，回溯</span><br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(k == word.length - <span class="hljs-number">1</span>)&#123; <span class="hljs-comment">// 这里减一是因为前面确定了最后一位是匹配的</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        board[i][j] = <span class="hljs-number">0</span>; <span class="hljs-comment">// 标记为已访问过</span><br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span>[] dir : direction)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> i + dir[<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> j + dir[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span>(x &gt;= <span class="hljs-number">0</span> &amp;&amp; x &lt; board.length &amp;&amp; y &gt;= <span class="hljs-number">0</span> &amp;&amp; y &lt; board[<span class="hljs-number">0</span>].length &amp;&amp; backtracking(x, y, k + <span class="hljs-number">1</span>, board, word))&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 已找到</span><br>            &#125;<br>        &#125;<br><br>        board[i][j] = word[k]; <span class="hljs-comment">// 恢复</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="N皇后"><a href="#N皇后" class="headerlink" title="N皇后"></a>N皇后</h5><blockquote><p>按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。<br>n 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。<br>给你一个整数 n ，返回所有不同的 n 皇后问题 的解决方案。<br>每一种解法包含一个不同的 n 皇后问题 的棋子放置方案，该方案中 ‘Q’ 和 ‘.’ 分别代表了皇后和空位。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;String&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-type">boolean</span>[] usedCol, used45, used135;<br><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="hljs-title function_">solveNQueens</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        usedCol = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n]; <span class="hljs-comment">// 保证不在同一列</span><br>        used45 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[<span class="hljs-number">2</span> * n + <span class="hljs-number">1</span>]; <span class="hljs-comment">// 保证不在45度斜线内</span><br>        used135 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[<span class="hljs-number">2</span> * n + <span class="hljs-number">1</span>]; <span class="hljs-comment">// 保证不在135度斜线内</span><br>        <span class="hljs-comment">// 收集结果</span><br>        <span class="hljs-type">int</span>[] board = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        backtracking(board, n, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-comment">// 使用行来回溯</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span>[] board, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> row)</span>&#123;<br>        <span class="hljs-keyword">if</span>(row == n)&#123;<br>            <span class="hljs-comment">// 解释结果</span><br>            List&lt;String&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i : board)&#123;<br>                <span class="hljs-type">char</span>[] str = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[n];<br>                Arrays.fill(str, <span class="hljs-string">&#x27;.&#x27;</span>);<br>                str[i] = <span class="hljs-string">&#x27;Q&#x27;</span>;<br>                path.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(str));<br>            &#125;<br>            res.add(path);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">col</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; col &lt; n; col++)&#123;<br>            <span class="hljs-keyword">if</span>(usedCol[col] || used45[row + col] || used135[n - <span class="hljs-number">1</span> - col + row])&#123; <span class="hljs-comment">// 不在同一列和同一斜线上</span><br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            board[row] = col;<br>            usedCol[col] = <span class="hljs-literal">true</span>;<br>            used45[row + col] = <span class="hljs-literal">true</span>;<br>            used135[n - <span class="hljs-number">1</span> - col + row] = <span class="hljs-literal">true</span>;<br>            backtracking(board, n, row + <span class="hljs-number">1</span>);<br>            usedCol[col] = <span class="hljs-literal">false</span>;<br>            used45[row + col] = <span class="hljs-literal">false</span>;<br>            used135[n - <span class="hljs-number">1</span> - col + row] = <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><h5 id="最小栈"><a href="#最小栈" class="headerlink" title="最小栈"></a>最小栈</h5><blockquote><p>设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。<br>实现 MinStack 类:<br>MinStack() 初始化堆栈对象。<br>void push(int val) 将元素val推入堆栈。<br>void pop() 删除堆栈顶部的元素。<br>int top() 获取堆栈顶部的元素。<br>int getMin() 获取堆栈中的最小元素。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MinStack</span> &#123;<br>    <span class="hljs-comment">// 成对保存每个元素，前者为栈中元素，后者为对应的前缀最小值</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Deque&lt;<span class="hljs-type">int</span>[]&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MinStack</span><span class="hljs-params">()</span> &#123;<br>        stack.push(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0</span>, Integer.MAX_VALUE&#125;);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> &#123;<br>        stack.push(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;val, Math.min(getMin(), val)&#125;);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> &#123;<br>        stack.pop();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">top</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> stack.peek()[<span class="hljs-number">0</span>];<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getMin</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> stack.peek()[<span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MinStack object will be instantiated and called as such:</span><br><span class="hljs-comment"> * MinStack obj = new MinStack();</span><br><span class="hljs-comment"> * obj.push(val);</span><br><span class="hljs-comment"> * obj.pop();</span><br><span class="hljs-comment"> * int param_3 = obj.top();</span><br><span class="hljs-comment"> * int param_4 = obj.getMin();</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h5 id="字符串解码"><a href="#字符串解码" class="headerlink" title="字符串解码"></a>字符串解码</h5><blockquote><p>给定一个经过编码的字符串，返回它解码后的字符串。<br>编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。<br>你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。<br>此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">decodeString</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        LinkedList&lt;Integer&gt; stack_num = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        LinkedList&lt;String&gt; stack_char = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c : s.toCharArray())&#123;<br>            <span class="hljs-keyword">if</span>(c == <span class="hljs-string">&#x27;[&#x27;</span>)&#123; <span class="hljs-comment">// 入栈</span><br>                stack_num.add(num); <span class="hljs-comment">// 栈顶数字用于翻倍res</span><br>                stack_char.add(res.toString()); <span class="hljs-comment">// 栈底元素为空</span><br>                num = <span class="hljs-number">0</span>;<br>                res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(c == <span class="hljs-string">&#x27;]&#x27;</span>)&#123; <span class="hljs-comment">// 出栈</span><br>                <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">cur_res</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>                <span class="hljs-type">int</span> <span class="hljs-variable">cur_num</span> <span class="hljs-operator">=</span> stack_num.removeLast();<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; cur_num; i++)&#123;<br>                    cur_res.append(res);<br>                &#125;<br>                res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(stack_char.removeLast() + cur_res);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(c &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="hljs-string">&#x27;9&#x27;</span>)&#123; <span class="hljs-comment">// 数字</span><br>                num = num * <span class="hljs-number">10</span> + Integer.parseInt(c + <span class="hljs-string">&quot;&quot;</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 字母</span><br>                res.append(c);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res.toString();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
      <category>hot100</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>hot100</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>代码随想录之单调栈</title>
    <link href="/2025/06/24/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E4%B9%8B%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    <url>/2025/06/24/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E4%B9%8B%E5%8D%95%E8%B0%83%E6%A0%88/</url>
    
    <content type="html"><![CDATA[<h2 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h2><h3 id="每日温度"><a href="#每日温度" class="headerlink" title="每日温度"></a>每日温度</h3><blockquote><p>给定一个整数数组 temperatures ，表示每天的温度，返回一个数组 answer ，其中 answer[i] 是指对于第 i 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 0 来代替。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] dailyTemperatures(<span class="hljs-type">int</span>[] temperatures) &#123;<br>        <span class="hljs-comment">// 从栈顶到栈底，保持递增顺序，从而求得右边更大的数字</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> temperatures.length;<br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[len];<br>        Deque&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; len; i++)&#123;<br>            <span class="hljs-keyword">while</span>(!stack.isEmpty() &amp;&amp; temperatures[i] &gt; temperatures[stack.peek()])&#123;<br>                res[stack.peek()] = i - stack.peek();<br>                stack.pop();<br>            &#125;<br>            stack.push(i);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="下一个更大元素-I"><a href="#下一个更大元素-I" class="headerlink" title="下一个更大元素 I"></a>下一个更大元素 I</h4><blockquote><p>nums1 中数字 x 的 下一个更大元素 是指 x 在 nums2 中对应位置 右侧 的 第一个 比 x 大的元素。<br>给你两个 没有重复元素 的数组 nums1 和 nums2 ，下标从 0 开始计数，其中nums1 是 nums2 的子集。<br>对于每个 0 &lt;&#x3D; i &lt; nums1.length ，找出满足 nums1[i] &#x3D;&#x3D; nums2[j] 的下标 j ，并且在 nums2 确定 nums2[j] 的 下一个更大元素 。如果不存在下一个更大元素，那么本次查询的答案是 -1 。<br>返回一个长度为 nums1.length 的数组 ans 作为答案，满足 ans[i] 是如上所述的 下一个更大元素 。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] nextGreaterElement(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span>[] nums2) &#123;<br>        HashMap&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums1.length; i++)&#123;<br>            map.put(nums1[i], i);<br>        &#125;<br><br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums1.length];<br>        Stack&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        Arrays.fill(res, -<span class="hljs-number">1</span>);<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums2.length; i++)&#123;<br>            <span class="hljs-keyword">while</span>(!stack.isEmpty() &amp;&amp; nums2[stack.peek()] &lt; nums2[i])&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> nums2[stack.pop()];<br>                <span class="hljs-keyword">if</span>(map.containsKey(prev))&#123;<br>                    res[map.get(prev)] = nums2[i];<br>                &#125;<br>            &#125;<br>            stack.push(i);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="接雨水"><a href="#接雨水" class="headerlink" title="接雨水"></a>接雨水</h3><blockquote><p>给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">trap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] height)</span> &#123;<br>        <span class="hljs-comment">// 从栈顶到栈底单调递增，从而判断出凹槽</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> height.length;<br>        <span class="hljs-keyword">if</span>(len &lt;= <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>        Stack&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        stack.push(<span class="hljs-number">0</span>);<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; len; i++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">top</span> <span class="hljs-operator">=</span> stack.peek();<br>            <span class="hljs-keyword">if</span>(height[i] &lt; height[top])&#123; <span class="hljs-comment">// 小于栈顶，压入栈</span><br>                stack.push(i);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(height[i] == height[top])&#123; <span class="hljs-comment">// 等于栈顶，更新栈顶</span><br>                stack.pop();<br>                stack.push(i);<br>            &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 大于栈顶，出现凹槽，进行计算</span><br>                <span class="hljs-keyword">while</span>(!stack.isEmpty() &amp;&amp; height[i] &gt; height[top])&#123;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> stack.pop(); <span class="hljs-comment">// 凹槽地板</span><br>                    <span class="hljs-keyword">if</span>(!stack.isEmpty())&#123;<br>                        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> stack.peek(); <span class="hljs-comment">// 左边的第一根柱子，i为右边的柱子</span><br>                        <span class="hljs-type">int</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> Math.min(height[left], height[i]) - height[mid];<br>                        <span class="hljs-type">int</span> <span class="hljs-variable">w</span> <span class="hljs-operator">=</span> i - left - <span class="hljs-number">1</span>;<br>                        sum += h * w;<br>                        top = stack.peek(); <span class="hljs-comment">// 更新</span><br>                    &#125;<br>                &#125;<br>                stack.push(i);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="柱状图中最大的矩形"><a href="#柱状图中最大的矩形" class="headerlink" title="柱状图中最大的矩形"></a>柱状图中最大的矩形</h4><blockquote><p>给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。<br>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">largestRectangleArea</span><span class="hljs-params">(<span class="hljs-type">int</span>[] heights)</span> &#123;<br>        <span class="hljs-comment">// 遇到矮的柱子就计算，故从栈顶到栈底是单调递减的</span><br>        <span class="hljs-type">int</span>[] newHeight = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[heights.length + <span class="hljs-number">2</span>];<br>        System.arraycopy(heights, <span class="hljs-number">0</span>, newHeight, <span class="hljs-number">1</span>, heights.length);<br>        newHeight[heights.length + <span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>        newHeight[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br><br>        Stack&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        stack.push(<span class="hljs-number">0</span>);<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; newHeight.length; i++)&#123;<br>            <span class="hljs-keyword">while</span>(newHeight[i] &lt; newHeight[stack.peek()])&#123; <span class="hljs-comment">// 注意i在这里不变，因此宽是正确的</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> stack.pop();<br>                <span class="hljs-type">int</span> <span class="hljs-variable">w</span> <span class="hljs-operator">=</span> i - stack.peek() - <span class="hljs-number">1</span>;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> newHeight[mid];<br>                res = Math.max(res, h * w);<br>            &#125;<br>            stack.push(i);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
      <category>代码随想录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>代码随想录之动态规划</title>
    <link href="/2025/06/19/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E4%B9%8B%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <url>/2025/06/19/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E4%B9%8B%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    
    <content type="html"><![CDATA[<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><h3 id="爬楼梯"><a href="#爬楼梯" class="headerlink" title="爬楼梯"></a>爬楼梯</h3><blockquote><p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。<br>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p></blockquote><p>动态规划五步走：确定dp数组及下标含义-&gt;确定递推公式-&gt;dp数组初始化-&gt;遍历顺序-&gt;举例推导</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">climbStairs</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-comment">// 等效于斐波拉契数列</span><br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt;= n; i++)&#123;<br>            dp[i] = dp[i - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">2</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="使用最小花费爬楼梯"><a href="#使用最小花费爬楼梯" class="headerlink" title="使用最小花费爬楼梯"></a>使用最小花费爬楼梯</h4><blockquote><p>给你一个整数数组 cost ，其中 cost[i] 是从楼梯第 i 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。<br>你可以选择从下标为 0 或下标为 1 的台阶开始爬楼梯。<br>请你计算并返回达到楼梯顶部的最低花费。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minCostClimbingStairs</span><span class="hljs-params">(<span class="hljs-type">int</span>[] cost)</span> &#123;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[cost.length + <span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt;= cost.length; i++)&#123;<br>            dp[i] = Math.min(dp[i - <span class="hljs-number">1</span>] + cost[i - <span class="hljs-number">1</span>], dp[i - <span class="hljs-number">2</span>] + cost[i - <span class="hljs-number">2</span>]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[cost.length];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="不同路径"><a href="#不同路径" class="headerlink" title="不同路径"></a>不同路径</h3><blockquote><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。<br>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。<br>问总共有多少条不同的路径？</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">uniquePaths</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m][n];<br>        <span class="hljs-comment">// 初始化，一般为边界</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++)&#123;<br>            dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++)&#123;<br>            dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; m; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; n; j++)&#123;<br>                dp[i][j] = dp[i - <span class="hljs-number">1</span>][j] + dp[i][j - <span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> dp[m - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="不同路径-II"><a href="#不同路径-II" class="headerlink" title="不同路径 II"></a>不同路径 II</h4><blockquote><p>给定一个 m x n 的整数数组 grid。一个机器人初始位于 左上角（即 grid[0][0]）。机器人尝试移动到 右下角（即 grid[m - 1][n - 1]）。机器人每次只能向下或者向右移动一步。<br>网格中的障碍物和空位置分别用 1 和 0 来表示。机器人的移动路径中不能包含 任何 有障碍物的方格。<br>返回机器人能够到达右下角的不同路径数量。<br>测试用例保证答案小于等于 2 * 109。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">uniquePathsWithObstacles</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] obstacleGrid)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> obstacleGrid.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> obstacleGrid[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m][n];<br><br>        <span class="hljs-comment">// 起点或终点有障碍，直接返回0</span><br>        <span class="hljs-keyword">if</span>(obstacleGrid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] == <span class="hljs-number">1</span> || obstacleGrid[m - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>] == <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 初始化边界，注意一旦遇到障碍就结束</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m &amp;&amp; obstacleGrid[i][<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>; i++)&#123;<br>            dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n &amp;&amp; obstacleGrid[<span class="hljs-number">0</span>][j] == <span class="hljs-number">0</span>; j++)&#123;<br>            dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; m; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; n; j++)&#123;<br>                <span class="hljs-comment">// 障碍物保持初始化为0</span><br>                <span class="hljs-keyword">if</span>(obstacleGrid[i][j] == <span class="hljs-number">0</span>)&#123;<br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j] + dp[i][j - <span class="hljs-number">1</span>];<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> dp[m - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="整数拆分"><a href="#整数拆分" class="headerlink" title="整数拆分"></a>整数拆分</h3><blockquote><p>给定一个正整数 n ，将其拆分为 k 个 正整数 的和（ k &gt;&#x3D; 2 ），并使这些整数的乘积最大化。<br>返回 你可以获得的最大乘积 。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">integerBreak</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-comment">// dp[i] 为数字i拆分后的最大乘积</span><br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">2</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>; i &lt;= n; i++)&#123;<br>            <span class="hljs-comment">// 因为大于i - j也只是在重复，同时避免使用到dp[0]和dp[1]</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= i - j; j++)&#123;<br>                <span class="hljs-comment">// 其实就是拆不拆i - j地问题</span><br>                dp[i] = Math.max(dp[i], j * Math.max( (i - j), dp[i - j]));<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="不同的二叉搜索树"><a href="#不同的二叉搜索树" class="headerlink" title="不同的二叉搜索树"></a>不同的二叉搜索树</h3><blockquote><p>给你一个整数 n ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的 二叉搜索树 有多少种？返回满足题意的二叉搜索树的种数。</p></blockquote><p>dp[3]，就是 元素1为头结点搜索树的数量 + 元素2为头结点搜索树的数量 + 元素3为头结点搜索树的数量</p><p>元素1为头结点搜索树的数量 &#x3D; 右子树有2个元素的搜索树数量 * 左子树有0个元素的搜索树数量</p><p>元素2为头结点搜索树的数量 &#x3D; 右子树有1个元素的搜索树数量 * 左子树有1个元素的搜索树数量</p><p>元素3为头结点搜索树的数量 &#x3D; 右子树有0个元素的搜索树数量 * 左子树有2个元素的搜索树数量</p><p>有2个元素的搜索树数量就是dp[2]。</p><p>有1个元素的搜索树数量就是dp[1]。</p><p>有0个元素的搜索树数量就是dp[0]。</p><p>所以dp[3] &#x3D; dp[2] * dp[0] + dp[1] * dp[1] + dp[0] * dp[2]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numTrees</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt;= n; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= i; j++)&#123;<br>                dp[i] += dp[j - <span class="hljs-number">1</span>] * dp[i - j];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="分割等和子集——01背包问题"><a href="#分割等和子集——01背包问题" class="headerlink" title="分割等和子集——01背包问题"></a>分割等和子集——01背包问题</h3><blockquote><p>给你一个 只包含正整数 的 非空 数组 nums 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canPartition</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-comment">// 本质：能否将sum / 2的背包塞满</span><br>        <span class="hljs-comment">// 即背包问题可用于求背包是否能装满</span><br>        <span class="hljs-keyword">if</span>(nums == <span class="hljs-literal">null</span> || nums.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> num : nums)&#123;<br>            sum += num;<br>        &#125;<br>        <span class="hljs-comment">// 无法平分</span><br>        <span class="hljs-keyword">if</span>(sum % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> sum / <span class="hljs-number">2</span>;<br>        <span class="hljs-comment">// dp[i]表示容量为i的背包最大能装的价值为多少</span><br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[target + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++)&#123;<br>            <span class="hljs-comment">// 倒序遍历，防止重复使用某物品</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> target; j &gt;= nums[i]; j--)&#123;<br>                <span class="hljs-comment">// 既是重量也是价值，防止溢出</span><br>                dp[j] = Math.max(dp[j], dp[j - nums[i]] + nums[i]);<br>            &#125;<br>            <span class="hljs-comment">// 剪枝</span><br>            <span class="hljs-keyword">if</span>(dp[target] == target)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[target] == target;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="最后一块石头的重量-II"><a href="#最后一块石头的重量-II" class="headerlink" title="最后一块石头的重量 II"></a>最后一块石头的重量 II</h4><blockquote><p>有一堆石头，用整数数组 stones 表示。其中 stones[i] 表示第 i 块石头的重量。<br>每一回合，从中选出任意两块石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x &lt;&#x3D; y。那么粉碎的可能结果如下：<br>如果 x &#x3D;&#x3D; y，那么两块石头都会被完全粉碎；<br>如果 x !&#x3D; y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。<br>最后，最多只会剩下一块 石头。返回此石头 最小的可能重量 。如果没有石头剩下，就返回 0。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lastStoneWeightII</span><span class="hljs-params">(<span class="hljs-type">int</span>[] stones)</span> &#123;<br>        <span class="hljs-comment">// 尽量把石头分成重量相同的两堆</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> stone : stones)&#123;<br>            sum += stone;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> sum / <span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[target + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; stones.length; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> target; j &gt;= stones[i]; j--)&#123;<br>                dp[j] = Math.max(dp[j], dp[j - stones[i]] + stones[i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum - <span class="hljs-number">2</span> * dp[target];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="目标和——组合问题"><a href="#目标和——组合问题" class="headerlink" title="目标和——组合问题"></a>目标和——组合问题</h4><blockquote><p>给你一个非负整数数组 nums 和一个整数 target 。<br>向数组中的每个整数前添加 ‘+’ 或 ‘-‘ ，然后串联起所有整数，可以构造一个 表达式 ：<br>例如，nums &#x3D; [2, 1] ，可以在 2 之前添加 ‘+’ ，在 1 之前添加 ‘-‘ ，然后串联起来得到表达式 “+2-1” 。<br>返回可以通过上述方法构造的、运算结果等于 target 的不同 表达式 的数目。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findTargetSumWays</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> num : nums)&#123;<br>            sum += num;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(Math.abs(target) &gt; sum) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>((target + sum) % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">bagSize</span> <span class="hljs-operator">=</span> (target + sum) / <span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[bagSize + <span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>; <span class="hljs-comment">// 初始化</span><br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> bagSize; j &gt;= nums[i]; j--)&#123;<br>                <span class="hljs-comment">// 其实依然是用不用nums[i]的问题</span><br>                dp[j] = dp[j] + dp[j - nums[i]];<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> dp[bagSize];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="一和零"><a href="#一和零" class="headerlink" title="一和零"></a>一和零</h4><blockquote><p>给你一个二进制字符串数组 strs 和两个整数 m 和 n 。<br>请你找出并返回 strs 的最大子集的长度，该子集中 最多 有 m 个 0 和 n 个 1 。<br>如果 x 的所有元素也是 y 的元素，集合 x 是集合 y 的 子集 。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findMaxForm</span><span class="hljs-params">(String[] strs, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-comment">// dp[i][j]表示i个0和j个1时的最大子集长度</span><br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m + <span class="hljs-number">1</span>][n + <span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span> zeroNum, oneNum;<br>        <span class="hljs-keyword">for</span>(String str : strs)&#123;<br>            zeroNum = <span class="hljs-number">0</span>;<br>            oneNum = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> ch : str.toCharArray())&#123;<br>                <span class="hljs-keyword">if</span>(ch == <span class="hljs-string">&#x27;0&#x27;</span>)&#123;<br>                    zeroNum++;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    oneNum++;<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> m; i &gt;= zeroNum; i--)&#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> n; j &gt;= oneNum; j--)&#123;<br>                    <span class="hljs-comment">// 依然是用不用该字符串的问题</span><br>                    dp[i][j] = Math.max(dp[i][j], dp[i - zeroNum][j - oneNum] + <span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[m][n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="零钱兑换II——完全背包问题"><a href="#零钱兑换II——完全背包问题" class="headerlink" title="零钱兑换II——完全背包问题"></a>零钱兑换II——完全背包问题</h3><blockquote><p>给你一个整数数组 coins 表示不同面额的硬币，另给一个整数 amount 表示总金额。<br>请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 0 。<br>假设每一种面额的硬币有无限个。<br>题目数据保证结果符合 32 位带符号整数。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">change</span><span class="hljs-params">(<span class="hljs-type">int</span> amount, <span class="hljs-type">int</span>[] coins)</span> &#123;<br>        <span class="hljs-comment">// dp[i][j]表示在使用前i个物品的情况下容量为j的背包的价值</span><br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[coins.length][amount + <span class="hljs-number">1</span>];<br><br>        <span class="hljs-comment">// 初始化第一行和第一列</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; coins.length; i++)&#123;<br>            dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> coins[<span class="hljs-number">0</span>]; j &lt;= amount; j++)&#123;<br>            dp[<span class="hljs-number">0</span>][j] += dp[<span class="hljs-number">0</span>][j - coins[<span class="hljs-number">0</span>]];<br>        &#125;<br><br>        <span class="hljs-comment">// 同样是用不用物品i的问题</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; coins.length; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= amount; j++)&#123;<br>                <span class="hljs-keyword">if</span>(j &lt; coins[i]) dp[i][j] = dp[i - <span class="hljs-number">1</span>][j];<br>                <span class="hljs-comment">// 与01背包问题的区别是dp[i][j - coins[i]]，即在同一层</span><br>                <span class="hljs-keyword">else</span> dp[i][j] = dp[i][j - coins[i]] + dp[i - <span class="hljs-number">1</span>][j];<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> dp[coins.length - <span class="hljs-number">1</span>][amount];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>或者使用一维数组直接求解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">change</span><span class="hljs-params">(<span class="hljs-type">int</span> amount, <span class="hljs-type">int</span>[] coins)</span> &#123;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[amount + <span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 组合问题先遍历物品，排列问题先遍历背包</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; coins.length; i++)&#123; <span class="hljs-comment">// 遍历物品</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> coins[i]; j &lt;= amount; j++)&#123; <span class="hljs-comment">// 遍历背包</span><br>                <span class="hljs-comment">// 依然是用不用物品i的问题</span><br>                dp[j] = dp[j] + dp[j - coins[i]];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[amount];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="组合总和-Ⅳ"><a href="#组合总和-Ⅳ" class="headerlink" title="组合总和 Ⅳ"></a>组合总和 Ⅳ</h4><blockquote><p>给你一个由 不同 整数组成的数组 nums ，和一个目标整数 target 。请你从 nums 中找出并返回总和为 target 的元素组合的个数。<br>题目数据保证答案符合 32 位整数范围。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">combinationSum4</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-comment">// 只用求个数，是用动态规划</span><br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[target + <span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 实为排列问题</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= target; i++)&#123; <span class="hljs-comment">// 先遍历背包</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; nums.length; j++)&#123; <span class="hljs-comment">// 再遍历物品</span><br>                <span class="hljs-keyword">if</span>(i &gt;= nums[j])&#123;<br>                    dp[i] = dp[i] + dp[i - nums[j]];<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> dp[target];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="零钱兑换"><a href="#零钱兑换" class="headerlink" title="零钱兑换"></a>零钱兑换</h4><blockquote><p>给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。<br>计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。<br>你可以认为每种硬币的数量是无限的。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">coinChange</span><span class="hljs-params">(<span class="hljs-type">int</span>[] coins, <span class="hljs-type">int</span> amount)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[amount + <span class="hljs-number">1</span>];<br>        <span class="hljs-comment">// 初始化为最大值</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; dp.length; j++)&#123;<br>            dp[j] = max;<br>        &#125;<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; coins.length; i++)&#123;<br>            <span class="hljs-comment">// 完全背包问题就正序遍历</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> coins[i]; j &lt;= amount; j++)&#123;<br>                <span class="hljs-comment">// 可能出现前面凑不成的情况</span><br>                <span class="hljs-keyword">if</span>(dp[j - coins[i]] != max)&#123;<br>                    dp[j] = Math.min(dp[j], dp[j - coins[i]] + <span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[amount] == max ? -<span class="hljs-number">1</span> : dp[amount];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="完全平方数"><a href="#完全平方数" class="headerlink" title="完全平方数"></a>完全平方数</h4><blockquote><p>给你一个整数 n ，返回 和为 n 的完全平方数的最少数量 。<br>完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numSquares</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt;= n; j++)&#123;<br>            dp[j] = max;<br>        &#125;<br><br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i * i &lt;= n; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i * i; j &lt;= n; j++)&#123;<br>                <span class="hljs-comment">// 这里不需要if，因为一个数一定能拆成多个完全平方数相加</span><br>                dp[j] = Math.min(dp[j], dp[j - i * i] + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="单词拆分"><a href="#单词拆分" class="headerlink" title="单词拆分"></a>单词拆分</h4><blockquote><p>给你一个字符串 s 和一个字符串列表 wordDict 作为字典。如果可以利用字典中出现的一个或多个单词拼接出 s 则返回 true。<br>注意：不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">wordBreak</span><span class="hljs-params">(String s, List&lt;String&gt; wordDict)</span> &#123;<br>        HashSet&lt;String&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;(wordDict);<br>        <span class="hljs-type">boolean</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[s.length() + <span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= s.length(); i++)&#123; <span class="hljs-comment">// 先遍历背包</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; i &amp;&amp; !dp[i]; j++)&#123; <span class="hljs-comment">// 再遍历物品，剪枝了一下</span><br>                <span class="hljs-keyword">if</span>(set.contains(s.substring(j, i)) &amp;&amp; dp[j])&#123;<br>                    dp[i] = <span class="hljs-literal">true</span>;<br>                &#125;<br><br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> dp[s.length()];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="打家劫舍"><a href="#打家劫舍" class="headerlink" title="打家劫舍"></a>打家劫舍</h3><blockquote><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。<br>给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">rob</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-keyword">if</span>(nums == <span class="hljs-literal">null</span> || nums.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(nums.length == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br><br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length];<br>        dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>        dp[<span class="hljs-number">1</span>] = Math.max(dp[<span class="hljs-number">0</span>], nums[<span class="hljs-number">1</span>]);<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt; nums.length; i++)&#123;<br>            <span class="hljs-comment">// 偷不偷房屋i的问题</span><br>            dp[i] = Math.max(dp[i - <span class="hljs-number">1</span>], dp[i - <span class="hljs-number">2</span>] + nums[i]);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> dp[nums.length - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="打家劫舍-II"><a href="#打家劫舍-II" class="headerlink" title="打家劫舍 II"></a>打家劫舍 II</h4><blockquote><p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。<br>给定一个代表每个房屋存放金额的非负整数数组，计算你 在不触动警报装置的情况下 ，今晚能够偷窃到的最高金额。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">// 考虑两种情况：含首不含尾、含尾不含首</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">rob</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-keyword">if</span>(nums == <span class="hljs-literal">null</span> || nums.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(nums.length == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">return</span> Math.max(robAction(nums, <span class="hljs-number">0</span>, nums.length - <span class="hljs-number">2</span>), robAction(nums, <span class="hljs-number">1</span>, nums.length - <span class="hljs-number">1</span>));<br>    &#125;<br><br>    <span class="hljs-comment">// 跟打家劫舍一致</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">robAction</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span>&#123;<br>        <span class="hljs-keyword">if</span>(end == start) <span class="hljs-keyword">return</span> nums[start];<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length];<br>        dp[start] = nums[start];<br>        dp[start + <span class="hljs-number">1</span>] = Math.max(dp[start], nums[start + <span class="hljs-number">1</span>]);<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start + <span class="hljs-number">2</span>; i &lt;= end; i++)&#123;<br>            dp[i] = Math.max(dp[i - <span class="hljs-number">2</span>] + nums[i], dp[i - <span class="hljs-number">1</span>]);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> dp[end];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="打家劫舍-III"><a href="#打家劫舍-III" class="headerlink" title="打家劫舍 III"></a>打家劫舍 III</h4><blockquote><p>小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为 root 。<br>除了 root 之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果 两个直接相连的房子在同一天晚上被打劫 ，房屋将自动报警。<br>给定二叉树的 root 。返回 在不触动警报的情况下 ，小偷能够盗取的最高金额 。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">rob</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-type">int</span>[] dp = robAction(root);<br>        <span class="hljs-keyword">return</span> Math.max(dp[<span class="hljs-number">0</span>], dp[<span class="hljs-number">1</span>]);<br>    &#125;<br><br>    <span class="hljs-comment">// dp[0]表示不偷，dp[1]表示偷</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] robAction(TreeNode root)&#123;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> dp;<br>        &#125;<br>        <span class="hljs-type">int</span>[] left = robAction(root.left);<br>        <span class="hljs-type">int</span>[] right = robAction(root.right);<br><br>        dp[<span class="hljs-number">0</span>] = Math.max(left[<span class="hljs-number">0</span>], left[<span class="hljs-number">1</span>]) + Math.max(right[<span class="hljs-number">0</span>], right[<span class="hljs-number">1</span>]);<br>        dp[<span class="hljs-number">1</span>] = root.val + left[<span class="hljs-number">0</span>] + right[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">return</span> dp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="买卖股票的最佳时机"><a href="#买卖股票的最佳时机" class="headerlink" title="买卖股票的最佳时机"></a>买卖股票的最佳时机</h3><blockquote><p>给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。<br>你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。<br>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxProfit</span><span class="hljs-params">(<span class="hljs-type">int</span>[] prices)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> prices.length;<br>        <span class="hljs-comment">// 0表示持有股票，1表示未持有股票</span><br>        <span class="hljs-comment">// 由于第i天的利润只和第i-1天有关，故节约空间</span><br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">2</span>];<br>        dp[<span class="hljs-number">0</span>] = -prices[<span class="hljs-number">0</span>];<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; len; i++)&#123;<br>            <span class="hljs-comment">// i-1天是否持有股票的区别</span><br>            dp[<span class="hljs-number">0</span>] = Math.max(dp[<span class="hljs-number">0</span>], -prices[i]);<br>            dp[<span class="hljs-number">1</span>] = Math.max(dp[<span class="hljs-number">1</span>], prices[i] + dp[<span class="hljs-number">0</span>]);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="买卖股票的最佳时机-II"><a href="#买卖股票的最佳时机-II" class="headerlink" title="买卖股票的最佳时机 II"></a>买卖股票的最佳时机 II</h4><blockquote><p>给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格。<br>在每一天，你可以决定是否购买和&#x2F;或出售股票。你在任何时候 最多 只能持有 一股 股票。你也可以先购买，然后在 同一天 出售。<br>返回 你能获得的 最大 利润 。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxProfit</span><span class="hljs-params">(<span class="hljs-type">int</span>[] prices)</span> &#123;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">2</span>];<br>        <span class="hljs-comment">// 0表示持有，1表示卖出</span><br>        dp[<span class="hljs-number">0</span>] = -prices[<span class="hljs-number">0</span>];<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; prices.length; i++)&#123;<br>            dp[<span class="hljs-number">0</span>] = Math.max(dp[<span class="hljs-number">0</span>], dp[<span class="hljs-number">1</span>] - prices[i]);<br>            dp[<span class="hljs-number">1</span>] = Math.max(dp[<span class="hljs-number">1</span>], dp[<span class="hljs-number">0</span>] + prices[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="买卖股票的最佳时机-III"><a href="#买卖股票的最佳时机-III" class="headerlink" title="买卖股票的最佳时机 III"></a>买卖股票的最佳时机 III</h4><blockquote><p>给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。<br>设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。<br>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxProfit</span><span class="hljs-params">(<span class="hljs-type">int</span>[] prices)</span> &#123;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">4</span>];<br>        <span class="hljs-comment">// 0表示第一次交易买入</span><br>        dp[<span class="hljs-number">0</span>] = -prices[<span class="hljs-number">0</span>];<br>        <span class="hljs-comment">// 1表示第一次交易卖出</span><br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 2表示第二次交易买入</span><br>        dp[<span class="hljs-number">2</span>] = -prices[<span class="hljs-number">0</span>];<br>        <span class="hljs-comment">// 3表示第二次交易卖出</span><br>        dp[<span class="hljs-number">3</span>] = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; prices.length; i++)&#123;<br>            dp[<span class="hljs-number">0</span>] = Math.max(dp[<span class="hljs-number">0</span>], -prices[i]);<br>            dp[<span class="hljs-number">1</span>] = Math.max(dp[<span class="hljs-number">1</span>], dp[<span class="hljs-number">0</span>] + prices[i]);<br>            dp[<span class="hljs-number">2</span>] = Math.max(dp[<span class="hljs-number">2</span>], dp[<span class="hljs-number">1</span>] - prices[i]);<br>            dp[<span class="hljs-number">3</span>] = Math.max(dp[<span class="hljs-number">3</span>], dp[<span class="hljs-number">2</span>] + prices[i]);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">3</span>]; <span class="hljs-comment">//之所以是对的，是因为dp[3]也能表示未交易或者交易了一次，因为初始化的特点</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="买卖股票的最佳时机-IV"><a href="#买卖股票的最佳时机-IV" class="headerlink" title="买卖股票的最佳时机 IV"></a>买卖股票的最佳时机 IV</h4><blockquote><p>给你一个整数数组 prices 和一个整数 k ，其中 prices[i] 是某支给定的股票在第 i 天的价格。<br>设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。也就是说，你最多可以买 k 次，卖 k 次。<br>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxProfit</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span>[] prices)</span> &#123;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">2</span> * k + <span class="hljs-number">1</span>];<br>        <span class="hljs-comment">// 奇数表示买入，偶数表示卖出</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; <span class="hljs-number">2</span> * k + <span class="hljs-number">1</span>; j += <span class="hljs-number">2</span>)&#123;<br>            dp[j] = -prices[<span class="hljs-number">0</span>];<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; prices.length; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; <span class="hljs-number">2</span> * k + <span class="hljs-number">1</span>; j++)&#123;<br>                <span class="hljs-keyword">if</span>(j % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>)&#123;<br>                    dp[j] = Math.max(dp[j], dp[j - <span class="hljs-number">1</span>] - prices[i]);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    dp[j] = Math.max(dp[j], dp[j - <span class="hljs-number">1</span>] + prices[i]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">2</span> * k];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="买卖股票的最佳时机含冷冻期"><a href="#买卖股票的最佳时机含冷冻期" class="headerlink" title="买卖股票的最佳时机含冷冻期"></a>买卖股票的最佳时机含冷冻期</h4><blockquote><p>给定一个整数数组prices，其中第  prices[i] 表示第 i 天的股票价格 。​<br>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:<br>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。<br>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxProfit</span><span class="hljs-params">(<span class="hljs-type">int</span>[] prices)</span> &#123;<br>        <span class="hljs-comment">// 0表示持有，1表示至少两天前就已经卖出股票，2表示今天卖出，3表示处于冷冻期(昨天卖出)</span><br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">4</span>];<br>        dp[<span class="hljs-number">0</span>] = -prices[<span class="hljs-number">0</span>];<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; prices.length; i++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp0</span> <span class="hljs-operator">=</span> dp[<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp1</span> <span class="hljs-operator">=</span> dp[<span class="hljs-number">1</span>];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp2</span> <span class="hljs-operator">=</span> dp[<span class="hljs-number">2</span>];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp3</span> <span class="hljs-operator">=</span> dp[<span class="hljs-number">3</span>];<br>            dp[<span class="hljs-number">0</span>] = Math.max(temp0, Math.max(temp1, temp3) - prices[i]);<br>            dp[<span class="hljs-number">1</span>] = Math.max(temp1, temp3);<br>            dp[<span class="hljs-number">2</span>] = temp0 + prices[i];<br>            dp[<span class="hljs-number">3</span>] = temp2;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> Math.max(dp[<span class="hljs-number">1</span>], Math.max(dp[<span class="hljs-number">2</span>], dp[<span class="hljs-number">3</span>]));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="最长递增子序列"><a href="#最长递增子序列" class="headerlink" title="最长递增子序列"></a>最长递增子序列</h3><blockquote><p>给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。<br>子序列 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lengthOfLIS</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-comment">// dp[i]表示以nums[i]结尾的最长递增子序列长度</span><br>        <span class="hljs-keyword">if</span>(nums.length &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums.length;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        Arrays.fill(dp, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; nums.length; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; i; j++)&#123;<br>                <span class="hljs-keyword">if</span>(nums[j] &lt; nums[i])&#123;<br>                    dp[i] = Math.max(dp[i], dp[j] + <span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 实时更新</span><br>            res = Math.max(res, dp[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="最长连续递增序列"><a href="#最长连续递增序列" class="headerlink" title="最长连续递增序列"></a>最长连续递增序列</h4><blockquote><p>给定一个未经排序的整数数组，找到最长且 连续递增的子序列，并返回该序列的长度。<br>连续递增的子序列 可以由两个下标 l 和 r（l &lt; r）确定，如果对于每个 l &lt;&#x3D; i &lt; r，都有 nums[i] &lt; nums[i + 1] ，那么子序列 [nums[l], nums[l + 1], …, nums[r - 1], nums[r]] 就是连续递增子序列。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findLengthOfLCIS</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-comment">// 结果只和上一位有关，节约空间</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>, cur = <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; nums.length; i++)&#123;<br>            cur = (nums[i] &gt; nums[i - <span class="hljs-number">1</span>]) ? prev + <span class="hljs-number">1</span> : <span class="hljs-number">1</span>;<br>            prev = cur;<br>            res = Math.max(res, cur);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="最长重复子数组"><a href="#最长重复子数组" class="headerlink" title="最长重复子数组"></a>最长重复子数组</h4><blockquote><p>给两个整数数组 nums1 和 nums2 ，返回 两个数组中 公共的 、长度最长的子数组的长度 。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findLength</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span>[] nums2)</span> &#123;<br>        <span class="hljs-comment">// dp[i][j] 表示nums[i - 1]和nums[j - 1]序列的最长重复子序列</span><br>        <span class="hljs-comment">// 这样简化了初始化，因为初始化边缘为0即可，这样dp[1][1]在相同情况下自然就是1</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums1.length + <span class="hljs-number">1</span>][nums2.length + <span class="hljs-number">1</span>];<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= nums1.length; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= nums2.length; j++)&#123;<br>                <span class="hljs-keyword">if</span>(nums1[i - <span class="hljs-number">1</span>] == nums2[j - <span class="hljs-number">1</span>])&#123;<br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>                    res = Math.max(res, dp[i][j]);<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h4><blockquote><p>给定两个字符串 text1 和 text2，返回这两个字符串的最长 公共子序列 的长度。如果不存在 公共子序列 ，返回 0 。<br>一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。<br>例如，”ace” 是 “abcde” 的子序列，但 “aec” 不是 “abcde” 的子序列。<br>两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">longestCommonSubsequence</span><span class="hljs-params">(String text1, String text2)</span> &#123;<br>        <span class="hljs-comment">// 与上一题的区别就是不再需要连续</span><br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[text1.length() + <span class="hljs-number">1</span>][text2.length() + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= text1.length(); i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= text2.length(); j++)&#123;<br>                <span class="hljs-keyword">if</span>(text1.charAt(i - <span class="hljs-number">1</span>) == text2.charAt(j - <span class="hljs-number">1</span>))&#123;<br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    dp[i][j] = Math.max(dp[i - <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[text1.length()][text2.length()];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="不相交的线"><a href="#不相交的线" class="headerlink" title="不相交的线"></a>不相交的线</h4><blockquote><p>在两条独立的水平线上按给定的顺序写下 nums1 和 nums2 中的整数。<br>现在，可以绘制一些连接两个数字 nums1[i] 和 nums2[j] 的直线，这些直线需要同时满足：<br>nums1[i] &#x3D;&#x3D; nums2[j]<br>且绘制的直线不与任何其他连线（非水平线）相交。<br>请注意，连线即使在端点也不能相交：每个数字只能属于一条连线。<br>以这种方法绘制线条，并返回可以绘制的最大连线数</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxUncrossedLines</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span>[] nums2)</span> &#123;<br>        <span class="hljs-comment">// 等效于最长公共子序列，因为不会在端点相交，长度一致</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">len1</span> <span class="hljs-operator">=</span> nums1.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len2</span> <span class="hljs-operator">=</span> nums2.length;<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[len1 + <span class="hljs-number">1</span>][len2 + <span class="hljs-number">1</span>];<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= len1; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= len2; j++)&#123;<br>                <span class="hljs-keyword">if</span>(nums1[i - <span class="hljs-number">1</span>] == nums2[j - <span class="hljs-number">1</span>])&#123;<br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    dp[i][j] = Math.max(dp[i - <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>]);<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> dp[len1][len2];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="最大子数组和"><a href="#最大子数组和" class="headerlink" title="最大子数组和"></a>最大子数组和</h4><blockquote><p>给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。<br>子数组是数组中的一个连续部分。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxSubArray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-comment">// 同样节约空间</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; nums.length; i++)&#123;<br>            prev = Math.max(prev + nums[i], nums[i]);<br>            res = Math.max(prev, res);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="判断子序列"><a href="#判断子序列" class="headerlink" title="判断子序列"></a>判断子序列</h4><blockquote><p>给定字符串 s 和 t ，判断 s 是否为 t 的子序列。<br>字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，”ace”是”abcde”的一个子序列，而”aec”不是）。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSubsequence</span><span class="hljs-params">(String s, String t)</span> &#123;<br>        <span class="hljs-comment">// 类比最长公共子序列，不过只删除t的元素来达到拟合s的目的</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">len1</span> <span class="hljs-operator">=</span> s.length(), len2 = t.length();<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[len1 + <span class="hljs-number">1</span>][len2 + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= len1; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= len2; j++)&#123;<br>                <span class="hljs-keyword">if</span>(s.charAt(i - <span class="hljs-number">1</span>) == t.charAt(j - <span class="hljs-number">1</span>))&#123;<br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// 相当于剔除t[j - 1]</span><br>                    dp[i][j] = dp[i][j - <span class="hljs-number">1</span>];<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[len1][len2] == len1;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="不同的子序列"><a href="#不同的子序列" class="headerlink" title="不同的子序列"></a>不同的子序列</h4><blockquote><p>给你两个字符串 s 和 t ，统计并返回在 s 的 子序列 中 t 出现的个数。<br>测试用例保证结果在 32 位有符号整数范围内。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numDistinct</span><span class="hljs-params">(String s, String t)</span> &#123;<br>        <span class="hljs-comment">// 只考虑在s中删除元素</span><br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[s.length() + <span class="hljs-number">1</span>][t.length() + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= s.length(); i++)&#123;<br>            dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= s.length(); i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= t.length(); j++)&#123;<br>                <span class="hljs-keyword">if</span>(s.charAt(i - <span class="hljs-number">1</span>) == t.charAt(j - <span class="hljs-number">1</span>))&#123;<br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">1</span>][j]; <span class="hljs-comment">// 是否删除s[i - 1]的问题</span><br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j]; <span class="hljs-comment">// 必须删除s[i - 1]</span><br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> dp[s.length()][t.length()];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="两个字符串的删除操作"><a href="#两个字符串的删除操作" class="headerlink" title="两个字符串的删除操作"></a>两个字符串的删除操作</h4><blockquote><p>给定两个单词 word1 和 word2 ，返回使得 word1 和  word2 相同所需的最小步数。<br>每步 可以删除任意一个字符串中的一个字符。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minDistance</span><span class="hljs-params">(String word1, String word2)</span> &#123;<br>        <span class="hljs-comment">// 与上一题的区别就是两个字符串都能删除</span><br>        <span class="hljs-comment">// 记录操作次数</span><br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[word1.length() + <span class="hljs-number">1</span>][word2.length() + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= word1.length(); i++)&#123;<br>            dp[i][<span class="hljs-number">0</span>] = i;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt;= word2.length(); j++)&#123;<br>            dp[<span class="hljs-number">0</span>][j] = j;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= word1.length(); i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= word2.length(); j++)&#123;<br>                <span class="hljs-keyword">if</span>(word1.charAt(i - <span class="hljs-number">1</span>) == word2.charAt(j - <span class="hljs-number">1</span>))&#123;<br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]; <span class="hljs-comment">// 无需删除</span><br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// 删除word1[i - 1]，删除word2[j - 1]，都删除</span><br>                    dp[i][j] = Math.min(Math.min(dp[i - <span class="hljs-number">1</span>][j] + <span class="hljs-number">1</span>, dp[i][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>), dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">2</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> dp[word1.length()][word2.length()];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="编辑距离"><a href="#编辑距离" class="headerlink" title="编辑距离"></a>编辑距离</h4><blockquote><p>给你两个单词 word1 和 word2， 请返回将 word1 转换成 word2 所使用的最少操作数  。<br>你可以对一个单词进行如下三种操作：<br>插入一个字符<br>删除一个字符<br>替换一个字符</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minDistance</span><span class="hljs-params">(String word1, String word2)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len1</span> <span class="hljs-operator">=</span> word1.length(), len2 = word2.length();<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[len1 + <span class="hljs-number">1</span>][len2 + <span class="hljs-number">1</span>];<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= len1; i++)&#123;<br>            dp[i][<span class="hljs-number">0</span>] = i;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt;= len2; j++)&#123;<br>            dp[<span class="hljs-number">0</span>][j] = j;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= len1; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= len2; j++)&#123;<br>                <span class="hljs-keyword">if</span>(word1.charAt(i - <span class="hljs-number">1</span>) == word2.charAt(j - <span class="hljs-number">1</span>))&#123;<br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]; <span class="hljs-comment">// 无需操作</span><br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// 替换，还是增删</span><br>                    dp[i][j] = Math.min(dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>], Math.min(dp[i - <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>])) + <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> dp[len1][len2];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="回文子串"><a href="#回文子串" class="headerlink" title="回文子串"></a>回文子串</h3><blockquote><p>给你一个字符串 s ，请你统计并返回这个字符串中 回文子串 的数目。<br>回文字符串 是正着读和倒过来读一样的字符串。<br>子字符串 是字符串中的由连续字符组成的一个序列。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countSubstrings</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-comment">// dp[i][j]表示区间[i,j]是否为回文</span><br>        <span class="hljs-type">boolean</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[s.length()][s.length()];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// dp[i][j]的结果依赖dp[i + 1][j - 1]，因此从下往上，从左往右遍历</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> s.length() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i; j &lt; s.length(); j++)&#123;<br>                <span class="hljs-keyword">if</span>(s.charAt(i) == s.charAt(j) &amp;&amp; (j - i &lt;= <span class="hljs-number">1</span> || dp[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]))&#123;<br>                    res++;<br>                    dp[i][j] = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="最长回文子序列"><a href="#最长回文子序列" class="headerlink" title="最长回文子序列"></a>最长回文子序列</h4><blockquote><p>给你一个字符串 s ，找出其中最长的回文子序列，并返回该序列的长度。<br>子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">longestPalindromeSubseq</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-comment">// 不一定连续</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[s.length()][s.length()];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt; len; k++) dp[k][k] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> len - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>; j &lt; len; j++)&#123;<br>                <span class="hljs-keyword">if</span>(s.charAt(i) == s.charAt(j))&#123;<br>                    dp[i][j] = dp[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">2</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    dp[i][j] = Math.max(dp[i][j - <span class="hljs-number">1</span>], dp[i + <span class="hljs-number">1</span>][j]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][len - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
      <category>代码随想录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>代码随想录之贪心算法</title>
    <link href="/2025/06/17/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E4%B9%8B%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    <url>/2025/06/17/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E4%B9%8B%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h2><h3 id="分发饼干"><a href="#分发饼干" class="headerlink" title="分发饼干"></a>分发饼干</h3><blockquote><p>假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。<br>对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] &gt;&#x3D; g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是满足尽可能多的孩子，并输出这个最大数值。</p></blockquote><p>贪心算法适合用在每一步都能做出局部最优，并且全局最优解可以由局部最优推出的场景，且每次做的选择不会影响后面的全局最优。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">// 大饼干喂给胃口大的，避免浪费的同时形成最优解，考虑胃口</span><br>    <span class="hljs-comment">// 或者小饼干喂给小胃口的，考虑饼干</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findContentChildren</span><span class="hljs-params">(<span class="hljs-type">int</span>[] g, <span class="hljs-type">int</span>[] s)</span> &#123;<br>        Arrays.sort(g);<br>        Arrays.sort(s);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> s.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 遍历大胃口，将大饼干喂给恰好小于饼干值的大胃口，即寻找每一个大饼干合适的小孩</span><br>        <span class="hljs-comment">// 局部最优：大饼干喂给大胃口</span><br>        <span class="hljs-comment">// 全局最优：喂饱尽可能多的孩子</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> g.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span> &amp;&amp; start &gt;= <span class="hljs-number">0</span>; i--)&#123;<br>            <span class="hljs-keyword">if</span>(g[i] &lt;= s[start])&#123;<br>                start--;<br>                count++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="摆动序列"><a href="#摆动序列" class="headerlink" title="摆动序列"></a>摆动序列</h3><blockquote><p>如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为 摆动序列 。第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。<br>例如， [1, 7, 4, 9, 2, 5] 是一个 摆动序列 ，因为差值 (6, -3, 5, -7, 3) 是正负交替出现的。<br>相反，[1, 4, 7, 2, 5] 和 [1, 7, 4, 5, 5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。<br>子序列 可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。<br>给你一个整数数组 nums ，返回 nums 中作为 摆动序列 的 最长子序列的长度 。</p></blockquote><p>注意平坡问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">// 在坡度变化的时候修改prediff，避免平坡问题</span><br>    <span class="hljs-comment">// 局部最优：考虑峰值</span><br>    <span class="hljs-comment">// 全局最优：保证摆动序列</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">wiggleMaxLength</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-keyword">if</span>(nums.length &lt;= <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> nums.length;<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">curDiff</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">preDiff</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; nums.length; i++)&#123;<br>            curDiff = nums[i] - nums[i - <span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span>((curDiff &gt; <span class="hljs-number">0</span> &amp;&amp; preDiff &lt;= <span class="hljs-number">0</span>) || (curDiff &lt; <span class="hljs-number">0</span> &amp;&amp; preDiff &gt;= <span class="hljs-number">0</span>))&#123;<br>                count++;<br>                preDiff = curDiff;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="最大子数组和"><a href="#最大子数组和" class="headerlink" title="最大子数组和"></a>最大子数组和</h3><blockquote><p>给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。<br>子数组是数组中的一个连续部分。</p></blockquote><p>使用贪心算法时理清局部最优和全局最优。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">// 局部最优：连续和为负数时放弃，保证局部为正数</span><br>    <span class="hljs-comment">// 全局最优：选取最大连续和</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxSubArray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-keyword">if</span>(nums.length == <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> Integer.MIN_VALUE;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++)&#123;<br>            count += nums[i];<br>            sum = Math.max(sum, count); <span class="hljs-comment">// 必须实时</span><br>            <span class="hljs-keyword">if</span>(count &lt;= <span class="hljs-number">0</span>)&#123;<br>                count = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="买卖股票的最佳时机-II"><a href="#买卖股票的最佳时机-II" class="headerlink" title="买卖股票的最佳时机 II"></a>买卖股票的最佳时机 II</h3><blockquote><p>给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格。<br>在每一天，你可以决定是否购买和&#x2F;或出售股票。你在任何时候 最多 只能持有 一股 股票。你也可以先购买，然后在 同一天 出售。<br>返回 你能获得的 最大 利润 。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">// 局部最优：收集每天的正利润</span><br>    <span class="hljs-comment">// 全局最优：获得最大利润</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxProfit</span><span class="hljs-params">(<span class="hljs-type">int</span>[] prices)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; prices.length; i++)&#123;<br>            res += Math.max(prices[i] - prices[i - <span class="hljs-number">1</span>], <span class="hljs-number">0</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="跳跃游戏"><a href="#跳跃游戏" class="headerlink" title="跳跃游戏"></a>跳跃游戏</h3><blockquote><p>给你一个非负整数数组 nums ，你最初位于数组的 第一个下标 。数组中的每个元素代表你在该位置可以跳跃的最大长度。<br>判断你是否能够到达最后一个下标，如果可以，返回 true ；否则，返回 false 。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canJump</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-comment">// 局部最优：跳最远</span><br>        <span class="hljs-comment">// 全局最优：能不能覆盖到终点</span><br>        <span class="hljs-keyword">if</span>(nums.length == <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">coverRange</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 之所以用coverRange终止，是因为只能跳那么远</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= coverRange; i++)&#123;<br>            coverRange = Math.max(coverRange, i + nums[i]);<br>            <span class="hljs-keyword">if</span>(coverRange &gt;= nums.length - <span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="跳跃游戏II"><a href="#跳跃游戏II" class="headerlink" title="跳跃游戏II"></a>跳跃游戏II</h4><blockquote><p>给定一个长度为 n 的 0 索引整数数组 nums。初始位置为 nums[0]。<br>每个元素 nums[i] 表示从索引 i 向后跳转的最大长度。换句话说，如果你在 nums[i] 处，你可以跳转到任意 nums[i + j] 处:<br>0 &lt;&#x3D; j &lt;&#x3D; nums[i]<br>i + j &lt; n<br>返回到达 nums[n - 1] 的最小跳跃次数。生成的测试用例可以到达 nums[n - 1]。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">// 局部最优：尽可能跳得更远</span><br>    <span class="hljs-comment">// 全局最优：最少步数</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">jump</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">curDis</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">nextDis</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= curDis &amp;&amp; curDis &lt; nums.length - <span class="hljs-number">1</span>; i++)&#123;<br>            nextDis = Math.max(nextDis, i + nums[i]);<br>            <span class="hljs-keyword">if</span>(i == curDis)&#123;<br>                <span class="hljs-comment">// 到达当前最大覆盖范围，准备跳跃</span><br>                curDis = nextDis; <span class="hljs-comment">// 更新为下次的最大覆盖范围</span><br>                res++; <span class="hljs-comment">//跳跃</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="加油站"><a href="#加油站" class="headerlink" title="加油站"></a>加油站</h3><blockquote><p>在一条环路上有 n 个加油站，其中第 i 个加油站有汽油 gas[i] 升。<br>你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。<br>给定两个整数数组 gas 和 cost ，如果你可以按顺序绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1 。如果存在解，则 保证 它是 唯一 的。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">// 局部最优：当前累加rest[i]的和curSum一旦小于0，起始位置至少要是i+1，因为从i之前开始一定不行</span><br>    <span class="hljs-comment">// 全局最优：找到可以跑一圈的起始位置</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">canCompleteCircuit</span><span class="hljs-params">(<span class="hljs-type">int</span>[] gas, <span class="hljs-type">int</span>[] cost)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">curSum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">totalSum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; gas.length; i++)&#123;<br>            totalSum += gas[i] - cost[i];<br>            curSum += gas[i] - cost[i];<br>            <span class="hljs-keyword">if</span>(curSum &lt; <span class="hljs-number">0</span>)&#123;<br>                curSum = <span class="hljs-number">0</span>;<br>                start = i + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(totalSum &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> start;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="分发糖果"><a href="#分发糖果" class="headerlink" title="分发糖果"></a>分发糖果</h3><blockquote><p>n 个孩子站成一排。给你一个整数数组 ratings 表示每个孩子的评分。<br>你需要按照以下要求，给这些孩子分发糖果：<br>每个孩子至少分配到 1 个糖果。<br>相邻两个孩子评分更高的孩子会获得更多的糖果。<br>请你给每个孩子分发糖果，计算并返回需要准备的 最少糖果数目 。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">// 贪心两次，防止顾此失彼</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">candy</span><span class="hljs-params">(<span class="hljs-type">int</span>[] ratings)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> ratings.length;<br>        <span class="hljs-type">int</span>[] candy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[len];<br>        candy[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 第一次贪心，局部最优：保证右边的比左边多</span><br>        <span class="hljs-comment">// 故正向遍历</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; len; i++)&#123;<br>            candy[i] = (ratings[i] &gt; ratings[i - <span class="hljs-number">1</span>]) ? candy[i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span> : <span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 第二次贪心，局部最优：保证左边的比右边多</span><br>        <span class="hljs-comment">// 故反向遍历</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> len - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--)&#123;<br>            <span class="hljs-keyword">if</span>(ratings[i] &gt; ratings[i + <span class="hljs-number">1</span>])&#123;<br>                candy[i] = Math.max(candy[i], candy[i + <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> num : candy)&#123;<br>            res += num;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="根据身高重建队列"><a href="#根据身高重建队列" class="headerlink" title="根据身高重建队列"></a>根据身高重建队列</h3><blockquote><p>假设有打乱顺序的一群人站成一个队列，数组 people 表示队列中一些人的属性（不一定按顺序）。每个 people[i] &#x3D; [hi, ki] 表示第 i 个人的身高为 hi ，前面 正好 有 ki 个身高大于或等于 hi 的人。<br>请你重新构造并返回输入数组 people 所表示的队列。返回的队列应该格式化为数组 queue ，其中 queue[j] &#x3D; [hj, kj] 是队列中第 j 个人的属性（queue[0] 是排在队列前面的人）。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">// 先按照身高从大到小排序</span><br>    <span class="hljs-comment">// 局部最优：身高高的优先插入正确位置，因为后续身高矮的插入不会影响结果</span><br>    <span class="hljs-comment">// 全局最优：正确队列</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[][] reconstructQueue(<span class="hljs-type">int</span>[][] people) &#123;<br>        Arrays.sort(people, (a, b) -&gt;&#123;<br>            <span class="hljs-keyword">if</span>(a[<span class="hljs-number">0</span>] == b[<span class="hljs-number">0</span>]) <span class="hljs-keyword">return</span> a[<span class="hljs-number">1</span>] - b[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">return</span> b[<span class="hljs-number">0</span>] - a[<span class="hljs-number">0</span>];<br>        &#125;);<br><br>        LinkedList&lt;<span class="hljs-type">int</span>[]&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span>[] p : people)&#123;<br>            queue.add(p[<span class="hljs-number">1</span>], p);<br>        &#125;<br>        <span class="hljs-keyword">return</span> queue.toArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[people.length][]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="用最少数量的箭引爆气球"><a href="#用最少数量的箭引爆气球" class="headerlink" title="用最少数量的箭引爆气球"></a>用最少数量的箭引爆气球</h3><blockquote><p>有一些球形气球贴在一堵用 XY 平面表示的墙面上。墙面上的气球记录在整数数组 points ，其中points[i] &#x3D; [xstart, xend] 表示水平直径在 xstart 和 xend之间的气球。你不知道气球的确切 y 坐标。<br>一支弓箭可以沿着 x 轴从不同点 完全垂直 地射出。在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为 xstart，xend， 且满足  xstart ≤ x ≤ xend，则该气球会被 引爆 。可以射出的弓箭的数量 没有限制 。 弓箭一旦被射出之后，可以无限地前进。<br>给你一个数组 points ，返回引爆所有气球所必须射出的 最小 弓箭数 。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">// 局部最优：射击重叠的气球</span><br>    <span class="hljs-comment">// 全局最优：用的弓箭最少</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findMinArrowShots</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] points)</span> &#123;<br>        Arrays.sort(points, (a, b) -&gt; Integer.compare(a[<span class="hljs-number">0</span>], b[<span class="hljs-number">0</span>])); <span class="hljs-comment">// 避免溢出</span><br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; <span class="hljs-comment">// 第0个气球</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; points.length; i++)&#123;<br>            <span class="hljs-keyword">if</span>(points[i][<span class="hljs-number">0</span>] &gt; points[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>])&#123; <span class="hljs-comment">// 不重叠</span><br>                count++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                points[i][<span class="hljs-number">1</span>] = Math.min(points[i][<span class="hljs-number">1</span>], points[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>]); <span class="hljs-comment">// 更新右边界</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="无重叠区间"><a href="#无重叠区间" class="headerlink" title="无重叠区间"></a>无重叠区间</h4><blockquote><p>给定一个区间的集合 intervals ，其中 intervals[i] &#x3D; [starti, endi] 。返回 需要移除区间的最小数量，使剩余区间互不重叠 。<br>注意 只在一点上接触的区间是 不重叠的。例如 [1, 2] 和 [2, 3] 是不重叠的。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">// 类似于气球题</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">eraseOverlapIntervals</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] intervals)</span> &#123;<br>        Arrays.sort(intervals, (a, b) -&gt; Integer.compare(a[<span class="hljs-number">0</span>], b[<span class="hljs-number">0</span>]));<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; intervals.length; i++)&#123;<br>            <span class="hljs-keyword">if</span>(intervals[i][<span class="hljs-number">0</span>] &gt;= intervals[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>])&#123;<br>                count++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                intervals[i][<span class="hljs-number">1</span>] = Math.min(intervals[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>], intervals[i][<span class="hljs-number">1</span>]); <span class="hljs-comment">// 用min是为了防止气球遗漏</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> intervals.length - count;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="合并区间"><a href="#合并区间" class="headerlink" title="合并区间"></a>合并区间</h4><blockquote><p>以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] &#x3D; [starti, endi] 。请你合并所有重叠的区间，并返回 一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间 。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[][] merge(<span class="hljs-type">int</span>[][] intervals) &#123;<br>        LinkedList&lt;<span class="hljs-type">int</span>[]&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        Arrays.sort(intervals, (a, b) -&gt; Integer.compare(a[<span class="hljs-number">0</span>], b[<span class="hljs-number">0</span>]));<br>        res.add(intervals[<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; intervals.length; i++)&#123;<br>            <span class="hljs-keyword">if</span>(intervals[i][<span class="hljs-number">0</span>] &lt;= res.getLast()[<span class="hljs-number">1</span>])&#123;<br>                <span class="hljs-comment">// 重叠区间</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> res.getLast()[<span class="hljs-number">0</span>];<br>                <span class="hljs-type">int</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> Math.max(intervals[i][<span class="hljs-number">1</span>], res.getLast()[<span class="hljs-number">1</span>]);<br>                res.removeLast();<br>                res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;start, end&#125;);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                res.add(intervals[i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res.toArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[res.size()][]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="单调递增的数字"><a href="#单调递增的数字" class="headerlink" title="单调递增的数字"></a>单调递增的数字</h3><blockquote><p>当且仅当每个相邻位数上的数字 x 和 y 满足 x &lt;&#x3D; y 时，我们称这个整数是单调递增的。<br>给定一个整数 n ，返回 小于或等于 n 的最大数字，且数字呈 单调递增 。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">monotoneIncreasingDigits</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> String.valueOf(n);<br>        <span class="hljs-type">char</span>[] chars = s.toCharArray();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> s.length() - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--)&#123;<br>            <span class="hljs-keyword">if</span>(chars[i] &gt; chars[i + <span class="hljs-number">1</span>])&#123;<br>                chars[i]--;<br>                start = i + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt; s.length(); i++)&#123;<br>            chars[i] = <span class="hljs-string">&#x27;9&#x27;</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> Integer.parseInt(String.valueOf(chars));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="监控二叉树"><a href="#监控二叉树" class="headerlink" title="监控二叉树"></a>监控二叉树</h3><blockquote><p>给定一个二叉树，我们在树的节点上安装摄像头。<br>节点上的每个摄影头都可以监视其父对象、自身及其直接子对象。<br>计算监控树的所有节点所需的最小摄像头数量。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">// 局部最优：叶子结点的父节点安装摄像头</span><br>    <span class="hljs-comment">// 全局最优：总共用的摄像头最少</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> res;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minCameraCover</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(recursive(root) == <span class="hljs-number">0</span>) res++;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-comment">// 0：未被监控</span><br>    <span class="hljs-comment">// 1：监控但不是摄像头</span><br>    <span class="hljs-comment">// 2：自身是摄像头</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">recursive</span><span class="hljs-params">(TreeNode root)</span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; <span class="hljs-comment">// 便于叶子节点的判断</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> recursive(root.left);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> recursive(root.right);<br>        <span class="hljs-keyword">if</span>(left == <span class="hljs-number">0</span> || right == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-comment">// 需要在自己身上安装摄像头</span><br>            res++;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>        &#125;<br>        <span class="hljs-comment">// 左右节点都被监控，自身不安装摄像头，减少数量</span><br>        <span class="hljs-keyword">if</span>(left == <span class="hljs-number">1</span> &amp;&amp; right == <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-comment">// 左右节点有至少一个摄像头，已被监控</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
      <category>代码随想录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>代码随想录之回溯算法</title>
    <link href="/2025/06/15/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E4%B9%8B%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"/>
    <url>/2025/06/15/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E4%B9%8B%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h2><h3 id="组合——以本题为例理解回溯思想和剪枝操作"><a href="#组合——以本题为例理解回溯思想和剪枝操作" class="headerlink" title="组合——以本题为例理解回溯思想和剪枝操作"></a>组合——以本题为例理解回溯思想和剪枝操作</h3><blockquote><p>给定两个整数 n 和 k，返回范围 [1, n] 中所有可能的 k 个数的组合。<br>你可以按 任何顺序 返回答案。<br>示例 1：<br>输入：n &#x3D; 4, k &#x3D; 2<br>输出：<br>[<br>  [2,4],<br>  [3,4],<br>  [2,3],<br>  [1,2],<br>  [1,3],<br>  [1,4],<br>]</p></blockquote><p>画图便于理解回溯，每次记录路径以便于回溯。剪枝剪掉长度不到k的无效路径。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-comment">// 记录每次的路径</span><br>    LinkedList&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">combine</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k)</span> &#123;<br>        backtracking(n, k, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> startIndex)</span>&#123;<br>        <span class="hljs-keyword">if</span>(path.size() == k)&#123;<br>            res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 剪枝操作，避免无效遍历，因为这些剪枝的长度到不了k</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> startIndex; i &lt;= n - (k - path.size()) + <span class="hljs-number">1</span>; i++)&#123;<br>            path.add(i);<br>            backtracking(n, k, i + <span class="hljs-number">1</span>);<br>            path.removeLast(); <span class="hljs-comment">// 回溯</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="组合总和——前置剪枝与后置剪枝"><a href="#组合总和——前置剪枝与后置剪枝" class="headerlink" title="组合总和——前置剪枝与后置剪枝"></a>组合总和——前置剪枝与后置剪枝</h4><blockquote><p>找出所有相加之和为 n 的 k 个数的组合，且满足下列条件：<br>只使用数字1到9<br>每个数字 最多使用一次<br>返回 所有可能的有效组合的列表 。该列表不能包含相同的组合两次，组合可以以任何顺序返回。</p></blockquote><p>前置剪枝更复杂，但是效率更高。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    LinkedList&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">combinationSum3</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-comment">// backtracking1(k, n, 0, 1);</span><br>        backtracking2(k, n, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-comment">// 前置剪枝，剪掉永远不会到达path.size() == k的部分</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracking1</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> sum, <span class="hljs-type">int</span> startIndex)</span>&#123;<br>        <span class="hljs-keyword">if</span>(sum &gt; n) <span class="hljs-keyword">return</span>;<br><br>        <span class="hljs-keyword">if</span>(path.size() == k)&#123;<br>            <span class="hljs-keyword">if</span>(sum == n) res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> startIndex; i &lt;= <span class="hljs-number">9</span> - (k - path.size()) + <span class="hljs-number">1</span>; i++)&#123;<br>            path.add(i);<br>            sum += i;<br>            backtracking1(k, n, sum, i + <span class="hljs-number">1</span>);<br>            sum -= i;<br>            path.removeLast();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 后置剪枝，剪掉path.size() &gt; k的部分，及时止损</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracking2</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> sum, <span class="hljs-type">int</span> startIndex)</span>&#123;<br>        <span class="hljs-keyword">if</span>(sum &gt; n) <span class="hljs-keyword">return</span>;<br><br>        <span class="hljs-keyword">if</span>(path.size() &gt; k) <span class="hljs-keyword">return</span>;<br><br>        <span class="hljs-keyword">if</span>(sum == n &amp;&amp; path.size() == k)&#123;<br>            res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> startIndex; i &lt;= <span class="hljs-number">9</span>; i++)&#123;<br>            path.add(i);<br>            sum += i;<br>            backtracking2(k, n, sum, i + <span class="hljs-number">1</span>);<br>            sum -= i;<br>            path.removeLast();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="电话号码的字母组合——理解回溯的层数"><a href="#电话号码的字母组合——理解回溯的层数" class="headerlink" title="电话号码的字母组合——理解回溯的层数"></a>电话号码的字母组合——理解回溯的层数</h4><blockquote><p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。<br>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p></blockquote><p>用数组记录按键与字母的关系，理解回溯的层数与path处理的关系，画图理解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;String&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>    String[] numString = &#123;<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-string">&quot;def&quot;</span>, <span class="hljs-string">&quot;ghi&quot;</span>, <span class="hljs-string">&quot;jkl&quot;</span>, <span class="hljs-string">&quot;mno&quot;</span>, <span class="hljs-string">&quot;pqrs&quot;</span>, <span class="hljs-string">&quot;tuv&quot;</span>, <span class="hljs-string">&quot;wxyz&quot;</span>&#125;;<br><br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">letterCombinations</span><span class="hljs-params">(String digits)</span> &#123;<br>        <span class="hljs-keyword">if</span>(digits == <span class="hljs-literal">null</span> || digits.length() == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br>        backtracking(digits, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(String digits, <span class="hljs-type">int</span> num)</span>&#123;<br>        <span class="hljs-comment">// num记录digits的第几位</span><br>        <span class="hljs-keyword">if</span>(num == digits.length())&#123;<br>            res.add(path.toString());<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> numString[digits.charAt(num) - <span class="hljs-string">&#x27;0&#x27;</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; str.length(); i++)&#123;<br>            <span class="hljs-comment">// path的每一位表示的是第几层，在这里表示第几位</span><br>            path.append(str.charAt(i));<br>            backtracking(digits, num + <span class="hljs-number">1</span>);<br>            path.deleteCharAt(path.length() - <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="分割回文串"><a href="#分割回文串" class="headerlink" title="分割回文串"></a>分割回文串</h3><blockquote><p>给你一个字符串 s，请你将 s 分割成一些 子串，使每个子串都是 回文串 。返回 s 所有可能的分割方案。<br>示例 1：<br>输入：s &#x3D; “aab”<br>输出：[[“a”,”a”,”b”],[“aa”,”b”]]<br>示例 2：<br>输入：s &#x3D; “a”<br>输出：[[“a”]]</p></blockquote><p>切割问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;String&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    List&lt;String&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="hljs-title function_">partition</span><span class="hljs-params">(String s)</span> &#123;<br>        backtracking(s, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> startIndex)</span>&#123;<br>        <span class="hljs-keyword">if</span>(startIndex == s.length())&#123;<br>            res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> startIndex; i &lt; s.length(); i++)&#123;<br>            sb.append(s.charAt(i)); <span class="hljs-comment">// 寻找回文前缀</span><br>            <span class="hljs-keyword">if</span>(check(sb))&#123;<br>                path.add(sb.toString());<br>                backtracking(s, i + <span class="hljs-number">1</span>);<br>                path.removeLast();<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 这里还可以用动态规划优化</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">check</span><span class="hljs-params">(StringBuilder sb)</span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; sb.length() / <span class="hljs-number">2</span>; i++)&#123;<br>            <span class="hljs-keyword">if</span>(sb.charAt(i) != sb.charAt(sb.length() - i - <span class="hljs-number">1</span>))&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="复原-IP-地址——利用判断合法剪枝"><a href="#复原-IP-地址——利用判断合法剪枝" class="headerlink" title="复原 IP 地址——利用判断合法剪枝"></a>复原 IP 地址——利用判断合法剪枝</h4><blockquote><p>有效 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 ‘.’ 分隔。<br>例如：”0.1.2.201” 和 “192.168.1.1” 是 有效 IP 地址，但是 “0.011.255.245”、”192.168.1.312” 和 “<a href="mailto:&#x31;&#x39;&#50;&#x2e;&#49;&#x36;&#56;&#64;&#49;&#x2e;&#x31;">192.168@1.1</a>“ 是 无效 IP 地址。<br>给定一个只包含数字的字符串 s ，用以表示一个 IP 地址，返回所有可能的有效 IP 地址，这些地址可以通过在 s 中插入 ‘.’ 来形成。你 不能 重新排序或删除 s 中的任何数字。你可以按 任何 顺序返回答案。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;String&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br><br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">restoreIpAddresses</span><span class="hljs-params">(String s)</span> &#123;<br>        backtracking(s, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> startIndex, <span class="hljs-type">int</span> dotNum)</span>&#123;<br>        <span class="hljs-keyword">if</span>(startIndex == s.length() &amp;&amp; dotNum == <span class="hljs-number">4</span>)&#123;<br>            res.add(sb.toString());<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 非法</span><br>        <span class="hljs-keyword">if</span>(startIndex == s.length() || dotNum == <span class="hljs-number">4</span>)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 剪枝方法：整数介于[0,255]，因此最多三位</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> startIndex; i &lt; s.length() &amp;&amp; i - startIndex &lt; <span class="hljs-number">3</span> &amp;&amp; Integer.parseInt(s.substring(startIndex, i + <span class="hljs-number">1</span>)) &gt;= <span class="hljs-number">0</span> &amp;&amp; Integer.parseInt(s.substring(startIndex, i + <span class="hljs-number">1</span>)) &lt;= <span class="hljs-number">255</span>; i++)&#123;<br>            <span class="hljs-comment">// 非零开头</span><br>            <span class="hljs-keyword">if</span>(i + <span class="hljs-number">1</span> - startIndex &gt; <span class="hljs-number">1</span> &amp;&amp; s.charAt(startIndex) == <span class="hljs-string">&#x27;0&#x27;</span>)&#123;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            sb.append(s.substring(startIndex, i + <span class="hljs-number">1</span>));<br>            <span class="hljs-comment">// 加dot</span><br>            <span class="hljs-keyword">if</span>(dotNum &lt; <span class="hljs-number">3</span>) sb.append(<span class="hljs-string">&quot;.&quot;</span>);<br>            backtracking(s, i + <span class="hljs-number">1</span>, dotNum + <span class="hljs-number">1</span>);<br>            sb.delete(startIndex + dotNum, i + dotNum + <span class="hljs-number">2</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="子集"><a href="#子集" class="headerlink" title="子集"></a>子集</h3><blockquote><p>给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。<br>解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。</p></blockquote><p>不同于组合和切割问题，树上的每个节点都要压入结果集。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    LinkedList&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">subsets</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        backtracking(nums, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> startIndex)</span>&#123;<br>        res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(path)); <span class="hljs-comment">// 树上的每个节点都要放上去</span><br>        <span class="hljs-keyword">if</span>(startIndex &gt;= nums.length)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> startIndex; i &lt; nums.length; i++)&#123;<br>            path.add(nums[i]);<br>            backtracking(nums, i + <span class="hljs-number">1</span>);<br>            path.removeLast();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="非递减子序列——利用哈希表去重"><a href="#非递减子序列——利用哈希表去重" class="headerlink" title="非递减子序列——利用哈希表去重"></a>非递减子序列——利用哈希表去重</h4><blockquote><p>给你一个整数数组 nums ，找出并返回所有该数组中不同的递增子序列，递增子序列中 至少有两个元素 。你可以按 任意顺序 返回答案。<br>数组中可能含有重复元素，如出现两个整数相等，也可以视作递增序列的一种特殊情况。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">// 由于要找递增子序列，故不能排序，使用哈希表</span><br>    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    List&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">findSubsequences</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        backtracking(nums, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> startIndex)</span>&#123;<br>        <span class="hljs-keyword">if</span>(path.size() &gt;= <span class="hljs-number">2</span>)&#123;<br>            res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(path));<br>        &#125;<br>        HashSet&lt;Integer&gt; hs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> startIndex; i &lt; nums.length; i++)&#123;<br>            <span class="hljs-comment">// 保证递增和去重</span><br>            <span class="hljs-keyword">if</span>((!path.isEmpty() &amp;&amp; path.get(path.size() - <span class="hljs-number">1</span>) &gt; nums[i]) || hs.contains(nums[i]))&#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            hs.add(nums[i]);<br>            path.add(nums[i]);<br>            backtracking(nums, i + <span class="hljs-number">1</span>);<br>            path.removeLast();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h3><blockquote><p>给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。<br>示例 1：<br>输入：nums &#x3D; [1,2,3]<br>输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</p></blockquote><p>完全树不剪枝，故注意去重问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">// 使用完全树不剪枝，因此要注意去重</span><br>    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    List&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">permute</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        backtracking(nums);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <br>    <span class="hljs-comment">// 完全树用不到startIndex</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span>&#123;<br>        <span class="hljs-keyword">if</span>(path.size() == nums.length)&#123;<br>            res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++)&#123;<br>            <span class="hljs-keyword">if</span>(path.contains(nums[i]))&#123;<br>                <span class="hljs-comment">// 去重</span><br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            path.add(nums[i]);<br>            backtracking(nums);<br>            path.removeLast();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="全排列-II——去重的思想"><a href="#全排列-II——去重的思想" class="headerlink" title="全排列 II——去重的思想"></a>全排列 II——去重的思想</h4><blockquote><p>给定一个可包含重复数字的序列 nums ，按任意顺序 返回所有不重复的全排列。</p></blockquote><p>理解这里怎么去重的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    List&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">permuteUnique</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-comment">// used用于记录index的数字用过没有</span><br>        <span class="hljs-type">boolean</span>[] used = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[nums.length];<br>        <span class="hljs-comment">// 默认为false</span><br>        Arrays.fill(used, <span class="hljs-literal">false</span>);<br>        Arrays.sort(nums);<br>        backtracking(nums, used);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">boolean</span>[] used)</span>&#123;<br>        <span class="hljs-keyword">if</span>(path.size() == nums.length)&#123;<br>            res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++)&#123;<br>            <span class="hljs-comment">// used记录path用过没有，用过可以去用相等但没用过的数字；但没用过的话，说明在该层中用过相等的数字，会重复，不能使用</span><br>            <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i - <span class="hljs-number">1</span>] == nums[i] &amp;&amp; used[i - <span class="hljs-number">1</span>] == <span class="hljs-literal">false</span>)&#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            <span class="hljs-comment">// 用used去重的方法，这里不能用path.contains()的方法，因为有相等数字</span><br>            <span class="hljs-keyword">if</span>(used[i] == <span class="hljs-literal">false</span>)&#123;<br>                used[i] = <span class="hljs-literal">true</span>;<br>                path.add(nums[i]);<br>                backtracking(nums, used);<br>                path.removeLast();<br>                used[i] = <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="N皇后"><a href="#N皇后" class="headerlink" title="N皇后"></a>N皇后</h3><blockquote><p>按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。<br>n 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。<br>给你一个整数 n ，返回所有不同的 n 皇后问题 的解决方案。<br>每一种解法包含一个不同的 n 皇后问题 的棋子放置方案，该方案中 ‘Q’ 和 ‘.’ 分别代表了皇后和空位。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;String&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-type">boolean</span>[] usedCol, used45, used135;<br><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="hljs-title function_">solveNQueens</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        usedCol = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n]; <span class="hljs-comment">// 保证不在同一列</span><br>        used45 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[<span class="hljs-number">2</span> * n + <span class="hljs-number">1</span>]; <span class="hljs-comment">// 保证不在45度斜线内</span><br>        used135 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[<span class="hljs-number">2</span> * n + <span class="hljs-number">1</span>]; <span class="hljs-comment">// 保证不在135度斜线内</span><br>        <span class="hljs-comment">// 收集结果</span><br>        <span class="hljs-type">int</span>[] board = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        backtracking(board, n, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-comment">// 使用行来回溯</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span>[] board, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> row)</span>&#123;<br>        <span class="hljs-keyword">if</span>(row == n)&#123;<br>            <span class="hljs-comment">// 解释结果</span><br>            List&lt;String&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i : board)&#123;<br>                <span class="hljs-type">char</span>[] str = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[n];<br>                Arrays.fill(str, <span class="hljs-string">&#x27;.&#x27;</span>);<br>                str[i] = <span class="hljs-string">&#x27;Q&#x27;</span>;<br>                path.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(str));<br>            &#125;<br>            res.add(path);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">col</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; col &lt; n; col++)&#123;<br>            <span class="hljs-keyword">if</span>(usedCol[col] || used45[row + col] || used135[n - <span class="hljs-number">1</span> - col + row])&#123; <span class="hljs-comment">// 不在同一列和同一斜线上</span><br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            board[row] = col;<br>            usedCol[col] = <span class="hljs-literal">true</span>;<br>            used45[row + col] = <span class="hljs-literal">true</span>;<br>            used135[n - <span class="hljs-number">1</span> - col + row] = <span class="hljs-literal">true</span>;<br>            backtracking(board, n, row + <span class="hljs-number">1</span>);<br>            usedCol[col] = <span class="hljs-literal">false</span>;<br>            used45[row + col] = <span class="hljs-literal">false</span>;<br>            used135[n - <span class="hljs-number">1</span> - col + row] = <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="解数独"><a href="#解数独" class="headerlink" title="解数独"></a>解数独</h3><blockquote><p>编写一个程序，通过填充空格来解决数独问题。<br>数独的解法需 遵循如下规则：<br>数字 1-9 在每一行只能出现一次。<br>数字 1-9 在每一列只能出现一次。<br>数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。（请参考示例图）<br>数独部分空格内已填入了数字，空白格用 ‘.’ 表示。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">solveSudoku</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] board)</span> &#123;<br>        backtracking(board);<br>    &#125;<br><br>    <span class="hljs-comment">// 同样是唯一解，用boolean</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] board)</span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; i++)&#123; <span class="hljs-comment">// 遍历行</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">9</span>; j++)&#123; <span class="hljs-comment">// 遍历列</span><br>                <span class="hljs-keyword">if</span>(board[i][j] != <span class="hljs-string">&#x27;.&#x27;</span>)&#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;1&#x27;</span>; k &lt;= <span class="hljs-string">&#x27;9&#x27;</span>; k++)&#123;<br>                    <span class="hljs-keyword">if</span>(isValid(i, j, k, board))&#123;<br>                        board[i][j] = k;<br>                        <span class="hljs-keyword">if</span>(backtracking(board))&#123;<br>                            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                        &#125;<br>                        board[i][j] = <span class="hljs-string">&#x27;.&#x27;</span>;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(<span class="hljs-type">int</span> row, <span class="hljs-type">int</span> column, <span class="hljs-type">char</span> val, <span class="hljs-type">char</span>[][] board)</span>&#123;<br>        <span class="hljs-comment">// 同行是否重复</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; i++)&#123;<br>            <span class="hljs-keyword">if</span>(board[row][i] == val)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 同列是否重复</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; i++)&#123;<br>            <span class="hljs-keyword">if</span>(board[i][column] == val)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 九宫格内是否重复</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">startRow</span> <span class="hljs-operator">=</span> (row / <span class="hljs-number">3</span>) * <span class="hljs-number">3</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">startColumn</span> <span class="hljs-operator">=</span> (column / <span class="hljs-number">3</span>) * <span class="hljs-number">3</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> startRow; i &lt; startRow + <span class="hljs-number">3</span>; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> startColumn; j &lt; startColumn + <span class="hljs-number">3</span>; j++)&#123;<br>                <span class="hljs-keyword">if</span>(board[i][j] == val)&#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
      <category>代码随想录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>missing semester笔记</title>
    <link href="/2025/06/08/missing-semester%E7%AC%94%E8%AE%B0/"/>
    <url>/2025/06/08/missing-semester%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="shell指令"><a href="#shell指令" class="headerlink" title="shell指令"></a>shell指令</h2><p>罗列一些常见的shell指令供翻阅与学习</p><h3 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h3><h4 id="–help和man-查阅帮助"><a href="#–help和man-查阅帮助" class="headerlink" title="–help和man: 查阅帮助"></a>–help和man: 查阅帮助</h4><p>使用man命令手册查阅命令的详细说明和参数，或者–help</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">man <span class="hljs-built_in">ls</span><br><span class="hljs-built_in">ls</span> --<span class="hljs-built_in">help</span><br></code></pre></td></tr></table></figure><h4 id="在程序间创建连接"><a href="#在程序间创建连接" class="headerlink" title="在程序间创建连接"></a>在程序间创建连接</h4><p>默认的输入流和输出流分别为键盘和显示屏，但是 <code>&lt; file</code> 和 <code>&gt; file</code> 可以将输入输出重定向到文件；如果要追加，使用 <code>&gt;&gt;</code> ；而使用 <code>|</code> 可以将一个程序的输出和另一个程序的输入连接起来</p><h4 id="命令分隔符"><a href="#命令分隔符" class="headerlink" title="命令分隔符"></a>命令分隔符</h4><ul><li><code>;</code>: 无论前面命令是否执行成功，都会执行后面的命令</li><li><code>&amp;&amp;</code>: 前面命令执行成功时才执行后面的命令</li><li><code>||</code>: 前面命令执行失败时才执行后面的命令</li></ul><h4 id="子命令"><a href="#子命令" class="headerlink" title="子命令"></a>子命令</h4><p>用于把一个命令的输出结果作为另一个命令的参数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;共有 <span class="hljs-subst">$(ls | wc -l)</span> 个文件&quot;</span><br><span class="hljs-built_in">cat</span> $(find . -name <span class="hljs-string">&quot;*.log&quot;</span>)           <span class="hljs-comment"># 把所有 .log 文件合并显示</span><br></code></pre></td></tr></table></figure><h4 id="执行文件"><a href="#执行文件" class="headerlink" title="执行文件"></a>执行文件</h4><p>使用 <code>./file</code> 即可</p><h4 id="相对路径和绝对路径"><a href="#相对路径和绝对路径" class="headerlink" title="相对路径和绝对路径"></a>相对路径和绝对路径</h4><p>注意 <code>/</code> 代表系统的根目录；某个路径以 <code>/</code> 开头，则为绝对路径，否则为相对路径； <code>.</code> 表示当前目录， <code>..</code> 则表示上级目录</p><h4 id="关于权限"><a href="#关于权限" class="headerlink" title="关于权限"></a>关于权限</h4><p>每个文件或目录都有三类用户的权限：</p><ul><li>u: 文件所有者</li><li>g: 文件所属组</li><li>o: 其他用户</li><li>a: 所有用户，即u+g+o</li></ul><p>每类用户用三个字母表示其权限：</p><ul><li>r: 读，查看内容</li><li>w: 写，修改内容</li><li>x: 执行文件或进入目录</li><li>-: 不具备此权限</li></ul><p>权限可以使用数字法表示，即三种权限代表的数字相加，三个数字分别对应三类用户，其中：</p><ul><li>r &#x3D; 4</li><li>w &#x3D; 2</li><li>x &#x3D; 1</li></ul><p>也可以使用字母符号法：</p><ul><li>+: 添加权限</li><li>-: 去除权限</li><li>&#x3D;: 设置为指定权限</li></ul><h3 id="常用的shell指令"><a href="#常用的shell指令" class="headerlink" title="常用的shell指令"></a>常用的shell指令</h3><h4 id="ls-列出目录内容，即里面的文件和文件夹"><a href="#ls-列出目录内容，即里面的文件和文件夹" class="headerlink" title="ls: 列出目录内容，即里面的文件和文件夹"></a>ls: 列出目录内容，即里面的文件和文件夹</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">ls</span>              <span class="hljs-comment"># 简单列出当前目录内容</span><br><span class="hljs-built_in">ls</span> -l           <span class="hljs-comment"># 详细信息（权限、大小、时间等）</span><br><span class="hljs-built_in">ls</span> -a           <span class="hljs-comment"># 显示所有文件，包括以 . 开头的隐藏文件</span><br><span class="hljs-built_in">ls</span> -lh          <span class="hljs-comment"># 详细信息并以可读单位显示文件大小</span><br><span class="hljs-built_in">ls</span> /path        <span class="hljs-comment"># 查看指定路径</span><br><span class="hljs-built_in">ls</span> --color=auto <span class="hljs-comment"># 彩色打印结果</span><br><span class="hljs-built_in">ls</span> -t           <span class="hljs-comment"># 以最近访问顺序排序</span><br></code></pre></td></tr></table></figure><h4 id="cd-切换目录"><a href="#cd-切换目录" class="headerlink" title="cd: 切换目录"></a>cd: 切换目录</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /home/user    <span class="hljs-comment"># 切换到指定目录</span><br><span class="hljs-built_in">cd</span> ~             <span class="hljs-comment"># 切换到当前用户主目录</span><br><span class="hljs-built_in">cd</span> ..            <span class="hljs-comment"># 返回上一级目录</span><br><span class="hljs-built_in">cd</span> -             <span class="hljs-comment"># 回到上一次所在目录</span><br></code></pre></td></tr></table></figure><h4 id="pwd-显示当前目录的完整路径"><a href="#pwd-显示当前目录的完整路径" class="headerlink" title="pwd: 显示当前目录的完整路径"></a>pwd: 显示当前目录的完整路径</h4><h4 id="mkdir-创建新目录"><a href="#mkdir-创建新目录" class="headerlink" title="mkdir: 创建新目录"></a>mkdir: 创建新目录</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> newdir                 <span class="hljs-comment"># 创建一个新目录</span><br><span class="hljs-built_in">mkdir</span> -p /tmp/dir1/dir2      <span class="hljs-comment"># 递归创建多级目录</span><br></code></pre></td></tr></table></figure><h4 id="rm-删除文件或目录"><a href="#rm-删除文件或目录" class="headerlink" title="rm: 删除文件或目录"></a>rm: 删除文件或目录</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">rm</span> file.txt                <span class="hljs-comment"># 删除文件</span><br><span class="hljs-built_in">rm</span> -r <span class="hljs-built_in">dir</span>                  <span class="hljs-comment"># 递归删除目录及其内容</span><br><span class="hljs-built_in">rm</span> -f file.txt             <span class="hljs-comment"># 强制删除，不提示</span><br><span class="hljs-built_in">rm</span> -rf <span class="hljs-built_in">dir</span>                 <span class="hljs-comment"># 递归强制删除目录</span><br></code></pre></td></tr></table></figure><h4 id="cp-复制文件或目录"><a href="#cp-复制文件或目录" class="headerlink" title="cp: 复制文件或目录"></a>cp: 复制文件或目录</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cp</span> source.txt dest.txt         <span class="hljs-comment"># 复制文件</span><br><span class="hljs-built_in">cp</span> -r dir1 dir2                <span class="hljs-comment"># 递归复制目录</span><br><span class="hljs-built_in">cp</span> file1 file2 /some/dir/      <span class="hljs-comment"># 复制多个文件到目录</span><br></code></pre></td></tr></table></figure><h4 id="mv-移动或重命名文件或目录"><a href="#mv-移动或重命名文件或目录" class="headerlink" title="mv: 移动或重命名文件或目录"></a>mv: 移动或重命名文件或目录</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mv</span> old.txt new.txt             <span class="hljs-comment"># 重命名文件</span><br><span class="hljs-built_in">mv</span> file.txt /new/dir/          <span class="hljs-comment"># 移动文件到新目录</span><br><span class="hljs-built_in">mv</span> dir1 dir2 /path/            <span class="hljs-comment"># 移动多个文件/目录</span><br></code></pre></td></tr></table></figure><h4 id="cat-查看文件内容、合并文件、快速创建文件"><a href="#cat-查看文件内容、合并文件、快速创建文件" class="headerlink" title="cat: 查看文件内容、合并文件、快速创建文件"></a>cat: 查看文件内容、合并文件、快速创建文件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> file.txt                  <span class="hljs-comment"># 显示文件内容</span><br><span class="hljs-built_in">cat</span> file1 file2 &gt; merged.txt  <span class="hljs-comment"># 合并两个文件为一个新文件</span><br><span class="hljs-built_in">cat</span> &gt; newfile.txt             <span class="hljs-comment"># 创建新文件并输入内容（Ctrl+D结束）</span><br></code></pre></td></tr></table></figure><h4 id="more-less-分页显示文件内容"><a href="#more-less-分页显示文件内容" class="headerlink" title="more&#x2F;less: 分页显示文件内容"></a>more&#x2F;less: 分页显示文件内容</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">more file.txt<br>less file.txt<br></code></pre></td></tr></table></figure><h4 id="head-查看文件开头内容"><a href="#head-查看文件开头内容" class="headerlink" title="head: 查看文件开头内容"></a>head: 查看文件开头内容</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">head</span> file.txt           <span class="hljs-comment"># 默认显示前10行</span><br><span class="hljs-built_in">head</span> -n 20 file.txt     <span class="hljs-comment"># 显示前20行</span><br></code></pre></td></tr></table></figure><h4 id="tail-查看文件结尾内容"><a href="#tail-查看文件结尾内容" class="headerlink" title="tail: 查看文件结尾内容"></a>tail: 查看文件结尾内容</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">tail</span> file.txt           <span class="hljs-comment"># 默认显示后10行</span><br><span class="hljs-built_in">tail</span> -n 20 file.txt     <span class="hljs-comment"># 显示后20行</span><br><span class="hljs-built_in">tail</span> -f log.txt         <span class="hljs-comment"># 实时跟踪文件新增内容</span><br></code></pre></td></tr></table></figure><h4 id="touch-创建新的空文件，或者更新已存在文件的时间戳"><a href="#touch-创建新的空文件，或者更新已存在文件的时间戳" class="headerlink" title="touch: 创建新的空文件，或者更新已存在文件的时间戳"></a>touch: 创建新的空文件，或者更新已存在文件的时间戳</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">touch</span> file.txt            <span class="hljs-comment"># 创建空文件或更新时间戳</span><br><span class="hljs-built_in">touch</span> file1 file2         <span class="hljs-comment"># 同时创建/更新时间戳多个文件</span><br></code></pre></td></tr></table></figure><h4 id="echo-输出文本或变量的值"><a href="#echo-输出文本或变量的值" class="headerlink" title="echo: 输出文本或变量的值"></a>echo: 输出文本或变量的值</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Hello, world!&quot;</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$HOME</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;PATH is <span class="hljs-variable">$PATH</span>&quot;</span><br></code></pre></td></tr></table></figure><h4 id="grep-根据字符串或正则表达式搜索文本内容"><a href="#grep-根据字符串或正则表达式搜索文本内容" class="headerlink" title="grep: 根据字符串或正则表达式搜索文本内容"></a>grep: 根据字符串或正则表达式搜索文本内容</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">grep <span class="hljs-string">&quot;pattern&quot;</span> file.txt             <span class="hljs-comment"># 查找文件中包含&quot;pattern&quot;的行</span><br>grep -i <span class="hljs-string">&quot;pattern&quot;</span> file.txt          <span class="hljs-comment"># 忽略大小写</span><br>grep -r <span class="hljs-string">&quot;pattern&quot;</span> ./dir             <span class="hljs-comment"># 递归搜索目录</span><br>grep -n <span class="hljs-string">&quot;pattern&quot;</span> file.txt          <span class="hljs-comment"># 显示行号</span><br>grep -v <span class="hljs-string">&quot;pattern&quot;</span> file.txt           <span class="hljs-comment"># 反向匹配（不包含 pattern 的行）</span><br></code></pre></td></tr></table></figure><h4 id="sort-对文件每一行进行排序"><a href="#sort-对文件每一行进行排序" class="headerlink" title="sort: 对文件每一行进行排序"></a>sort: 对文件每一行进行排序</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sort</span> file.txt                        <span class="hljs-comment"># 按字母顺序排序</span><br><span class="hljs-built_in">sort</span> -n file.txt                     <span class="hljs-comment"># 按数字排序</span><br><span class="hljs-built_in">sort</span> -r file.txt                     <span class="hljs-comment"># 反向排序（降序）</span><br><span class="hljs-built_in">sort</span> -k 2 file.txt                   <span class="hljs-comment"># 按第2列排序（默认以空格/制表符分隔）</span><br><span class="hljs-built_in">sort</span> -u file.txt                     <span class="hljs-comment"># 排序后去重</span><br></code></pre></td></tr></table></figure><h4 id="uniq-删除重复行"><a href="#uniq-删除重复行" class="headerlink" title="uniq: 删除重复行"></a>uniq: 删除重复行</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">uniq</span> file.txt                        <span class="hljs-comment"># 去除重复行（需先排序）</span><br><span class="hljs-built_in">sort</span> file.txt | <span class="hljs-built_in">uniq</span>                 <span class="hljs-comment"># 先排序再去重</span><br><span class="hljs-built_in">uniq</span> -c file.txt                     <span class="hljs-comment"># 统计每个唯一行出现的次数</span><br><span class="hljs-built_in">uniq</span> -d file.txt                     <span class="hljs-comment"># 只显示重复的行</span><br></code></pre></td></tr></table></figure><h4 id="awk-功能多样"><a href="#awk-功能多样" class="headerlink" title="awk: 功能多样"></a>awk: 功能多样</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">awk <span class="hljs-string">&#x27;&#123;print $1&#125;&#x27;</span> file.txt            <span class="hljs-comment"># 打印第一列</span><br>awk -F <span class="hljs-string">&#x27;:&#x27;</span> <span class="hljs-string">&#x27;&#123;print $1, $3&#125;&#x27;</span> /etc/passwd  <span class="hljs-comment"># 指定分隔符</span><br>awk <span class="hljs-string">&#x27;$3 &gt; 1000 &#123;print $1&#125;&#x27;</span> /etc/passwd   <span class="hljs-comment"># 条件筛选</span><br>awk <span class="hljs-string">&#x27;&#123;sum += $2&#125; END &#123;print sum&#125;&#x27;</span> file.txt  <span class="hljs-comment"># 汇总第二列</span><br></code></pre></td></tr></table></figure><h4 id="cut-按列提取文本"><a href="#cut-按列提取文本" class="headerlink" title="cut: 按列提取文本"></a>cut: 按列提取文本</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cut</span> -d <span class="hljs-string">&#x27;:&#x27;</span> -f 1 /etc/passwd          <span class="hljs-comment"># 以 : 为分隔符，提取第1列</span><br><span class="hljs-built_in">cut</span> -c 1-5 file.txt                  <span class="hljs-comment"># 提取每行的第1至5个字符</span><br><span class="hljs-built_in">cut</span> -f2,4 -d<span class="hljs-string">&#x27;,&#x27;</span> data.csv             <span class="hljs-comment"># 以逗号为分隔符，提取第2和第4列</span><br></code></pre></td></tr></table></figure><h4 id="sed-流编辑器，批量处理文本内容"><a href="#sed-流编辑器，批量处理文本内容" class="headerlink" title="sed: 流编辑器，批量处理文本内容"></a>sed: 流编辑器，批量处理文本内容</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">sed <span class="hljs-string">&#x27;s/old/new/&#x27;</span> file.txt          <span class="hljs-comment"># 替换每行第一个old为new（s为替换）</span><br>sed <span class="hljs-string">&#x27;s/old/new/g&#x27;</span> file.txt         <span class="hljs-comment"># 替换每行所有old为new（s为替换，g为全局）</span><br>sed <span class="hljs-string">&#x27;2d&#x27;</span> file.txt                  <span class="hljs-comment"># 删除第二行</span><br>sed <span class="hljs-string">&#x27;2,4d&#x27;</span> file.txt                <span class="hljs-comment"># 删除第2到4行</span><br>sed -n <span class="hljs-string">&#x27;5,10p&#x27;</span> file.txt            <span class="hljs-comment"># 只显示第5到10行</span><br>sed <span class="hljs-string">&#x27;2i\插入内容&#x27;</span> file.txt         <span class="hljs-comment"># 在第二行前插入内容</span><br>sed <span class="hljs-string">&#x27;2a\追加内容&#x27;</span> file.txt         <span class="hljs-comment"># 在第二行后追加内容</span><br></code></pre></td></tr></table></figure><p>添加 <code>-e</code> 选项以支持多条指令， <code>-E</code> 选项以支持正则表达式</p><h4 id="wc-统计文件内容"><a href="#wc-统计文件内容" class="headerlink" title="wc: 统计文件内容"></a>wc: 统计文件内容</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">wc</span> -l file.txt         <span class="hljs-comment"># 行数</span><br><span class="hljs-built_in">wc</span> -w file.txt         <span class="hljs-comment"># 单词数</span><br><span class="hljs-built_in">wc</span> -c file.txt         <span class="hljs-comment"># 字节数</span><br></code></pre></td></tr></table></figure><h4 id="diff-cmp-比较文件差异"><a href="#diff-cmp-比较文件差异" class="headerlink" title="diff&#x2F;cmp: 比较文件差异"></a>diff&#x2F;cmp: 比较文件差异</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">diff file1.txt file2.txt<br>cmp file1.txt file2.txt<br></code></pre></td></tr></table></figure><h4 id="find-查找文件或目录"><a href="#find-查找文件或目录" class="headerlink" title="find: 查找文件或目录"></a>find: 查找文件或目录</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">find . -name <span class="hljs-string">&quot;*.txt&quot;</span>                <span class="hljs-comment"># 当前目录下查找所有txt文件</span><br>find /home -<span class="hljs-built_in">type</span> d -name <span class="hljs-string">&quot;test*&quot;</span>    <span class="hljs-comment"># 查找以test开头的目录</span><br>find . -size +10M                   <span class="hljs-comment"># 查找大于10M的文件</span><br></code></pre></td></tr></table></figure><h4 id="locate-在系统索引数据库中快速查找文件"><a href="#locate-在系统索引数据库中快速查找文件" class="headerlink" title="locate: 在系统索引数据库中快速查找文件"></a>locate: 在系统索引数据库中快速查找文件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">locate bashrc<br></code></pre></td></tr></table></figure><p>使用 <code>updatedb</code> 定期更新数据库</p><h4 id="chmod-修改权限"><a href="#chmod-修改权限" class="headerlink" title="chmod: 修改权限"></a>chmod: 修改权限</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">chmod</span> 777 test.txt         <span class="hljs-comment"># 所有人全部权限</span><br><span class="hljs-built_in">chmod</span> 644 test.txt         <span class="hljs-comment"># 所有者rw，组/其他r</span><br><span class="hljs-built_in">chmod</span> 600 secret.txt       <span class="hljs-comment"># 只有所有者可读写</span><br><span class="hljs-built_in">chmod</span> +x run.sh            <span class="hljs-comment"># 给所有用户添加可执行权限</span><br><span class="hljs-built_in">chmod</span> -R 755 /path/dir     <span class="hljs-comment"># 递归更改目录及其内容权限</span><br><span class="hljs-built_in">chmod</span> u+x file.sh          <span class="hljs-comment"># 给所有者添加执行权限</span><br><span class="hljs-built_in">chmod</span> go-w file.txt        <span class="hljs-comment"># 移除组和其他用户的写权限</span><br><span class="hljs-built_in">chmod</span> a=r myfile           <span class="hljs-comment"># 所有人只有读权限</span><br><span class="hljs-built_in">chmod</span> u=rw,go=r data.txt   <span class="hljs-comment"># u:读写，g/o:只读</span><br></code></pre></td></tr></table></figure><h4 id="chown-修改所有者和所属组"><a href="#chown-修改所有者和所属组" class="headerlink" title="chown: 修改所有者和所属组"></a>chown: 修改所有者和所属组</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">chown</span> user file.txt<br><span class="hljs-built_in">chown</span> user:group file.txt<br></code></pre></td></tr></table></figure><h4 id="su-sudo-切换用户-以管理者身份执行命令"><a href="#su-sudo-切换用户-以管理者身份执行命令" class="headerlink" title="su&#x2F;sudo: 切换用户&#x2F;以管理者身份执行命令"></a>su&#x2F;sudo: 切换用户&#x2F;以管理者身份执行命令</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">su               <span class="hljs-comment"># 切换到root用户，需要输入root密码</span><br><span class="hljs-built_in">sudo</span> <span class="hljs-built_in">command</span>     <span class="hljs-comment"># 以root权限执行command</span><br></code></pre></td></tr></table></figure><h4 id="ps-查看进程"><a href="#ps-查看进程" class="headerlink" title="ps: 查看进程"></a>ps: 查看进程</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">ps                <span class="hljs-comment"># 查看当前shell的进程</span><br>ps aux            <span class="hljs-comment"># 查看所有进程</span><br>ps -ef            <span class="hljs-comment"># 另一种详细格式</span><br></code></pre></td></tr></table></figure><h4 id="top-htop-动态显示系统进程和资源占用情况"><a href="#top-htop-动态显示系统进程和资源占用情况" class="headerlink" title="top&#x2F;htop: 动态显示系统进程和资源占用情况"></a>top&#x2F;htop: 动态显示系统进程和资源占用情况</h4><h4 id="kill-终止进程"><a href="#kill-终止进程" class="headerlink" title="kill: 终止进程"></a>kill: 终止进程</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">kill</span> PID                <span class="hljs-comment"># 结束指定进程</span><br><span class="hljs-built_in">kill</span> -9 PID             <span class="hljs-comment"># 强制杀死进程</span><br></code></pre></td></tr></table></figure><h4 id="df-查看磁盘大小"><a href="#df-查看磁盘大小" class="headerlink" title="df: 查看磁盘大小"></a>df: 查看磁盘大小</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">df</span> -h                  <span class="hljs-comment"># 以可读单位显示磁盘使用情况</span><br></code></pre></td></tr></table></figure><h4 id="du-查看文件或目录大小"><a href="#du-查看文件或目录大小" class="headerlink" title="du: 查看文件或目录大小"></a>du: 查看文件或目录大小</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">du</span> -sh *               <span class="hljs-comment"># 显示当前目录下每个文件/目录的大小</span><br><span class="hljs-built_in">du</span> -h --max-depth=1    <span class="hljs-comment"># 只显示一级子目录大小</span><br></code></pre></td></tr></table></figure><h4 id="free-查看内存使用"><a href="#free-查看内存使用" class="headerlink" title="free: 查看内存使用"></a>free: 查看内存使用</h4><h4 id="uname-显示系统信息"><a href="#uname-显示系统信息" class="headerlink" title="uname: 显示系统信息"></a>uname: 显示系统信息</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">uname</span> -a                <span class="hljs-comment"># 显示全部信息</span><br><span class="hljs-built_in">uname</span> -r                <span class="hljs-comment"># 显示内核版本</span><br></code></pre></td></tr></table></figure><h4 id="ping-测试主机之间的网络连接"><a href="#ping-测试主机之间的网络连接" class="headerlink" title="ping: 测试主机之间的网络连接"></a>ping: 测试主机之间的网络连接</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">ping www.baidu.com<br>ping -c 4 www.baidu.com   <span class="hljs-comment"># 只ping 4次</span><br></code></pre></td></tr></table></figure><h4 id="ifconfig-ip-显示或配置网络接口信息"><a href="#ifconfig-ip-显示或配置网络接口信息" class="headerlink" title="ifconfig&#x2F;ip: 显示或配置网络接口信息"></a>ifconfig&#x2F;ip: 显示或配置网络接口信息</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ip a<br></code></pre></td></tr></table></figure><h4 id="curl-wget-从网络获取文件或数据"><a href="#curl-wget-从网络获取文件或数据" class="headerlink" title="curl&#x2F;wget: 从网络获取文件或数据"></a>curl&#x2F;wget: 从网络获取文件或数据</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl http://example.com<br>wget http://example.com/file.txt<br></code></pre></td></tr></table></figure><h4 id="history-查看历史命令"><a href="#history-查看历史命令" class="headerlink" title="history: 查看历史命令"></a>history: 查看历史命令</h4><h4 id="date-显示或设置系统时间"><a href="#date-显示或设置系统时间" class="headerlink" title="date: 显示或设置系统时间"></a>date: 显示或设置系统时间</h4><h4 id="clear-清屏"><a href="#clear-清屏" class="headerlink" title="clear: 清屏"></a>clear: 清屏</h4><h2 id="shell脚本"><a href="#shell脚本" class="headerlink" title="shell脚本"></a>shell脚本</h2><h3 id="脚本开头：shebang"><a href="#脚本开头：shebang" class="headerlink" title="脚本开头：shebang"></a>脚本开头：shebang</h3><p>用于指定解释器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">!/bin/bash<br></code></pre></td></tr></table></figure><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>使用变量时前面加上 <code>$</code> ；赋值时等号左右不能有空格，否则视为参数；分隔符 <code>&#39;</code> 中的变量不会被转义，而 <code>&quot;</code> 会将变量值进行替换；<code>$(CMD)</code> 实现命令替换，即用命令的输出进行替换；<code>&lt;(CMD)</code> 则会执行命令并将结果输出到一个临时文件中</p><h3 id="获取脚本参数"><a href="#获取脚本参数" class="headerlink" title="获取脚本参数"></a>获取脚本参数</h3><ul><li><code>$0</code>: 脚本名</li><li><code>$1</code>: 脚本的第一个参数</li><li><code>$@</code>: 所有参数（分开）</li><li><code>$*</code>: 所有参数（整体）</li><li><code>$#</code>: 参数个数</li><li><code>$?</code>: 前一个命令的返回值（退出状态）</li><li><code>$$</code>: 当前脚本的进程识别码</li><li><code>!!</code>: 完整的上一条命令（含参数）</li><li><code>$_</code>: 上一条命令的最后一个参数</li></ul><h3 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">if</span> [ condition ]; <span class="hljs-keyword">then</span><br>  command1<br><span class="hljs-keyword">elif</span> [ condition2 ]; <span class="hljs-keyword">then</span><br>  command2<br><span class="hljs-keyword">else</span><br>  command3<br><span class="hljs-keyword">fi</span><br></code></pre></td></tr></table></figure><p>常见条件运算符（整数）：</p><ul><li><code>-eq</code>: 等于</li><li><code>-ne</code>: 不等于</li><li><code>-gt</code>: 大于</li><li><code>-lt</code>: 小于</li><li><code>-ge</code>: 大于等于</li><li><code>-le</code>: 小于等于</li></ul><p>字符串判断：</p><ul><li><code>-z</code>: 字符串为空</li><li><code>-n</code>: 字符串非空</li></ul><p>文件判断：</p><ul><li><code>-e file</code>: 文件存在</li><li><code>-f file</code>: 普通文件</li><li><code>-d file</code>: 目录</li></ul><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"> <span class="hljs-keyword">for</span>循环<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> 1 2 3; <span class="hljs-keyword">do</span><br>  <span class="hljs-built_in">echo</span> <span class="hljs-variable">$i</span><br><span class="hljs-keyword">done</span><br><br><span class="hljs-keyword">for</span> file <span class="hljs-keyword">in</span> *.txt; <span class="hljs-keyword">do</span><br>  <span class="hljs-built_in">echo</span> <span class="hljs-variable">$file</span><br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"> <span class="hljs-keyword">while</span>循环<br>count=1<br><span class="hljs-keyword">while</span> [ <span class="hljs-variable">$count</span> -le 5 ]; <span class="hljs-keyword">do</span><br>  <span class="hljs-built_in">echo</span> <span class="hljs-variable">$count</span><br>  count=$((count+<span class="hljs-number">1</span>))<br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-function"><span class="hljs-title">myfunc</span></span>() &#123;<br>  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;参数1：<span class="hljs-variable">$1</span>&quot;</span><br>&#125;<br>myfunc <span class="hljs-string">&quot;hello&quot;</span><br></code></pre></td></tr></table></figure><p>使用 <code>source</code> 指令加载函数</p><h2 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h2><p>懒得看了，待补充，参考指令 <code>vimtutor</code> ，或者<a href="https://github.com/HanielF/VimTutor">vimtutor中文版</a></p><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>参考<a href="https://deerchao.cn/tutorials/regex/regex.htm">正则表达式30分钟入门教程</a></p><h3 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h3><ul><li><code>.</code>: 匹配除换行符以外的任意字符，在Singleline模式也会匹配换行符；如果是想查找 <code>.</code> 这个字符本身，请使用转义 <code>\.</code></li><li><code>\w</code>: 匹配字母或数字或下划线，等效于 <code>[A-Za-z0-9_]</code></li><li><code>\s</code>: 匹配任何空白符</li><li><code>\d</code>: 匹配数字</li><li><code>\b</code>: 匹配单词开头或结束，如 <code>\bhi\b</code> 精确匹配单词hi</li><li><code>^</code>: 匹配字符串的开始，在Multiline模式匹配行首</li><li><code>$</code>: 匹配字符串的结束</li></ul><h3 id="限定符"><a href="#限定符" class="headerlink" title="限定符"></a>限定符</h3><ul><li><code>*</code>: 重复零次或更多次</li><li><code>+</code>: 重复一次或更多次</li><li><code>?</code>: 重复零次或一次</li><li><code>&#123;n&#125;</code>: 重复n次</li><li><code>&#123;n,&#125;</code>: 重复n次或更多次</li><li><code>&#123;n,m&#125;</code>: 重复n到m次</li></ul><p>注意限定符默认贪婪，即匹配尽可能多的字符，如 <code>a.*b</code> 匹配最长的a开始b结束的字符串；为了懒惰，即匹配尽可能少的字符，在限定符后加上 <code>?</code> 即可</p><h3 id="字符类"><a href="#字符类" class="headerlink" title="字符类"></a>字符类</h3><p>使用方括号，如 <code>[aeiou]</code> 匹配任意一个元音字母， <code>[0-9]</code> 等效于 <code>\d</code></p><h3 id="分枝条件"><a href="#分枝条件" class="headerlink" title="分枝条件"></a>分枝条件</h3><p>使用 <code>|</code> 匹配多个规则，类似于or，因此也要注意条件顺序</p><h3 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h3><p>使用圆括号来分组，从而匹配括号里的子表达式，并可以使用限定符约束；在这样做时实现了捕获，正则表达式从左到右为每个分组分配一个组号，后续使用 <code>\1</code> 可以代表分组1的文本（而分组0代表整个正则表达式）</p><h4 id="捕获"><a href="#捕获" class="headerlink" title="捕获"></a>捕获</h4><ul><li><code>(exp)</code>: 匹配exp，并捕获文本到自动命名的组里</li><li><code>(?&lt;name&gt;exp)</code>: 匹配exp，并捕获文本到名称为name的组里，也可以写成 <code>(?&#39;name&#39;exp)</code></li><li><code>(?:exp)</code>: 匹配exp，不捕获匹配的文本，也不给此分组分配组号</li></ul><h4 id="零宽断言"><a href="#零宽断言" class="headerlink" title="零宽断言"></a>零宽断言</h4><p>如 <code>(?=exp)</code> 断言自身出现的位置的后面能匹配表达式exp，如 <code>\b\w+(?=ing\b)</code> 匹配以ing结尾的单词的前面的部分（除了ing以外的部分）</p><ul><li><code>(?=exp)</code>: 匹配exp前面的位置</li><li><code>(?&lt;=exp)</code>: 匹配exp后面的位置</li><li><code>(?!exp)</code>: 匹配后面跟的不是exp的位置</li><li><code>(?&lt;!exp)</code>: 匹配前面不是exp的位置</li></ul><h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h4><p>使用 <code>(?#comment)</code> 写注释</p><h3 id="反义"><a href="#反义" class="headerlink" title="反义"></a>反义</h3><ul><li><code>\W</code>: 匹配任意不是字母，数字，下划线的字符</li><li><code>\S</code>: 匹配任意不是空白符的字符</li><li><code>\D</code>: 匹配任意非数字的字符</li><li><code>\B</code>: 匹配不是单词开头或结束的位置</li><li><code>[^x]</code>: 匹配除了x以外的任意字符</li></ul><h3 id="递归匹配"><a href="#递归匹配" class="headerlink" title="递归匹配"></a>递归匹配</h3><p>用于判定括号匹配等等，使用了栈的思想</p><ul><li><code>(?&#39;group&#39;)</code>: 把捕获的内容命名为group，并压入堆栈</li><li><code>(?&#39;-group&#39;)</code>: 从堆栈上弹出最后压入堆栈的名为group的捕获内容，如果堆栈本来为空，则本分组的匹配失败</li><li><code>(?(group)yes|no)</code>: 如果堆栈上存在以名为group的捕获内容的话，继续匹配yes部分的表达式，否则继续匹配no部分</li><li><code>(?!)</code>: 零宽负向先行断言，由于没有后缀表达式，试图匹配总是失败</li></ul><h2 id="命令行环境"><a href="#命令行环境" class="headerlink" title="命令行环境"></a>命令行环境</h2><h3 id="终端多路复用"><a href="#终端多路复用" class="headerlink" title="终端多路复用"></a>终端多路复用</h3><p>使用 <code>tmux</code> 实现基于面板和标签分割出多个终端窗口，从而同时与多个 shell 会话进行交互</p><h4 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">tmux                     <span class="hljs-comment"># 启动 tmux 并进入默认 session</span><br>tmux new -s mysession    <span class="hljs-comment"># 新建并命名一个 session</span><br>tmux <span class="hljs-built_in">ls</span>                  <span class="hljs-comment"># 列出所有 session</span><br>tmux attach -t mysession <span class="hljs-comment"># 连接/恢复到指定 session</span><br>tmux kill-session -t mysession  <span class="hljs-comment"># 关闭指定 session</span><br>tmux detach              <span class="hljs-comment"># 分离当前session保持后台运行，也可以使用Ctrl-b d</span><br></code></pre></td></tr></table></figure><h4 id="窗口"><a href="#窗口" class="headerlink" title="窗口"></a>窗口</h4><ul><li><code>Ctrl+b c</code>: 新建窗口</li><li><code>Ctrl+b n</code>: 下一个窗口</li><li><code>Ctrl+b p</code>: 上一个窗口</li><li><code>Ctrl+b w</code> 列出窗口列表</li><li><code>Ctrl+b ,</code>: 重命名当前窗口</li></ul><h4 id="面板"><a href="#面板" class="headerlink" title="面板"></a>面板</h4><ul><li><code>Ctrl+b %</code>: 横向分屏（左右）</li><li><code>Ctrl+b &quot;</code>: 纵向分屏（上下）</li><li><code>Ctrl+b o</code>: 在各面板之间切换</li><li><code>Ctrl+b x</code>: 关闭当前面板</li><li><code>Ctrl+b ;</code>: 返回上一个面板</li></ul><h3 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h3><p>使用 <code>alias</code> 指令取个简短的新名字</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">alias</span> alias_name=<span class="hljs-string">&quot;command_to_alias arg1 arg2&quot;</span><br></code></pre></td></tr></table></figure><h3 id="远端设备"><a href="#远端设备" class="headerlink" title="远端设备"></a>远端设备</h3><p>使用 <code>ssh</code> 指令连接到其他服务器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh [user@]hostname [<span class="hljs-built_in">command</span>]<br>ssh -p 2222 user@host         <span class="hljs-comment"># 连接到2222端口</span><br>ssh -i ~/.ssh/id_rsa user@host <span class="hljs-comment"># 用指定私钥认证</span><br>ssh -L 8080:localhost:80 user@host <span class="hljs-comment"># 本地8080转发到远程80端口</span><br>ssh -R 2022:localhost:22 user@host <span class="hljs-comment"># 远程端口转发</span><br></code></pre></td></tr></table></figure><h4 id="公钥认证"><a href="#公钥认证" class="headerlink" title="公钥认证"></a>公钥认证</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh-keygen -t rsa       <span class="hljs-comment"># 生成密钥对</span><br>ssh-copy-id user@host   <span class="hljs-comment"># 将公钥上传到远程主机</span><br></code></pre></td></tr></table></figure><h4 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h4><p>即设置 <code>~/.ssh/config</code> 来简化指令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs config">Host myserver<br>    HostName server.com<br>    User alice<br>    Port 2222<br>    IdentityFile ~/.ssh/id_rsa<br></code></pre></td></tr></table></figure><h4 id="相关指令"><a href="#相关指令" class="headerlink" title="相关指令"></a>相关指令</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">scp file.txt user@host:/tmp/    <span class="hljs-comment"># 基于ssh的拷贝</span><br><span class="hljs-built_in">tee</span>         <span class="hljs-comment"># 将标准输出写入到一个文件，可以配合ssh使用</span><br></code></pre></td></tr></table></figure><h2 id="git"><a href="#git" class="headerlink" title="git"></a>git</h2><p>一些常用指令</p><h3 id="日常同步和获取代码"><a href="#日常同步和获取代码" class="headerlink" title="日常同步和获取代码"></a>日常同步和获取代码</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> &lt;address&gt;     <span class="hljs-comment"># 第一次获取项目代码到本地</span><br>git pull                <span class="hljs-comment"># 同步远程仓库最新提交到本地当前分支</span><br></code></pre></td></tr></table></figure><h3 id="代码变更管理"><a href="#代码变更管理" class="headerlink" title="代码变更管理"></a>代码变更管理</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">git status              <span class="hljs-comment"># 查看哪些文件发生了变化、哪些文件已暂存、哪些未提交</span><br>git add &lt;file name&gt;<br>git add .               <span class="hljs-comment"># 把更改加入到下次提交的“暂存区”，. 表示全部添加</span><br>git commit -m <span class="hljs-string">&quot;message&quot;</span> <span class="hljs-comment"># 把暂存区的更改保存为一次提交</span><br></code></pre></td></tr></table></figure><h3 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">git branch                  <span class="hljs-comment"># 列出所有本地分支</span><br>git checkout -b &lt;feature&gt;   <span class="hljs-comment"># 新建并切换分支</span><br>git checkout &lt;feature&gt;      <span class="hljs-comment"># 切换分支</span><br>git merge &lt;feature&gt;         <span class="hljs-comment"># 把指定分支的更改合并到当前分支</span><br>git branch -d &lt;feature&gt;     <span class="hljs-comment"># 删除已合并或不用的分支</span><br></code></pre></td></tr></table></figure><h3 id="推送与协作"><a href="#推送与协作" class="headerlink" title="推送与协作"></a>推送与协作</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git push                        <span class="hljs-comment"># 把本地提交同步到远程仓库</span><br>git push -u origin &lt;feature&gt;    <span class="hljs-comment"># 推送新分支到远程，第一次把新分支推送到远程时常用</span><br></code></pre></td></tr></table></figure><h3 id="历史与排查"><a href="#历史与排查" class="headerlink" title="历史与排查"></a>历史与排查</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">log</span>                 <span class="hljs-comment"># 查看项目的提交记录</span><br>git <span class="hljs-built_in">log</span> &lt;file name&gt;     <span class="hljs-comment"># 排查某文件的历史修改</span><br>git diff                <span class="hljs-comment"># 比较未提交的更改、分支差异等</span><br>git stash               <span class="hljs-comment"># 临时保存未提交的更改，切换分支后可恢复</span><br></code></pre></td></tr></table></figure><h3 id="场景举例"><a href="#场景举例" class="headerlink" title="场景举例"></a>场景举例</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">git pull                        <span class="hljs-comment"># 拉取最新代码</span><br>git checkout -b &lt;feature&gt;       <span class="hljs-comment"># 新建分支</span><br>git add .<br>git commit -m &lt;message&gt;         <span class="hljs-comment"># 提交</span><br>git push -u origin &lt;feature&gt;    <span class="hljs-comment"># 推送分支</span><br> <span class="hljs-built_in">pr</span><br>git checkout main               <span class="hljs-comment"># 切回主分支</span><br>git pull                        <span class="hljs-comment"># 同步</span><br>git branch -d &lt;feature&gt;         <span class="hljs-comment"># 删除用完的本地分支</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>计算机学习</category>
      
      <category>csdiy</category>
      
      <category>missing semester</category>
      
    </categories>
    
    
    <tags>
      
      <tag>csdiy</tag>
      
      <tag>missing semester</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>代码随想录之双指针、链表、二叉树、栈与队列</title>
    <link href="/2025/06/03/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E4%B9%8B%E5%8F%8C%E6%8C%87%E9%92%88%E3%80%81%E9%93%BE%E8%A1%A8%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91%E3%80%81%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"/>
    <url>/2025/06/03/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E4%B9%8B%E5%8F%8C%E6%8C%87%E9%92%88%E3%80%81%E9%93%BE%E8%A1%A8%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91%E3%80%81%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="移除元素——双指针法"><a href="#移除元素——双指针法" class="headerlink" title="移除元素——双指针法"></a>移除元素——双指针法</h3><blockquote><p>给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。<br>不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并原地修改输入数组。<br>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。<br>示例 1: 给定 nums &#x3D; [3,2,2,3], val &#x3D; 3, 函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。 你不需要考虑数组中超出新长度后面的元素。<br>示例 2: 给定 nums &#x3D; [0,1,2,2,3,0,4,2], val &#x3D; 2, 函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。<br>你不需要考虑数组中超出新长度后面的元素。</p></blockquote><p>使用双指针的思路，定义快慢指针，快指针：寻找新数组的元素，新数组就是不含有目标元素的数组；慢指针：指向更新新数组下标的位置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">removeElement</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, slow = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// fast用于检查是否等于val，slow用于计算不等于val的数目</span><br>        <span class="hljs-keyword">while</span>(fast != nums.length)&#123;<br>            <span class="hljs-keyword">if</span>(val != nums[fast])&#123;<br>                nums[slow] = nums[fast];<br>                slow++;<br>                fast++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                fast++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> slow;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="类似的双指针法（滑动窗口）——长度最小的子数组"><a href="#类似的双指针法（滑动窗口）——长度最小的子数组" class="headerlink" title="类似的双指针法（滑动窗口）——长度最小的子数组"></a>类似的双指针法（滑动窗口）——长度最小的子数组</h4><blockquote><p>给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组，并返回其长度。如果不存在符合条件的子数组，返回 0。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minSubArrayLen</span><span class="hljs-params">(<span class="hljs-type">int</span> target, <span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, slow = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// slow指向子数组的头一个元素</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> target;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> nums.length + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(fast &lt; nums.length)&#123;<br>            <span class="hljs-keyword">if</span>(nums[fast] &lt; sum)&#123;<br>                sum -= nums[fast];<br>                fast++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span>(len &gt; fast - slow + <span class="hljs-number">1</span>)&#123;<br>                    len = fast - slow + <span class="hljs-number">1</span>;<br>                &#125;<br>                sum += nums[slow];<br>                slow++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> len == nums.length + <span class="hljs-number">1</span> ? <span class="hljs-number">0</span> : len;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="滑动窗口和哈希表结合——水果成篮"><a href="#滑动窗口和哈希表结合——水果成篮" class="headerlink" title="滑动窗口和哈希表结合——水果成篮"></a>滑动窗口和哈希表结合——水果成篮</h4><blockquote><p>你正在探访一家农场，农场从左到右种植了一排果树。这些树用一个整数数组 fruits 表示，其中 fruits[i] 是第 i 棵树上的水果 种类 。<br>你想要尽可能多地收集水果。然而，农场的主人设定了一些严格的规矩，你必须按照要求采摘水果：<br>你只有 两个 篮子，并且每个篮子只能装 单一类型 的水果。每个篮子能够装的水果总量没有限制。<br>你可以选择任意一棵树开始采摘，你必须从 每棵 树（包括开始采摘的树）上 恰好摘一个水果 。采摘的水果应当符合篮子中的水果类型。每采摘一次，你将会向右移动到下一棵树，并继续采摘。<br>一旦你走到某棵树前，但水果不符合篮子的水果类型，那么就必须停止采摘。<br>给你一个整数数组 fruits ，返回你可以收集的水果的 最大 数目。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">totalFruit</span><span class="hljs-params">(<span class="hljs-type">int</span>[] fruits)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, fast = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">total</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span>[] count = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[fruits.length];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(fast &lt; fruits.length)&#123;<br>            count[fruits[fast]]++;<br>            <span class="hljs-keyword">if</span>(count[fruits[fast]] == <span class="hljs-number">1</span>)&#123;<br>                total++;<br>            &#125;<br>            <span class="hljs-keyword">while</span>(total &gt; <span class="hljs-number">2</span>)&#123;<br>                count[fruits[slow]]--;<br>                <span class="hljs-keyword">if</span>(count[fruits[slow]] == <span class="hljs-number">0</span>)&#123;<br>                    total--;<br>                &#125;<br>                slow++;<br>            &#125;<br>            fast++;<br>            <span class="hljs-keyword">if</span>(len &lt; fast - slow)&#123;<br>                len = fast - slow;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> len;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="升级版滑动窗口和哈希表——无重复字符的最长字串"><a href="#升级版滑动窗口和哈希表——无重复字符的最长字串" class="headerlink" title="升级版滑动窗口和哈希表——无重复字符的最长字串"></a>升级版滑动窗口和哈希表——无重复字符的最长字串</h4><blockquote><p>给定一个字符串 s ，请你找出其中不含有重复字符的 最长 子串 的长度。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lengthOfLongestSubstring</span><span class="hljs-params">(String s)</span> &#123;<br>        Set&lt;Character&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; slow &lt; s.length(); slow++)&#123;<br>            <span class="hljs-keyword">if</span>(slow != <span class="hljs-number">0</span>)&#123;<br>                set.remove(s.charAt(slow - <span class="hljs-number">1</span>));<br>            &#125;<br>            <span class="hljs-keyword">while</span>(fast != s.length() &amp;&amp; !set.contains(s.charAt(fast)))&#123;<br>                set.add(s.charAt(fast));<br>                fast++;<br>            &#125;<br>            res = Math.max(res, fast - slow);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="找到字符串中所有字母异位词"><a href="#找到字符串中所有字母异位词" class="headerlink" title="找到字符串中所有字母异位词"></a>找到字符串中所有字母异位词</h4><blockquote><p>给定两个字符串 s 和 p，找到 s 中所有 p 的 异位词 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。</p></blockquote><p>这里利用小写字母特性，只使用26位哈希表（数组），节约空间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">findAnagrams</span><span class="hljs-params">(String s, String p)</span> &#123;<br>        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">if</span>(s.length() &lt; p.length())&#123;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br>        <span class="hljs-type">int</span>[] sCount = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">26</span>];<br>        <span class="hljs-type">int</span>[] pCount = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">26</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; p.length(); i++)&#123; <span class="hljs-comment">// 先看前p位</span><br>            pCount[p.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>            sCount[s.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(Arrays.equals(sCount, pCount))&#123;<br>            res.add(<span class="hljs-number">0</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> p.length(); i &lt; s.length(); i++)&#123; <span class="hljs-comment">// 看后面的位数</span><br>            --sCount[s.charAt(i - p.length()) - <span class="hljs-string">&#x27;a&#x27;</span>]; <span class="hljs-comment">// 滑动窗口，失去一个得到一个</span><br>            ++sCount[s.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>];<br>            <span class="hljs-keyword">if</span>(Arrays.equals(sCount, pCount))&#123;<br>                res.add(i - p.length() + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="双指针收缩——盛最多水的容器"><a href="#双指针收缩——盛最多水的容器" class="headerlink" title="双指针收缩——盛最多水的容器"></a>双指针收缩——盛最多水的容器</h4><blockquote><p>给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。<br>找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。<br>返回容器可以储存的最大水量。<br>说明：你不能倾斜容器。</p></blockquote><p>使用双指针收缩容器，注意比较left和right来判断收缩哪边</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxArea</span><span class="hljs-params">(<span class="hljs-type">int</span>[] height)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = height.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, area;<br>        <span class="hljs-keyword">while</span>(left &lt; right)&#123;<br>            area = Math.min(height[left], height[right]) * (right - left);<br>            max = Math.max(max, area);<br>            <span class="hljs-keyword">if</span>(height[left] &lt; height[right])&#123;<br>                left++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                right--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> max;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="接雨水"><a href="#接雨水" class="headerlink" title="接雨水"></a>接雨水</h4><blockquote><p>给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">trap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] height)</span> &#123;<br>        <span class="hljs-comment">// 下标i处的雨水由leftMax和rightMax决定</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = height.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">leftMax</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, rightMax = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(left &lt; right)&#123;<br>            leftMax = Math.max(leftMax, height[left]);<br>            rightMax = Math.max(rightMax, height[right]);<br>            <span class="hljs-keyword">if</span>(height[left] &lt; height[right])&#123;<br>                sum += leftMax - height[left];<br>                left++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                sum += rightMax - height[right];<br>                right--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="螺旋矩阵"><a href="#螺旋矩阵" class="headerlink" title="螺旋矩阵"></a>螺旋矩阵</h3><blockquote><p>给定一个正整数 n，生成一个包含 1 到 n^2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。<br>示例:<br>输入: 3 输出: [ [ 1, 2, 3 ], [ 8, 9, 4 ], [ 7, 6, 5 ] ]</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[][] generateMatrix(<span class="hljs-type">int</span> n) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, r = n - <span class="hljs-number">1</span>, t = <span class="hljs-number">0</span>, b = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span>[][] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][n];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> l; i &lt;= r; i++) res[t][i] = k++;<br>            <span class="hljs-keyword">if</span>(++t &gt; b) <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> t; i &lt;= b; i++) res[i][r] = k++;<br>            <span class="hljs-keyword">if</span>(--r &lt; l) <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> r; i &gt;= l; i--) res[b][i] = k++;<br>            <span class="hljs-keyword">if</span>(--b &lt; t) <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> b; i &gt;= t; i--) res[i][l] = k++;<br>            <span class="hljs-keyword">if</span>(++l &gt; r) <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="链表的基本操作"><a href="#链表的基本操作" class="headerlink" title="链表的基本操作"></a>链表的基本操作</h3><h4 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a>移除元素</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">removeElements</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-comment">// 哨兵结点，对开始的结点分类讨论</span><br>        <span class="hljs-keyword">while</span>(head != <span class="hljs-literal">null</span> &amp;&amp; head.val == val)&#123;<br>            head = head.next;<br>        &#125;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">while</span>(cur != <span class="hljs-literal">null</span> &amp;&amp; cur.next != <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">if</span>(cur.next.val == val)&#123;<br>                cur.next = cur.next.next;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                cur = cur.next;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">reverseList</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head;<br>        ListNode temp, prev = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">while</span>(cur != <span class="hljs-literal">null</span>)&#123;<br>            temp = cur.next;<br>            cur.next = prev;<br>            prev = cur;<br>            cur = temp;<br>        &#125;<br>        <span class="hljs-keyword">return</span> prev;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="两两交换链表中的节点"><a href="#两两交换链表中的节点" class="headerlink" title="两两交换链表中的节点"></a>两两交换链表中的节点</h4><blockquote><p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。<br>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p></blockquote><p>使用递归算法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">swapPairs</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">if</span>(head.next == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> head;<br>        <span class="hljs-comment">// 递归</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> head.next;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">newNode</span> <span class="hljs-operator">=</span> swapPairs(head.next.next);<br>        next.next = head;<br>        head.next = newNode;<br>        <span class="hljs-keyword">return</span> next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="删除链表的倒数第N个节点"><a href="#删除链表的倒数第N个节点" class="headerlink" title="删除链表的倒数第N个节点"></a>删除链表的倒数第N个节点</h4><p>使用双指针</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">removeNthFromEnd</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">dum</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>, head);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> head, slow = dum;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            fast = fast.next;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(fast != <span class="hljs-literal">null</span>)&#123;<br>            fast = fast.next;<br>            slow = slow.next;<br>        &#125;<br>        slow.next = slow.next.next;<br>        <span class="hljs-keyword">return</span> dum.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="链表相交"><a href="#链表相交" class="headerlink" title="链表相交"></a>链表相交</h3><blockquote><p>给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。</p></blockquote><p>先遍历一遍得到长度，再对齐两个链表的指针，最后一起移动检查节点是否相等</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode(int x) &#123;</span><br><span class="hljs-comment"> *         val = x;</span><br><span class="hljs-comment"> *         next = null;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">getIntersectionNode</span><span class="hljs-params">(ListNode headA, ListNode headB)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">lenA</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, lenB = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">curA</span> <span class="hljs-operator">=</span> headA, curB = headB;<br>        <span class="hljs-keyword">while</span>(curA != <span class="hljs-literal">null</span>)&#123;<br>            curA = curA.next;<br>            lenA++;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(curB != <span class="hljs-literal">null</span>)&#123;<br>            curB = curB.next;<br>            lenB++;<br>        &#125;<br><br>        curA = headA; curB = headB;<br>        <span class="hljs-keyword">if</span>(lenA &gt; lenB)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; lenA - lenB; i++)&#123;<br>                curA = curA.next;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; lenB - lenA; i++)&#123;<br>                curB = curB.next;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">while</span>(curA != <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">if</span>(curA == curB)&#123;<br>                <span class="hljs-keyword">return</span> curA;<br>            &#125;<br>            curA = curA.next;<br>            curB = curB.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="环形链表"><a href="#环形链表" class="headerlink" title="环形链表"></a>环形链表</h3><blockquote><p>题意： 给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。<br>为了表示给定链表中的环，使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。<br>说明：不允许修改给定的链表。</p></blockquote><p>一个数学问题，双指针先双倍移动以判断环，再单倍移动以得到起始位置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode(int x) &#123;</span><br><span class="hljs-comment"> *         val = x;</span><br><span class="hljs-comment"> *         next = null;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">detectCycle</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> head, slow = head;<br>        <span class="hljs-keyword">while</span>(fast != <span class="hljs-literal">null</span> &amp;&amp; fast.next != <span class="hljs-literal">null</span>)&#123;<br>            fast = fast.next.next;<br>            slow = slow.next;<br>            <span class="hljs-keyword">if</span>(fast == slow)&#123;<br>                slow = head;<br>                <span class="hljs-keyword">while</span>(fast != slow)&#123;<br>                    fast = fast.next;<br>                    slow = slow.next;<br>                &#125;<br>                <span class="hljs-keyword">return</span> slow;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><h3 id="字母异位词分组"><a href="#字母异位词分组" class="headerlink" title="字母异位词分组"></a>字母异位词分组</h3><blockquote><p>给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。<br>字母异位词 是由重新排列源单词的所有字母得到的一个新单词。<br>示例:<br>输入: strs &#x3D; [“eat”, “tea”, “tan”, “ate”, “nat”, “bat”]<br>输出: [[“bat”],[“nat”,”tan”],[“ate”,”eat”,”tea”]]</p></blockquote><p>使用HashMap，键为排序后的str，值为str数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="hljs-title function_">groupAnagrams</span><span class="hljs-params">(String[] strs)</span> &#123;<br>        Map&lt;String, List&lt;String&gt;&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(String str : strs)&#123;<br>            <span class="hljs-type">char</span>[] s = str.toCharArray();<br>            Arrays.sort(s);<br>            <span class="hljs-comment">// 如果 Map 中没有键 new String(s)，则创建一个新的 ArrayList 并将其与键关联</span><br>            map.computeIfAbsent(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(s), k -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;()).add(str);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(map.values());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h3><blockquote><p>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。<br>你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。<br>你可以按任意顺序返回答案。</p></blockquote><p>使用HashMap记录差值和索引的键值对</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] twoSum(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target) &#123;<br>        Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++)&#123;<br>            <span class="hljs-keyword">if</span>(map.containsKey(nums[i]))&#123;<br>                res[<span class="hljs-number">0</span>] = map.get(nums[i]);<br>                res[<span class="hljs-number">1</span>] = i;<br>                <span class="hljs-keyword">return</span> res;<br>            &#125;<br>            map.put(target - nums[i], i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="四数相加"><a href="#四数相加" class="headerlink" title="四数相加"></a>四数相加</h4><blockquote><p>给你四个整数数组 nums1、nums2、nums3 和 nums4 ，数组长度都是 n ，请你计算有多少个元组 (i, j, k, l) 能满足：<br>0 &lt;&#x3D; i, j, k, l &lt; n<br>nums1[i] + nums2[j] + nums3[k] + nums4[l] &#x3D;&#x3D; 0</p></blockquote><p>类似于两数之和，将nums1和nums2视为一组，nums3和nums4视为一组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">fourSumCount</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span>[] nums2, <span class="hljs-type">int</span>[] nums3, <span class="hljs-type">int</span>[] nums4)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-comment">// nums1和nums2一组，nums3和nums4一组</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i : nums1)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j : nums2)&#123;<br>                map.put(i + j, map.getOrDefault(i + j, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i : nums3)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j : nums4)&#123;<br>                <span class="hljs-keyword">if</span>(map.containsKey(<span class="hljs-number">0</span> - i - j))&#123;<br>                    res += map.get(<span class="hljs-number">0</span> - i - j);<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a>三数之和</h4><blockquote><p>给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i !&#x3D; j、i !&#x3D; k 且 j !&#x3D; k ，同时还满足 nums[i] + nums[j] + nums[k] &#x3D;&#x3D; 0 。请你返回所有和为 0 且不重复的三元组。<br>注意：答案中不可以包含重复的三元组。</p></blockquote><p>使用双指针法更简单，先进行排序，再遍历数组，并使用left和right指向剩下的两个数字，注意题干中的去重<br>对于四数之和，直接两层循环，剩下两个数就可以用双指针了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">threeSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-comment">// 先排序，以使用双指针</span><br>        Arrays.sort(nums);<br><br>        <span class="hljs-type">int</span> left, right, sum;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i] &gt; <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">return</span> res;<br>            &#125;<br><br>            <span class="hljs-comment">// 去除重复三元组</span><br>            <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i - <span class="hljs-number">1</span>] == nums[i])&#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            left = i + <span class="hljs-number">1</span>;<br>            right = nums.length - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span>(left &lt; right)&#123;<br>                sum = nums[i] + nums[left] + nums[right];<br>                <span class="hljs-keyword">if</span>(sum &gt; <span class="hljs-number">0</span>)&#123;<br>                    right--;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sum &lt; <span class="hljs-number">0</span>)&#123;<br>                    left++;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    res.add(Arrays.asList(nums[i], nums[left], nums[right]));<br>                    <span class="hljs-comment">// 去重</span><br>                    <span class="hljs-keyword">while</span>(left &lt; right &amp;&amp; nums[left] == nums[left + <span class="hljs-number">1</span>])&#123;<br>                        left++;<br>                    &#125;<br>                    <span class="hljs-keyword">while</span>(left &lt; right &amp;&amp; nums[right] == nums[right - <span class="hljs-number">1</span>])&#123;<br>                        right--;<br>                    &#125;<br>                    left++;<br>                    right--;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="翻转字符串里的单词"><a href="#翻转字符串里的单词" class="headerlink" title="翻转字符串里的单词"></a>翻转字符串里的单词</h3><blockquote><p>给定一个字符串，逐个翻转字符串中的每个单词。<br>示例 1：<br>输入: “the sky is blue”<br>输出: “blue is sky the”<br>示例 2：<br>输入: “  hello world!  “<br>输出: “world! hello”<br>解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。<br>示例 3：<br>输入: “a good   example”<br>输出: “example good a”<br>解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</p></blockquote><p>借助StringBuilder移除多余空格，将整个字符串反转，将每个单词反转</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">reverseWords</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> removeSpace(s);<br>        reverseString(sb, <span class="hljs-number">0</span>, sb.length() - <span class="hljs-number">1</span>);<br>        reverseEachWord(sb);<br>        <span class="hljs-keyword">return</span> sb.toString();<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> StringBuilder <span class="hljs-title function_">removeSpace</span><span class="hljs-params">(String s)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> s.length() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(s.charAt(start) == <span class="hljs-string">&#x27; &#x27;</span>) start++;<br>        <span class="hljs-keyword">while</span>(s.charAt(end) == <span class="hljs-string">&#x27; &#x27;</span>) end--;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-keyword">while</span>(start &lt;= end)&#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> s.charAt(start);<br>            <span class="hljs-keyword">if</span>(c != <span class="hljs-string">&#x27; &#x27;</span> || sb.charAt(sb.length() - <span class="hljs-number">1</span>) != <span class="hljs-string">&#x27; &#x27;</span>)&#123; <span class="hljs-comment">// 去除单词间的多余空格</span><br>                sb.append(c);<br>            &#125;<br>            start++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sb;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reverseString</span><span class="hljs-params">(StringBuilder sb, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span>&#123;<br>        <span class="hljs-keyword">while</span>(start &lt; end)&#123; <span class="hljs-comment">// 头尾交换</span><br>            <span class="hljs-type">char</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> sb.charAt(start);<br>            sb.setCharAt(start, sb.charAt(end));<br>            sb.setCharAt(end, temp);<br>            start++;<br>            end--;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reverseEachWord</span><span class="hljs-params">(StringBuilder sb)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; <span class="hljs-comment">// 双指针找到单词</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> sb.length();<br>        <span class="hljs-keyword">while</span>(start &lt; n)&#123;<br>            <span class="hljs-keyword">while</span>(end &lt; n &amp;&amp; sb.charAt(end) != <span class="hljs-string">&#x27; &#x27;</span>)&#123;<br>                end++;<br>            &#125;<br>            reverseString(sb, start, end - <span class="hljs-number">1</span>);<br>            start = end + <span class="hljs-number">1</span>;<br>            end = start + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="KMP算法——实现strStr"><a href="#KMP算法——实现strStr" class="headerlink" title="KMP算法——实现strStr()"></a>KMP算法——实现strStr()</h3><blockquote><p>实现 strStr() 函数。<br>给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回  -1。</p></blockquote><p>使用KMP算法，先根据回文计算next数组，再双指针，needle指针用于回溯</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">strStr</span><span class="hljs-params">(String haystack, String needle)</span> &#123;<br>        <span class="hljs-type">int</span>[] next = next(needle);<br>        <span class="hljs-comment">// 双指针分别指向两个字符串的匹配位，needle用于回溯，handle始终保持前移</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> haystack.length(), n = needle.length();<br>        <span class="hljs-keyword">while</span>((m - i) &gt;= (n - j))&#123;<br>            <span class="hljs-keyword">if</span>(haystack.charAt(i) == needle.charAt(j))&#123;<br>                i++; j++;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (j != <span class="hljs-number">0</span>)&#123;<br>                j = next[j - <span class="hljs-number">1</span>];<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                i++;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(j == n) &#123;<br>                <span class="hljs-keyword">return</span> i - j;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] next(String needle)&#123;<br>        <span class="hljs-type">int</span>[] next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[needle.length()];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">while</span>(j != needle.length())&#123;<br>            <span class="hljs-keyword">if</span>(needle.charAt(i) == needle.charAt(j))&#123;<br>                i++;<br>                next[j] = i; <span class="hljs-comment">// 回文有多少字符，而数组从0开始</span><br>                j++;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(i != <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-comment">// 回溯到已检查字符串的回文的下一位，进行检查匹配</span><br>                i = next[i - <span class="hljs-number">1</span>];<br>            &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 无法回溯，为默认值0</span><br>                j++;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="栈与队列"><a href="#栈与队列" class="headerlink" title="栈与队列"></a>栈与队列</h2><h3 id="用队列表示栈"><a href="#用队列表示栈" class="headerlink" title="用队列表示栈"></a>用队列表示栈</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyStack</span> &#123;<br>    Queue&lt;Integer&gt; q1;<br>    Queue&lt;Integer&gt; q2;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyStack</span><span class="hljs-params">()</span> &#123;<br>        q1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        q2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        <span class="hljs-comment">// 放在辅助队列使新加元素位于头部</span><br>        q2.offer(x);<br>        <span class="hljs-keyword">while</span>(!q1.isEmpty())&#123;<br>            q2.offer(q1.poll());<br>        &#125;<br>        <span class="hljs-comment">// 交换两队列的满空状态</span><br>        Queue&lt;Integer&gt; queueTemp;<br>        queueTemp = q1;<br>        q1 = q2;<br>        q2 = queueTemp;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> q1.poll();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">top</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> q1.peek();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">empty</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> q1.isEmpty();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MyStack object will be instantiated and called as such:</span><br><span class="hljs-comment"> * MyStack obj = new MyStack();</span><br><span class="hljs-comment"> * obj.push(x);</span><br><span class="hljs-comment"> * int param_2 = obj.pop();</span><br><span class="hljs-comment"> * int param_3 = obj.top();</span><br><span class="hljs-comment"> * boolean param_4 = obj.empty();</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h3 id="栈的应用——有效的括号"><a href="#栈的应用——有效的括号" class="headerlink" title="栈的应用——有效的括号"></a>栈的应用——有效的括号</h3><blockquote><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。<br>有效字符串需满足：<br>左括号必须用相同类型的右括号闭合。<br>左括号必须以正确的顺序闭合。<br>注意空字符串可被认为是有效字符串。</p></blockquote><p>使用栈匹配</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(String s)</span> &#123;<br>        Stack&lt;Character&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c : s.toCharArray())&#123;<br>            <span class="hljs-keyword">if</span>(c == <span class="hljs-string">&#x27;)&#x27;</span> &amp;&amp; !stack.isEmpty() &amp;&amp; stack.peek() == <span class="hljs-string">&#x27;(&#x27;</span>)&#123;<br>                stack.pop();<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(c == <span class="hljs-string">&#x27;]&#x27;</span> &amp;&amp; !stack.isEmpty() &amp;&amp; stack.peek() == <span class="hljs-string">&#x27;[&#x27;</span>)&#123;<br>                stack.pop();<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(c == <span class="hljs-string">&#x27;&#125;&#x27;</span> &amp;&amp; !stack.isEmpty() &amp;&amp; stack.peek() == <span class="hljs-string">&#x27;&#123;&#x27;</span>)&#123;<br>                stack.pop();<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                stack.push(c);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> stack.isEmpty();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="队列的应用——滑动窗口最大值"><a href="#队列的应用——滑动窗口最大值" class="headerlink" title="队列的应用——滑动窗口最大值"></a>队列的应用——滑动窗口最大值</h3><blockquote><p>给定一个数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。<br>返回滑动窗口中的最大值。</p></blockquote><p>实现一个单调递减的队列来peek最大值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyQueue</span> &#123; <span class="hljs-comment">// 该队列应当保证单调递减</span><br>    Deque&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">poll</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span>&#123; <span class="hljs-comment">// 只弹出最大值，其余值会自动消亡</span><br>        <span class="hljs-keyword">if</span>(!queue.isEmpty() &amp;&amp; val == queue.peek())&#123;<br>            queue.poll();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span>&#123;<br>        <span class="hljs-keyword">while</span>(!queue.isEmpty() &amp;&amp; val &gt; queue.getLast())&#123;<br>            queue.removeLast(); <span class="hljs-comment">// 抹除更小值保证单调递减</span><br>        &#125;<br>        queue.add(val);<br>    &#125;<br><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">peek</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> queue.peek();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] maxSlidingWindow(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k) &#123;<br>        <span class="hljs-keyword">if</span>(nums.length == <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> nums;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> nums.length - k + <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> res[] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[len];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">MyQueue</span> <span class="hljs-variable">queue</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyQueue</span>();<br>        <span class="hljs-comment">// 此时队列只有最大值及其后面的次大值，以此类推</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; k; i++)&#123;<br>            queue.add(nums[i]);<br>        &#125;<br>        res[num++] = queue.peek();<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> k; i &lt; nums.length; i++)&#123;<br>            queue.poll(nums[i - k]);<br>            queue.add(nums[i]);<br>            res[num++] = queue.peek();<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="优先级队列——前K个高级元素"><a href="#优先级队列——前K个高级元素" class="headerlink" title="优先级队列——前K个高级元素"></a>优先级队列——前K个高级元素</h3><blockquote><p>给定一个非空的整数数组，返回其中出现频率前 k 高的元素。</p></blockquote><p>先用HashMap记录键值对，再用优先级队列排序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] topKFrequent(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k) &#123;<br>        Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> num : nums)&#123;<br>            map.put(num, map.getOrDefault(num, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-comment">// 一个大顶堆</span><br>        PriorityQueue&lt;<span class="hljs-type">int</span>[]&gt; pq = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;((pair1, pair2) -&gt; pair2[<span class="hljs-number">1</span>] - pair1[<span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">for</span>(Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet())&#123;<br>            pq.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;entry.getKey(), entry.getValue()&#125;);<br>        &#125;<br><br>        <span class="hljs-type">int</span>[] ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[k];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; k; i++)&#123;<br>            ans[i] = pq.poll()[<span class="hljs-number">0</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h3 id="二叉树的基本操作"><a href="#二叉树的基本操作" class="headerlink" title="二叉树的基本操作"></a>二叉树的基本操作</h3><h4 id="二叉树的非递归遍历"><a href="#二叉树的非递归遍历" class="headerlink" title="二叉树的非递归遍历"></a>二叉树的非递归遍历</h4><p>以后序遍历为例，使用栈来辅助</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">postorderTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br><br>        Stack&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        stack.push(root);<br>        <span class="hljs-keyword">while</span>(!stack.isEmpty())&#123;<br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> stack.pop();<br>            res.add(cur.val);<br>            <span class="hljs-keyword">if</span>(cur.left != <span class="hljs-literal">null</span>)&#123;<br>                stack.push(cur.left);<br>            &#125;<br>            <span class="hljs-keyword">if</span>(cur.right != <span class="hljs-literal">null</span>)&#123;<br>                stack.push(cur.right);<br>            &#125;<br>        &#125;<br>        Collections.reverse(res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="二叉树的层序遍历"><a href="#二叉树的层序遍历" class="headerlink" title="二叉树的层序遍历"></a>二叉树的层序遍历</h4><p>递归或借助队列实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();<br><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">levelOrder</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-comment">// bfs(root);</span><br>        recursive(root, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-comment">// 递归</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">recursive</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> depth)</span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br>        depth++;<br><br>        <span class="hljs-keyword">if</span>(res.size() &lt; depth)&#123;<br>            List&lt;Integer&gt; item = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>            res.add(item);<br>        &#125;<br>        res.get(depth - <span class="hljs-number">1</span>).add(root.val);<br>        <br>        recursive(root.left, depth);<br>        recursive(root.right, depth);<br>    &#125;<br><br>    <span class="hljs-comment">// 借助队列</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">bfs</span><span class="hljs-params">(TreeNode root)</span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br>        Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;TreeNode&gt;();<br>        queue.offer(root);<br><br>        <span class="hljs-keyword">while</span>(!queue.isEmpty())&#123;<br>            List&lt;Integer&gt; item = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> queue.size();<br><br>            <span class="hljs-keyword">while</span>(len &gt; <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-type">TreeNode</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> queue.poll();<br>                item.add(temp.val);<br><br>                <span class="hljs-keyword">if</span>(temp.left != <span class="hljs-literal">null</span>)&#123;<br>                    queue.offer(temp.left);<br>                &#125;<br>                <span class="hljs-keyword">if</span>(temp.right != <span class="hljs-literal">null</span>)&#123;<br>                    queue.offer(temp.right);<br>                &#125;<br><br>                len--;<br>            &#125;<br><br>            res.add(item);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="翻转二叉树"><a href="#翻转二叉树" class="headerlink" title="翻转二叉树"></a>翻转二叉树</h4><p>递归交换左右孩子即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">invertTree</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        invertTree(root.left);<br>        invertTree(root.right);<br>        swapChildren(root);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swapChildren</span><span class="hljs-params">(TreeNode root)</span>&#123;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> root.left;<br>        root.left = root.right;<br>        root.right = temp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="二叉树的所有路径"><a href="#二叉树的所有路径" class="headerlink" title="二叉树的所有路径"></a>二叉树的所有路径</h4><blockquote><p>给定一个二叉树，返回所有从根节点到叶子节点的路径。</p></blockquote><p>递归时同时带上path用于记录到达当前节点的路径</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;String&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">binaryTreePaths</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-comment">// recursive(root, &quot;&quot;);</span><br>        byStack(root);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-comment">// 递归法</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">recursive</span><span class="hljs-params">(TreeNode root, String path)</span>&#123; <span class="hljs-comment">// path表示到达该节点的路径</span><br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span>(root.left == <span class="hljs-literal">null</span> &amp;&amp; root.right == <span class="hljs-literal">null</span>)&#123; <span class="hljs-comment">// 叶子节点</span><br>            res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(path).append(root.val).toString());<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">newPath</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(path).append(root.val).append(<span class="hljs-string">&quot;-&gt;&quot;</span>).toString();<br>        recursive(root.left, newPath);<br>        recursive(root.right, newPath);<br>    &#125;<br><br>    <span class="hljs-comment">// 迭代法</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">byStack</span><span class="hljs-params">(TreeNode root)</span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br>        Stack&lt;Object&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        <span class="hljs-comment">// 节点和路径同时入栈</span><br>        stack.push(root);<br>        stack.push(root.val + <span class="hljs-string">&quot;&quot;</span>);<br>        <span class="hljs-keyword">while</span>(!stack.isEmpty())&#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> (String) stack.pop();<br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> (TreeNode) stack.pop();<br>            <span class="hljs-keyword">if</span>(cur.left == <span class="hljs-literal">null</span> &amp;&amp; cur.right == <span class="hljs-literal">null</span>)&#123;<br>                <span class="hljs-comment">// 叶子节点</span><br>                res.add(path);<br>            &#125;<br>            <span class="hljs-keyword">if</span>(cur.left != <span class="hljs-literal">null</span>)&#123;<br>                stack.push(cur.left);<br>                stack.push(path + <span class="hljs-string">&quot;-&gt;&quot;</span> + cur.left.val);<br>            &#125;<br>            <span class="hljs-keyword">if</span>(cur.right != <span class="hljs-literal">null</span>)&#123;<br>                stack.push(cur.right);<br>                stack.push(path + <span class="hljs-string">&quot;-&gt;&quot;</span> + cur.right.val);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="从中序遍历与后序遍历序列构造二叉树"><a href="#从中序遍历与后序遍历序列构造二叉树" class="headerlink" title="从中序遍历与后序遍历序列构造二叉树"></a>从中序遍历与后序遍历序列构造二叉树</h4><blockquote><p>给定两个整数数组 inorder 和 postorder ，其中 inorder 是二叉树的中序遍历， postorder 是同一棵树的后序遍历，请你构造并返回这颗 二叉树 。</p></blockquote><p>root在后序遍历最后一个节点，以此切割中序序列（用map记录键值对来查找），再根据左右子树的长度切割后序序列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    Map&lt;Integer, Integer&gt; map;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">buildTree</span><span class="hljs-params">(<span class="hljs-type">int</span>[] inorder, <span class="hljs-type">int</span>[] postorder)</span> &#123;<br>        map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; inorder.length; i++)&#123;<br>            map.put(inorder[i], i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> findNode(inorder, <span class="hljs-number">0</span>, inorder.length - <span class="hljs-number">1</span>, postorder, <span class="hljs-number">0</span>, postorder.length - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 表示下标范围</span><br>    <span class="hljs-keyword">private</span> TreeNode <span class="hljs-title function_">findNode</span><span class="hljs-params">(<span class="hljs-type">int</span>[] inorder, <span class="hljs-type">int</span> inLeft, <span class="hljs-type">int</span> inRight, <span class="hljs-type">int</span>[] postorder, <span class="hljs-type">int</span> postLeft, <span class="hljs-type">int</span> postRight)</span>&#123;<br>        <span class="hljs-keyword">if</span>(inLeft &gt; inRight || postLeft &gt; postRight) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-comment">// 找到后序遍历最后一个元素在中序遍历位置</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">rootIndex</span> <span class="hljs-operator">=</span> map.get(postorder[postRight]);<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(inorder[rootIndex]);<br>        <span class="hljs-comment">// 在中序遍历和后序遍历中，左子树是等长的</span><br>        <span class="hljs-comment">// 使用root下表切割中序序列</span><br>        root.left = findNode(inorder, inLeft, rootIndex - <span class="hljs-number">1</span>, postorder, postLeft, postLeft + rootIndex - <span class="hljs-number">1</span> - inLeft);<br>        root.right = findNode(inorder, rootIndex + <span class="hljs-number">1</span>, inRight, postorder, postLeft + rootIndex - inLeft, postRight - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="二叉树的最近公共祖先"><a href="#二叉树的最近公共祖先" class="headerlink" title="二叉树的最近公共祖先"></a>二叉树的最近公共祖先</h4><blockquote><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。<br>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">lowestCommonAncestor</span><span class="hljs-params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;<br>        <span class="hljs-comment">// 使用后序遍历实现自底向上</span><br>        <span class="hljs-comment">// 只返回p,q或者null,或者二者的公共祖先</span><br>        <span class="hljs-keyword">if</span>(root == p || root == q || root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> root;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> lowestCommonAncestor(root.left, p, q);<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> lowestCommonAncestor(root.right, p, q);<br>        <span class="hljs-comment">// 左右分别有p,q,说明为公共祖先，返回自己</span><br>        <span class="hljs-keyword">if</span>(left != <span class="hljs-literal">null</span> &amp;&amp; right != <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> root;<br>        <span class="hljs-comment">// 只有左边不为null,说明要么p,q没有都找到，要么left为公共祖先，返回left</span><br>        <span class="hljs-keyword">if</span>(left != <span class="hljs-literal">null</span> &amp;&amp; right == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> left;<br>        <span class="hljs-keyword">if</span>(left == <span class="hljs-literal">null</span> &amp;&amp; right != <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> right;<br>        <span class="hljs-comment">//p,q都没找到，返回null</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h3><h4 id="验证二叉搜索树"><a href="#验证二叉搜索树" class="headerlink" title="验证二叉搜索树"></a>验证二叉搜索树</h4><blockquote><p>给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。<br>有效 二叉搜索树定义如下：<br>节点的左子树只包含 小于 当前节点的数。<br>节点的右子树只包含 大于 当前节点的数。<br>所有左子树和右子树自身必须也是二叉搜索树。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">TreeNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">// 记录中序遍历的前一个节点，从而得到左子树的最大值</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValidBST</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-comment">// 中序遍历</span><br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> isValidBST(root.left);<br>        <span class="hljs-keyword">if</span>(pre != <span class="hljs-literal">null</span> &amp;&amp; pre.val &gt;= root.val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        pre = root;<br>        <span class="hljs-keyword">return</span> left &amp;&amp; isValidBST(root.right);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="二叉搜索树中的插入操作"><a href="#二叉搜索树中的插入操作" class="headerlink" title="二叉搜索树中的插入操作"></a>二叉搜索树中的插入操作</h4><blockquote><p>给定二叉搜索树（BST）的根节点 root 和要插入树中的值 value ，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据 保证 ，新值和原始二叉搜索树中的任意节点值都不同。<br>注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回 任意有效的结果 。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">TreeNode</span> <span class="hljs-variable">parent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">insertIntoBST</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) root = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(val);<br>        recursive(root, val);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">recursive</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> val)</span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-comment">// 落到底部，可以插入</span><br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(val);<br>            <span class="hljs-keyword">if</span>(val &lt; parent.val) parent.left = cur;<br>            <span class="hljs-keyword">else</span> parent.right = cur;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        parent = root;<br>        <span class="hljs-keyword">if</span>(val &lt; root.val) recursive(root.left, val);<br>        <span class="hljs-keyword">if</span>(val &gt; root.val) recursive(root.right, val);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="删除二叉搜索树中的节点"><a href="#删除二叉搜索树中的节点" class="headerlink" title="删除二叉搜索树中的节点"></a>删除二叉搜索树中的节点</h4><blockquote><p>给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。</p></blockquote><p>分情况讨论</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">deleteNode</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> key)</span> &#123;<br>        <span class="hljs-comment">// 1.没找到节点，返回null</span><br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> root;<br>        <br>        <span class="hljs-keyword">if</span>(root.val == key)&#123;<br>            <span class="hljs-comment">// 2.左右子树都为空，直接删除</span><br>            <span class="hljs-keyword">if</span>(root.left == <span class="hljs-literal">null</span> &amp;&amp; root.right == <span class="hljs-literal">null</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            &#125;<br>            <span class="hljs-comment">// 3.左子树为空，将右子树拉上来拼接</span><br>            <span class="hljs-keyword">if</span>(root.left == <span class="hljs-literal">null</span>)&#123;<br>                <span class="hljs-keyword">return</span> root.right;<br>            &#125;<br>            <span class="hljs-comment">// 4.右子树为空，类似</span><br>            <span class="hljs-keyword">if</span>(root.right == <span class="hljs-literal">null</span>)&#123;<br>                <span class="hljs-keyword">return</span> root.left;<br>            &#125;<br>            <span class="hljs-comment">// 5.左右子树都不为空，将左子树拼接到右子树最左边节点的左孩子上</span><br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> root.right;<br>            <span class="hljs-keyword">while</span>(cur.left != <span class="hljs-literal">null</span>)&#123;<br>                cur = cur.left;<br>            &#125;<br>            cur.left = root.left;<br>            root = root.right;<br>            <span class="hljs-keyword">return</span> root;<br>        &#125;<br>        <span class="hljs-comment">// 拼接与回溯</span><br>        <span class="hljs-keyword">if</span>(key &lt; root.val) root.left = deleteNode(root.left, key);<br>        <span class="hljs-keyword">if</span>(key &gt; root.val) root.right = deleteNode(root.right, key);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
      <category>代码随想录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>试着发布第一个帖子</title>
    <link href="/2025/05/26/%E8%AF%95%E7%9D%80%E5%8F%91%E5%B8%83%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%B8%96%E5%AD%90/"/>
    <url>/2025/05/26/%E8%AF%95%E7%9D%80%E5%8F%91%E5%B8%83%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%B8%96%E5%AD%90/</url>
    
    <content type="html"><![CDATA[<p>这是我的第一个博客，我的博客会记录以下内容：</p><ul><li>魔禁读后感</li><li>csdiy学习记录</li><li>一些生活记录贴</li></ul><p>欢迎访问本博客的大家交流呀！</p>]]></content>
    
    
    <categories>
      
      <category>吹水</category>
      
    </categories>
    
    
    <tags>
      
      <tag>water</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2025/05/26/hello-world/"/>
    <url>/2025/05/26/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
