

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="jietiDdd">
  <meta name="keywords" content="">
  
    <meta name="description" content="hot100整理之python版哈希最长连续序列 给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。请你设计并实现时间复杂度为 O(n) 的算法解决此问题。  123456789101112class Solution:    def longestConsecutive(self, nums: List[int]) -&gt; int:">
<meta property="og:type" content="article">
<meta property="og:title" content="hot100整理之python版">
<meta property="og:url" content="http://example.com/2025/09/14/hot100%E6%95%B4%E7%90%86%E4%B9%8Bpython%E7%89%88/index.html">
<meta property="og:site_name" content="jietiDdd的个人博客">
<meta property="og:description" content="hot100整理之python版哈希最长连续序列 给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。请你设计并实现时间复杂度为 O(n) 的算法解决此问题。  123456789101112class Solution:    def longestConsecutive(self, nums: List[int]) -&gt; int:">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-09-14T07:08:07.000Z">
<meta property="article:modified_time" content="2025-09-24T11:17:50.608Z">
<meta property="article:author" content="jietiDdd">
<meta property="article:tag" content="leetcode">
<meta property="article:tag" content="hot100">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>hot100整理之python版 - jietiDdd的个人博客</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>jietiDdd的个人博客</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/aleister.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="hot100整理之python版"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-09-14 15:08" pubdate>
          2025年9月14日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          12k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          101 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">hot100整理之python版</h1>
            
            
              <div class="markdown-body">
                
                <h2 id="hot100整理之python版"><a href="#hot100整理之python版" class="headerlink" title="hot100整理之python版"></a>hot100整理之python版</h2><h3 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h3><h4 id="最长连续序列"><a href="#最长连续序列" class="headerlink" title="最长连续序列"></a>最长连续序列</h4><blockquote>
<p>给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。<br>请你设计并实现时间复杂度为 O(n) 的算法解决此问题。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">longestConsecutive</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        res = <span class="hljs-number">0</span><br>        st = <span class="hljs-built_in">set</span>(nums)  <span class="hljs-comment"># 使用哈希集合，从而使查找为O(1)</span><br>        <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> st:<br>            <span class="hljs-keyword">if</span> num - <span class="hljs-number">1</span> <span class="hljs-keyword">in</span> st:   <span class="hljs-comment"># 从最小的开始</span><br>                <span class="hljs-keyword">continue</span><br>            last = num + <span class="hljs-number">1</span><br>            <span class="hljs-keyword">while</span> last <span class="hljs-keyword">in</span> st:<br>                last = last + <span class="hljs-number">1</span><br>            res = <span class="hljs-built_in">max</span>(res, last - num)<br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure>

<h3 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h3><h4 id="盛最多水的容器"><a href="#盛最多水的容器" class="headerlink" title="盛最多水的容器"></a>盛最多水的容器</h4><blockquote>
<p>给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。<br>找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。<br>返回容器可以储存的最大水量。<br>说明：你不能倾斜容器。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maxArea</span>(<span class="hljs-params">self, height: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        left, right = <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(height) - <span class="hljs-number">1</span><br>        res = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> left != right:<br>            h = <span class="hljs-built_in">min</span>(height[left], height[right])<br>            w = right - left<br>            res = <span class="hljs-built_in">max</span>(res, h * w)<br>            <span class="hljs-keyword">if</span> height[left] &lt; height[right]:<br>                left += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                right -= <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure>

<h4 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a>三数之和</h4><blockquote>
<p>给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i !&#x3D; j、i !&#x3D; k 且 j !&#x3D; k ，同时还满足 nums[i] + nums[j] + nums[k] &#x3D;&#x3D; 0 。请你返回所有和为 0 且不重复的三元组。<br>注意：答案中不可以包含重复的三元组。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">threeSum</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:<br>        res = []<br>        nums.sort()<br>        <span class="hljs-keyword">for</span> i, num <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(nums):<br>            <span class="hljs-keyword">if</span> num &gt; <span class="hljs-number">0</span>: <span class="hljs-comment"># 剪枝</span><br>                <span class="hljs-keyword">break</span><br>            <span class="hljs-keyword">if</span> i &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> nums[i] == nums[i - <span class="hljs-number">1</span>]:    <span class="hljs-comment"># 去重</span><br>                <span class="hljs-keyword">continue</span><br>            <span class="hljs-comment"># 双指针收缩</span><br>            j = i + <span class="hljs-number">1</span><br>            k = <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span><br>            <span class="hljs-keyword">while</span> j &lt; k:<br>                <span class="hljs-built_in">sum</span> = nums[i] + nums[j] + nums[k]<br>                <span class="hljs-keyword">if</span> <span class="hljs-built_in">sum</span> &gt; <span class="hljs-number">0</span>:<br>                    k -= <span class="hljs-number">1</span><br>                <span class="hljs-keyword">elif</span> <span class="hljs-built_in">sum</span> &lt; <span class="hljs-number">0</span>:<br>                    j += <span class="hljs-number">1</span><br>                <span class="hljs-keyword">else</span>:<br>                    res.append([nums[i], nums[j], nums[k]])<br>                    <span class="hljs-comment"># 去重</span><br>                    <span class="hljs-keyword">while</span> j &lt; k <span class="hljs-keyword">and</span> nums[j] == nums[j + <span class="hljs-number">1</span>]:<br>                        j += <span class="hljs-number">1</span><br>                    <span class="hljs-keyword">while</span> j &lt; k <span class="hljs-keyword">and</span> nums[k] == nums[k - <span class="hljs-number">1</span>]:<br>                        k -= <span class="hljs-number">1</span><br>                    j += <span class="hljs-number">1</span><br>                    k -= <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> res<br><br></code></pre></td></tr></table></figure>

<h4 id="接雨水"><a href="#接雨水" class="headerlink" title="接雨水"></a>接雨水</h4><blockquote>
<p>给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">trap</span>(<span class="hljs-params">self, height: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        n = <span class="hljs-built_in">len</span>(height)<br>        <span class="hljs-keyword">if</span> n &lt;= <span class="hljs-number">2</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        <span class="hljs-comment"># 使用单调栈记录索引，从栈顶到栈底单调递增，从而找到凹槽</span><br>        stack = []<br>        stack.append(<span class="hljs-number">0</span>)<br>        res = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n):<br>            top = stack[-<span class="hljs-number">1</span>]<br>            <span class="hljs-keyword">while</span> stack <span class="hljs-keyword">and</span> height[top] &lt; height[i]:<br>                mid = stack.pop()<br>                <span class="hljs-keyword">if</span> stack:<br>                    left = stack[-<span class="hljs-number">1</span>]<br>                    h = <span class="hljs-built_in">min</span>(height[left], height[i]) - height[mid]<br>                    w = i - left - <span class="hljs-number">1</span><br>                    res += h * w<br>                    top = stack[-<span class="hljs-number">1</span>]<br>            stack.append(i)<br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure>

<h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><h4 id="无重复字符的最长子串"><a href="#无重复字符的最长子串" class="headerlink" title="无重复字符的最长子串"></a>无重复字符的最长子串</h4><blockquote>
<p>给定一个字符串 s ，请你找出其中不含有重复字符的 最长 子串 的长度。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">lengthOfLongestSubstring</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        slow = fast = <span class="hljs-number">0</span><br>        st = <span class="hljs-built_in">set</span>()<br>        res = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> fast != <span class="hljs-built_in">len</span>(s):<br>            <span class="hljs-keyword">if</span> s[fast] <span class="hljs-keyword">in</span> st:<br>                <span class="hljs-comment"># 出现重复元素，将重复元素及其之前的元素全部清除</span><br>                <span class="hljs-keyword">while</span> s[slow] != s[fast]:<br>                    st.remove(s[slow])<br>                    slow += <span class="hljs-number">1</span><br>                slow += <span class="hljs-number">1</span>   <span class="hljs-comment"># 移动到重复元素的下一位</span><br>                fast += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                st.add(s[fast])<br>                fast += <span class="hljs-number">1</span><br>            res = <span class="hljs-built_in">max</span>(res, fast - slow)<br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure>

<h4 id="找到字符串中所有字母异位词"><a href="#找到字符串中所有字母异位词" class="headerlink" title="找到字符串中所有字母异位词"></a>找到字符串中所有字母异位词</h4><blockquote>
<p>给定两个字符串 s 和 p，找到 s 中所有 p 的 异位词 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">findAnagrams</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span>, p: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>        counter = Counter(p)    <span class="hljs-comment"># 统计p中元素出现的频率</span><br>        res = []<br>        left = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> right, c <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(s):<br>            counter[c] -= <span class="hljs-number">1</span> <span class="hljs-comment"># s中出现就减一，减到零说明找到</span><br>            <span class="hljs-keyword">while</span> counter[c] &lt; <span class="hljs-number">0</span>:   <span class="hljs-comment"># c出现过多</span><br>                counter[s[left]] += <span class="hljs-number">1</span><br>                left += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> right - left + <span class="hljs-number">1</span> == <span class="hljs-built_in">len</span>(p):  <span class="hljs-comment"># 没有超出的了，说明s子串与p构成异位词</span><br>                res.append(left)<br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure>

<h3 id="子串"><a href="#子串" class="headerlink" title="子串"></a>子串</h3><h4 id="和为-K-的子数组"><a href="#和为-K-的子数组" class="headerlink" title="和为 K 的子数组"></a>和为 K 的子数组</h4><blockquote>
<p>给你一个整数数组 nums 和一个整数 k ，请你统计并返回 该数组中和为 k 的子数组的个数 。<br>子数组是数组中元素的连续非空序列。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">subarraySum</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-comment"># 哈希表键为前缀和，值为该前缀和的个数，遍历查找s[j] - s[i] = k，即统计有多少以j结尾的子数组</span><br>        res = <span class="hljs-built_in">sum</span> = <span class="hljs-number">0</span><br>        cnt = defaultdict(<span class="hljs-built_in">int</span>)<br>        cnt[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> nums:<br>            <span class="hljs-built_in">sum</span> += num  <span class="hljs-comment"># 统计当前前缀和，即s[j]</span><br>            res += cnt[<span class="hljs-built_in">sum</span> - k] <span class="hljs-comment"># 寻找所有的s[i]</span><br>            cnt[<span class="hljs-built_in">sum</span>] += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure>

<h4 id="滑动窗口最大值"><a href="#滑动窗口最大值" class="headerlink" title="滑动窗口最大值"></a>滑动窗口最大值</h4><blockquote>
<p>给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。<br>返回 滑动窗口中的最大值 。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maxSlidingWindow</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>        <span class="hljs-comment"># 使用单调队列，队列单调递减，从而保证队首为最大值</span><br>        <span class="hljs-comment"># 同时在其后面出现的次大值不会消亡，而其前面比最大值小的会消亡</span><br>        <span class="hljs-comment"># 考虑到滑动窗口右移，左边消亡的值没有留下的意义</span><br>        res = [<span class="hljs-number">0</span>] * (<span class="hljs-built_in">len</span>(nums) - k + <span class="hljs-number">1</span>)<br>        q = deque()<br><br>        <span class="hljs-keyword">for</span> i, num <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(nums):<br>            <span class="hljs-keyword">while</span> q <span class="hljs-keyword">and</span> nums[q[-<span class="hljs-number">1</span>]] &lt;= num: <span class="hljs-comment"># 相等也要移除，因为前面的离开了而最大值不变</span><br>                q.pop() <span class="hljs-comment"># 维护单调性</span><br>            q.append(i)<br>            <br>            left = i - k + <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> q[<span class="hljs-number">0</span>] &lt; left: <span class="hljs-comment"># 队首离开窗口</span><br>                q.popleft()<br>            <br>            <span class="hljs-keyword">if</span> left &gt;= <span class="hljs-number">0</span>:<br>                res[left] = nums[q[<span class="hljs-number">0</span>]]<br>        <br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure>

<h4 id="最小覆盖子串"><a href="#最小覆盖子串" class="headerlink" title="最小覆盖子串"></a>最小覆盖子串</h4><blockquote>
<p>给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 “” 。<br>注意：<br>对于 t 中重复字符，我们寻找的子字符串中该字符数量必须不少于 t 中该字符数量。<br>如果 s 中存在这样的子串，我们保证它是唯一的答案。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minWindow</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span>, t: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">str</span>:<br>        cnt = defaultdict(<span class="hljs-built_in">int</span>)<br>        <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> t:<br>            cnt[c] += <span class="hljs-number">1</span><br>        less = <span class="hljs-built_in">len</span>(cnt)  <span class="hljs-comment"># 记录子串中有多少字母出现次数达不到t中的出现次数</span><br><br>        resLeft, resRight = -<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(s)<br>        left = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> right, c <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(s):<br>            cnt[c] -= <span class="hljs-number">1</span> <span class="hljs-comment"># 右端点进入子串</span><br>            <span class="hljs-keyword">if</span> cnt[c] == <span class="hljs-number">0</span>:<br>                less -= <span class="hljs-number">1</span>   <span class="hljs-comment"># 达到了</span><br>            <span class="hljs-keyword">while</span> less == <span class="hljs-number">0</span>:    <span class="hljs-comment"># 已全部达到，进一步缩小</span><br>                <span class="hljs-keyword">if</span> right - left &lt; resRight - resLeft:<br>                    resLeft, resRight = left, right<br>                x = s[left]<br>                <span class="hljs-keyword">if</span> cnt[x] == <span class="hljs-number">0</span>:<br>                    less += <span class="hljs-number">1</span><br>                cnt[x] += <span class="hljs-number">1</span> <span class="hljs-comment"># 左端点移出子串</span><br>                left += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span> <span class="hljs-keyword">if</span> resLeft &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> s[resLeft : resRight + <span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure>

<h3 id="普通数组"><a href="#普通数组" class="headerlink" title="普通数组"></a>普通数组</h3><h4 id="轮转数组"><a href="#轮转数组" class="headerlink" title="轮转数组"></a>轮转数组</h4><blockquote>
<p>给定一个整数数组 nums，将数组中的元素向右轮转 k 个位置，其中 k 是非负数。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">rotate</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-literal">None</span>:<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        Do not return anything, modify nums in-place instead.</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment"># 反转三次即可</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">reverse</span>(<span class="hljs-params">start: <span class="hljs-built_in">int</span>, end: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">while</span> start &lt; end:<br>                nums[start], nums[end] = nums[end], nums[start]<br>                start += <span class="hljs-number">1</span><br>                end -= <span class="hljs-number">1</span><br><br>        k %= <span class="hljs-built_in">len</span>(nums)  <span class="hljs-comment"># 否则会溢出</span><br>        reverse(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span>)<br>        reverse(<span class="hljs-number">0</span>, k - <span class="hljs-number">1</span>)<br>        reverse(k, <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure>

<h4 id="除自身以外数组的乘积"><a href="#除自身以外数组的乘积" class="headerlink" title="除自身以外数组的乘积"></a>除自身以外数组的乘积</h4><blockquote>
<p>给你一个整数数组 nums，返回 数组 answer ，其中 answer[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积 。<br>题目数据 保证 数组 nums之中任意元素的全部前缀元素和后缀的乘积都在  32 位 整数范围内。<br>请 不要使用除法，且在 O(n) 时间复杂度内完成此题。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">productExceptSelf</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>        res = [<span class="hljs-number">1</span>] * <span class="hljs-built_in">len</span>(nums)<br>        <span class="hljs-comment"># 先计算后面数字的乘积</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">2</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br>            res[i] = res[i + <span class="hljs-number">1</span>] * nums[i + <span class="hljs-number">1</span>]<br>        <span class="hljs-comment"># 再乘上前面数字的乘积</span><br>        pre = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> i, x <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(nums):<br>            res[i] *= pre<br>            pre *= x<br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure>

<h4 id="缺失的第一个正数"><a href="#缺失的第一个正数" class="headerlink" title="缺失的第一个正数"></a>缺失的第一个正数</h4><blockquote>
<p>给你一个未排序的整数数组 nums ，请你找出其中没有出现的最小的正整数。<br>请你实现时间复杂度为 O(n) 并且只使用常数级别额外空间的解决方案。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">firstMissingPositive</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-comment"># 通过交换位置，使得数字1在下标0处，数字2在下标1处，以此类推</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(nums)):<br>            <span class="hljs-comment"># 使用while，保证最后nums[i] = i + 1</span><br>            <span class="hljs-keyword">while</span> <span class="hljs-number">1</span> &lt;= nums[i] &lt;= <span class="hljs-built_in">len</span>(nums) <span class="hljs-keyword">and</span> nums[i] != nums[nums[i] - <span class="hljs-number">1</span>]:   <span class="hljs-comment"># 不使用nums[i] = i + 1，防止落入死循环</span><br>                j = nums[i] - <span class="hljs-number">1</span><br>                nums[i], nums[j] = nums[j], nums[i]<br>        <span class="hljs-comment"># 从小到大检查哪个正数缺失</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums)):<br>            <span class="hljs-keyword">if</span> nums[i] != i + <span class="hljs-number">1</span>:<br>                <span class="hljs-keyword">return</span> i + <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(nums) + <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>

<h3 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h3><h4 id="矩阵置零"><a href="#矩阵置零" class="headerlink" title="矩阵置零"></a>矩阵置零</h4><blockquote>
<p>给定一个 m x n 的矩阵，如果一个元素为 0 ，则将其所在行和列的所有元素都设为 0 。请使用 原地 算法。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">setZeroes</span>(<span class="hljs-params">self, matrix: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-literal">None</span>:<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        Do not return anything, modify matrix in-place instead.</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        m, n = <span class="hljs-built_in">len</span>(matrix), <span class="hljs-built_in">len</span>(matrix[<span class="hljs-number">0</span>])<br>        col0 = <span class="hljs-built_in">any</span>(matrix[i][<span class="hljs-number">0</span>] == <span class="hljs-number">0</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m))<br>        row0 = <span class="hljs-built_in">any</span>(matrix[<span class="hljs-number">0</span>][j] == <span class="hljs-number">0</span> <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n))<br><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, m):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n):<br>                <span class="hljs-keyword">if</span> matrix[i][j] == <span class="hljs-number">0</span>:<br>                    matrix[i][<span class="hljs-number">0</span>] = matrix[<span class="hljs-number">0</span>][j] = <span class="hljs-number">0</span><br>        <br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, m):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n):<br>                <span class="hljs-keyword">if</span> matrix[i][<span class="hljs-number">0</span>] == <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> matrix[<span class="hljs-number">0</span>][j] == <span class="hljs-number">0</span>:<br>                    matrix[i][j] = <span class="hljs-number">0</span><br>        <br>        <span class="hljs-keyword">if</span> col0:<br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>                matrix[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span><br>        <br>        <span class="hljs-keyword">if</span> row0:<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>                matrix[<span class="hljs-number">0</span>][j] = <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>

<h4 id="旋转图像"><a href="#旋转图像" class="headerlink" title="旋转图像"></a>旋转图像</h4><blockquote>
<p>给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。<br>你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">rotate</span>(<span class="hljs-params">self, matrix: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-literal">None</span>:<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        Do not return anything, modify matrix in-place instead.</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment"># 一次转置和一次行翻转</span><br>        m, n = <span class="hljs-built_in">len</span>(matrix), <span class="hljs-built_in">len</span>(matrix[<span class="hljs-number">0</span>])<br>        <span class="hljs-comment"># 转置</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i):<br>                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]<br>        <span class="hljs-comment"># 行翻转</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n // <span class="hljs-number">2</span>):<br>                matrix[i][j], matrix[i][n - <span class="hljs-number">1</span> - j] = matrix[i][n - <span class="hljs-number">1</span> - j], matrix[i][j]<br></code></pre></td></tr></table></figure>

<h4 id="搜索二维矩阵-II"><a href="#搜索二维矩阵-II" class="headerlink" title="搜索二维矩阵 II"></a>搜索二维矩阵 II</h4><blockquote>
<p>编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target 。该矩阵具有以下特性：<br>每行的元素从左到右升序排列。<br>每列的元素从上到下升序排列。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">searchMatrix</span>(<span class="hljs-params">self, matrix: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]], target: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        <span class="hljs-comment"># 使用右上角判断，以排除一定比目标值大或者一定比目标值小的部分</span><br>        i, j = <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(matrix[<span class="hljs-number">0</span>]) - <span class="hljs-number">1</span><br>        <span class="hljs-keyword">while</span> i &lt; <span class="hljs-built_in">len</span>(matrix) <span class="hljs-keyword">and</span> j &gt;= <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">if</span> matrix[i][j] == target:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>            <span class="hljs-keyword">elif</span> matrix[i][j] &gt; target:<br>                j -= <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                i += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure>

<h3 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h3><h4 id="岛屿数量"><a href="#岛屿数量" class="headerlink" title="岛屿数量"></a>岛屿数量</h4><blockquote>
<p>给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。<br>岛屿总是被水包围，并且每座岛屿只能由水平方向和&#x2F;或竖直方向上相邻的陆地连接形成。<br>此外，你可以假设该网格的四条边均被水包围。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">numIslands</span>(<span class="hljs-params">self, grid: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        m, n = <span class="hljs-built_in">len</span>(grid), <span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>])<br>        <span class="hljs-comment"># 使用dfs遍历岛屿的每一块</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">i: <span class="hljs-built_in">int</span>, j: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">if</span>(i &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> i &gt;= m <span class="hljs-keyword">or</span> j &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> j &gt;= n <span class="hljs-keyword">or</span> grid[i][j] != <span class="hljs-string">&#x27;1&#x27;</span>):<br>                <span class="hljs-keyword">return</span><br>            grid[i][j] = <span class="hljs-string">&#x27;2&#x27;</span>    <span class="hljs-comment"># 2表示已经访问</span><br>            dfs(i, j - <span class="hljs-number">1</span>)<br>            dfs(i, j + <span class="hljs-number">1</span>)<br>            dfs(i - <span class="hljs-number">1</span>, j)<br>            dfs(i + <span class="hljs-number">1</span>, j)<br>        <br>        res = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>                <span class="hljs-keyword">if</span> grid[i][j] == <span class="hljs-string">&#x27;1&#x27;</span>:<br>                    dfs(i, j)<br>                    res += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure>

<h4 id="腐烂的橘子"><a href="#腐烂的橘子" class="headerlink" title="腐烂的橘子"></a>腐烂的橘子</h4><blockquote>
<p>在给定的 m x n 网格 grid 中，每个单元格可以有以下三个值之一：<br>值 0 代表空单元格；<br>值 1 代表新鲜橘子；<br>值 2 代表腐烂的橘子。<br>每分钟，腐烂的橘子 周围 4 个方向上相邻 的新鲜橘子都会腐烂。<br>返回 直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 -1 。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">orangesRotting</span>(<span class="hljs-params">self, grid: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-comment"># bfs，使用队列记录新的腐烂的橘子</span><br>        fresh = <span class="hljs-number">0</span>   <span class="hljs-comment"># 记录是否将所有橘子腐烂</span><br>        res = <span class="hljs-number">0</span><br>        m, n = <span class="hljs-built_in">len</span>(grid), <span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>])<br>        q = []<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>                <span class="hljs-keyword">if</span> grid[i][j] == <span class="hljs-number">1</span>:<br>                    fresh += <span class="hljs-number">1</span><br>                <span class="hljs-keyword">elif</span> grid[i][j] == <span class="hljs-number">2</span>:<br>                    q.append((i, j))<br>        <span class="hljs-keyword">while</span> q <span class="hljs-keyword">and</span> fresh:<br>            res += <span class="hljs-number">1</span><br>            tmp = q<br>            q = []<br>            <span class="hljs-keyword">for</span> i, j <span class="hljs-keyword">in</span> tmp:<br>                <span class="hljs-keyword">for</span> x, y <span class="hljs-keyword">in</span> (i - <span class="hljs-number">1</span>, j), (i + <span class="hljs-number">1</span>, j), (i, j - <span class="hljs-number">1</span>), (i, j + <span class="hljs-number">1</span>):<br>                    <span class="hljs-keyword">if</span> <span class="hljs-number">0</span> &lt;= x &lt; m <span class="hljs-keyword">and</span> <span class="hljs-number">0</span> &lt;= y &lt; n <span class="hljs-keyword">and</span> grid[x][y] == <span class="hljs-number">1</span>:<br>                        grid[x][y] = <span class="hljs-number">2</span><br>                        fresh -= <span class="hljs-number">1</span><br>                        q.append((x, y))<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span> <span class="hljs-keyword">if</span> fresh != <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> res<br></code></pre></td></tr></table></figure>

<h4 id="课程表"><a href="#课程表" class="headerlink" title="课程表"></a>课程表</h4><blockquote>
<p>你这个学期必须选修 numCourses 门课程，记为 0 到 numCourses - 1 。<br>在选修某些课程之前需要一些先修课程。 先修课程按数组 prerequisites 给出，其中 prerequisites[i] &#x3D; [ai, bi] ，表示如果要学习课程 ai 则 必须 先学习课程  bi 。<br>例如，先修课程对 [0, 1] 表示：想要学习课程 0 ，你需要先完成课程 1 。<br>请你判断是否可能完成所有课程的学习？如果可以，返回 true ；否则，返回 false 。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">canFinish</span>(<span class="hljs-params">self, numCourses: <span class="hljs-built_in">int</span>, prerequisites: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        <span class="hljs-comment"># 三色标记法，0表示未访问，1表示正在访问，2表示已经访问</span><br>        graph = [[] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(numCourses)]<br>        <span class="hljs-keyword">for</span> a, b <span class="hljs-keyword">in</span> prerequisites:<br>            graph[b].append(a)  <span class="hljs-comment"># 使用链表表示该图</span><br>        <br>        colors = [<span class="hljs-number">0</span>] * numCourses<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">course : <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">bool</span>:<br>            colors[course] = <span class="hljs-number">1</span>  <span class="hljs-comment"># 正在访问</span><br>            <span class="hljs-keyword">for</span> nxt <span class="hljs-keyword">in</span> graph[course]:<br>                <span class="hljs-comment"># 正在访问，或者未访问的在深度搜索后出现了环</span><br>                <span class="hljs-keyword">if</span> colors[nxt] == <span class="hljs-number">1</span> <span class="hljs-keyword">or</span> colors[nxt] == <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> dfs(nxt):<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>            colors[course] = <span class="hljs-number">2</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        <br>        <span class="hljs-keyword">for</span> course <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(numCourses):<br>            <span class="hljs-keyword">if</span> colors[course] == <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> dfs(course): <span class="hljs-comment"># 有环</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure>

<h4 id="实现-Trie-前缀树"><a href="#实现-Trie-前缀树" class="headerlink" title="实现 Trie (前缀树)"></a>实现 Trie (前缀树)</h4><blockquote>
<p>Trie（发音类似 “try”）或者说 前缀树 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补全和拼写检查。<br>请你实现 Trie 类：<br>Trie() 初始化前缀树对象。<br>void insert(String word) 向前缀树中插入字符串 word 。<br>boolean search(String word) 如果字符串 word 在前缀树中，返回 true（即，在检索之前已经插入）；否则，返回 false 。<br>boolean startsWith(String prefix) 如果之前已经插入的字符串 word 的前缀之一为 prefix ，返回 true ；否则，返回 false 。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-variable language_">self</span>.son = &#123;&#125;<br>        <span class="hljs-variable language_">self</span>.end = <span class="hljs-literal">False</span>    <span class="hljs-comment"># 以这个节点为结尾，组成的前缀是否构成插入的字符串</span><br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Trie</span>:<br>    <span class="hljs-comment"># 即26叉树</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-variable language_">self</span>.root = Node()<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">insert</span>(<span class="hljs-params">self, word: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-literal">None</span>:<br>        cur = <span class="hljs-variable language_">self</span>.root<br>        <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> word:<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> c <span class="hljs-keyword">in</span> cur.son:<br>                cur.son[c] = Node()<br>            cur = cur.son[c]<br>        cur.end = <span class="hljs-literal">True</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">search</span>(<span class="hljs-params">self, word: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span> <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.find(word) == <span class="hljs-number">2</span> <span class="hljs-keyword">else</span> <span class="hljs-literal">False</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">startsWith</span>(<span class="hljs-params">self, prefix: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span> <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.find(prefix) <span class="hljs-keyword">else</span> <span class="hljs-literal">False</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">find</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-comment"># 0表示未找到，1表示只找到前缀，2表示找到完整的字符串</span><br>        cur = <span class="hljs-variable language_">self</span>.root<br>        <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> s:<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> c <span class="hljs-keyword">in</span> cur.son:<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>            cur = cur.son[c]<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> <span class="hljs-keyword">if</span> cur.end <span class="hljs-keyword">else</span> <span class="hljs-number">1</span><br>        <br><br><br><span class="hljs-comment"># Your Trie object will be instantiated and called as such:</span><br><span class="hljs-comment"># obj = Trie()</span><br><span class="hljs-comment"># obj.insert(word)</span><br><span class="hljs-comment"># param_2 = obj.search(word)</span><br><span class="hljs-comment"># param_3 = obj.startsWith(prefix)</span><br></code></pre></td></tr></table></figure>

<h3 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h3><h4 id="电话号码的字母组合"><a href="#电话号码的字母组合" class="headerlink" title="电话号码的字母组合"></a>电话号码的字母组合</h4><blockquote>
<p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。<br>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">letterCombinations</span>(<span class="hljs-params">self, digits: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]:<br>        numString = [<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-string">&quot;def&quot;</span>, <span class="hljs-string">&quot;ghi&quot;</span>, <span class="hljs-string">&quot;jkl&quot;</span>, <span class="hljs-string">&quot;mno&quot;</span>, <span class="hljs-string">&quot;pqrs&quot;</span>, <span class="hljs-string">&quot;tuv&quot;</span>, <span class="hljs-string">&quot;wxyz&quot;</span>]<br>        res = []<br>        path = []<br><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">backtracking</span>(<span class="hljs-params">index: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(path) == <span class="hljs-built_in">len</span>(digits):<br>                res.append(<span class="hljs-string">&quot;&quot;</span>.join(path[:]))<br>                <span class="hljs-keyword">return</span><br>            <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> numString[<span class="hljs-built_in">int</span>(digits[index])]:<br>                path.append(c)<br>                backtracking(index + <span class="hljs-number">1</span>)<br>                path.pop()<br>        <br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> digits <span class="hljs-keyword">or</span> <span class="hljs-built_in">len</span>(digits) == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> res<br>        backtracking(<span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure>

<h4 id="括号生成"><a href="#括号生成" class="headerlink" title="括号生成"></a>括号生成</h4><blockquote>
<p>数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">generateParenthesis</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]:<br>        res = []<br>        path = []   <span class="hljs-comment"># path记录左括号的索引</span><br><br>        <span class="hljs-comment"># 使用balance记录左括号数与右括号数之差，index则为上一个左括号的索引</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">backtracking</span>(<span class="hljs-params">index: <span class="hljs-built_in">int</span>, balance: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(path) == n:<br>                ans = [<span class="hljs-string">&#x27;)&#x27;</span>] * <span class="hljs-number">2</span> * n<br>                <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> path:<br>                    ans[i] = <span class="hljs-string">&#x27;(&#x27;</span><br>                res.append(<span class="hljs-string">&#x27;&#x27;</span>.join(ans))<br>                <span class="hljs-keyword">return</span><br>            <span class="hljs-comment"># 每次加入b个右括号，再加入一个左括号</span><br>            <span class="hljs-keyword">for</span> b <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(balance + <span class="hljs-number">1</span>):<br>                path.append(index + b + <span class="hljs-number">1</span>)<br>                backtracking(index + b + <span class="hljs-number">1</span>, balance - b + <span class="hljs-number">1</span>)<br>                path.pop()<br><br>        backtracking(-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure>

<h4 id="单词搜索"><a href="#单词搜索" class="headerlink" title="单词搜索"></a>单词搜索</h4><blockquote>
<p>给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。<br>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">exist</span>(<span class="hljs-params">self, board: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]], word: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        m, n = <span class="hljs-built_in">len</span>(board), <span class="hljs-built_in">len</span>(board[<span class="hljs-number">0</span>])<br><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">backtracking</span>(<span class="hljs-params">i: <span class="hljs-built_in">int</span>, j: <span class="hljs-built_in">int</span>, index: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">bool</span>:<br>            <span class="hljs-keyword">if</span> board[i][j] != word[index]:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>            <br>            <span class="hljs-keyword">if</span> index == <span class="hljs-built_in">len</span>(word) - <span class="hljs-number">1</span>:  <span class="hljs-comment"># 减一是因为刚刚已判断出最后一位匹配</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>            <br>            board[i][j] = <span class="hljs-string">&#x27;0&#x27;</span>   <span class="hljs-comment"># 标记为已经访问</span><br>            <br>            <span class="hljs-keyword">for</span> x, y <span class="hljs-keyword">in</span> (i, j - <span class="hljs-number">1</span>), (i, j + <span class="hljs-number">1</span>), (i - <span class="hljs-number">1</span>, j), (i + <span class="hljs-number">1</span>, j):<br>                <span class="hljs-keyword">if</span> <span class="hljs-number">0</span> &lt;= x &lt; m <span class="hljs-keyword">and</span> <span class="hljs-number">0</span> &lt;= y &lt; n <span class="hljs-keyword">and</span> backtracking(x, y, index + <span class="hljs-number">1</span>):<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>            <br>            board[i][j] = word[index]   <span class="hljs-comment"># 回溯</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>                <span class="hljs-keyword">if</span> backtracking(i, j, <span class="hljs-number">0</span>):<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure>

<h4 id="分割回文串"><a href="#分割回文串" class="headerlink" title="分割回文串"></a>分割回文串</h4><blockquote>
<p>给你一个字符串 s，请你将 s 分割成一些 子串，使每个子串都是 回文串 。返回 s 所有可能的分割方案。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">partition</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]]:<br>        res = []<br>        path = []<br><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">check</span>(<span class="hljs-params">prefix: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">bool</span>:<br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(prefix) // <span class="hljs-number">2</span>):<br>                <span class="hljs-keyword">if</span> prefix[i] != prefix[<span class="hljs-built_in">len</span>(prefix) - i - <span class="hljs-number">1</span>]:<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">backtracking</span>(<span class="hljs-params">index: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">if</span> index == <span class="hljs-built_in">len</span>(s):<br>                res.append(path[:])<br>                <span class="hljs-keyword">return</span><br><br>            prefix = []<br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(index, <span class="hljs-built_in">len</span>(s)):<br>                <span class="hljs-comment"># 构造以index开始，i结束的回文</span><br>                prefix.append(s[i])<br>                <span class="hljs-keyword">if</span> check(prefix):<br>                    path.append(<span class="hljs-string">&#x27;&#x27;</span>.join(prefix))<br>                    backtracking(i + <span class="hljs-number">1</span>)<br>                    path.pop()<br>        <br>        backtracking(<span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure>

<h4 id="N皇后"><a href="#N皇后" class="headerlink" title="N皇后"></a>N皇后</h4><blockquote>
<p>按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。<br>n 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。<br>给你一个整数 n ，返回所有不同的 n 皇后问题 的解决方案。<br>每一种解法包含一个不同的 n 皇后问题 的棋子放置方案，该方案中 ‘Q’ 和 ‘.’ 分别代表了皇后和空位。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">solveNQueens</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]]:<br>        res = []<br>        board = [-<span class="hljs-number">1</span>] * n <span class="hljs-comment"># 记录皇后在每一行的第几列</span><br>        <span class="hljs-comment"># 都是从上到下的顺序</span><br>        usedCol = [<span class="hljs-literal">False</span>] * n<br>        used45 = [<span class="hljs-literal">False</span>] * (<span class="hljs-number">2</span> * n - <span class="hljs-number">1</span>)<br>        used135 = [<span class="hljs-literal">False</span>] * (<span class="hljs-number">2</span> * n - <span class="hljs-number">1</span>)<br><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">backtracking</span>(<span class="hljs-params">row: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">if</span> row == n:<br>                path = []<br>                <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>                    s = [<span class="hljs-string">&#x27;.&#x27;</span>] * n<br>                    s[board[i]] = <span class="hljs-string">&#x27;Q&#x27;</span><br>                    path.append(<span class="hljs-string">&#x27;&#x27;</span>.join(s))<br>                res.append(path[:])<br>            <br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>                <span class="hljs-keyword">if</span> usedCol[i] <span class="hljs-keyword">or</span> used45[i + row] <span class="hljs-keyword">or</span> used135[n - <span class="hljs-number">1</span> + row - i]:<br>                    <span class="hljs-keyword">continue</span><br>                board[row] = i<br>                usedCol[i] = <span class="hljs-literal">True</span><br>                used45[i + row] = <span class="hljs-literal">True</span><br>                used135[n - <span class="hljs-number">1</span> + row - i] = <span class="hljs-literal">True</span><br>                backtracking(row + <span class="hljs-number">1</span>)<br>                used135[n - <span class="hljs-number">1</span> + row - i] = <span class="hljs-literal">False</span><br>                used45[i + row] = <span class="hljs-literal">False</span><br>                usedCol[i] = <span class="hljs-literal">False</span><br>            <br>        backtracking(<span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure>

<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><h4 id="最小栈"><a href="#最小栈" class="headerlink" title="最小栈"></a>最小栈</h4><blockquote>
<p>设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。<br>实现 MinStack 类:<br>MinStack() 初始化堆栈对象。<br>void push(int val) 将元素val推入堆栈。<br>void pop() 删除堆栈顶部的元素。<br>int top() 获取堆栈顶部的元素。<br>int getMin() 获取堆栈中的最小元素。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MinStack</span>:<br>    <span class="hljs-comment"># 栈中元素配对，前者为当前元素，后者为前缀最小值</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-variable language_">self</span>.stack = [(<span class="hljs-number">0</span>, inf)] <span class="hljs-comment"># 放一个哨兵，从而不必检查栈空</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">push</span>(<span class="hljs-params">self, val: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-literal">None</span>:<br>        <span class="hljs-variable language_">self</span>.stack.append((val, <span class="hljs-built_in">min</span>(val, <span class="hljs-variable language_">self</span>.getMin())))<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">pop</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-literal">None</span>:<br>        <span class="hljs-variable language_">self</span>.stack.pop()<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">top</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.stack[-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">getMin</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.stack[-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]<br><br><br><span class="hljs-comment"># Your MinStack object will be instantiated and called as such:</span><br><span class="hljs-comment"># obj = MinStack()</span><br><span class="hljs-comment"># obj.push(val)</span><br><span class="hljs-comment"># obj.pop()</span><br><span class="hljs-comment"># param_3 = obj.top()</span><br><span class="hljs-comment"># param_4 = obj.getMin()</span><br></code></pre></td></tr></table></figure>

<h4 id="字符串解码"><a href="#字符串解码" class="headerlink" title="字符串解码"></a>字符串解码</h4><blockquote>
<p>给定一个经过编码的字符串，返回它解码后的字符串。<br>编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。<br>你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。<br>此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。<br>测试用例保证输出的长度不会超过 105。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">decodeString</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">str</span>:<br>        <span class="hljs-comment"># 认为每出现一组[]陷入一次递归，使用栈来模拟</span><br>        res = <span class="hljs-string">&quot;&quot;</span><br>        k = <span class="hljs-number">0</span>   <span class="hljs-comment"># 记录[]前的那个数字</span><br>        stack = []<br>        <br>        <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> s:<br>            <span class="hljs-keyword">if</span> c.isalpha():<br>                res += c<br>            <span class="hljs-keyword">elif</span> c.isdigit():<br>                k = k * <span class="hljs-number">10</span> + <span class="hljs-built_in">int</span>(c)<br>            <span class="hljs-keyword">elif</span> c == <span class="hljs-string">&#x27;[&#x27;</span>:  <span class="hljs-comment"># 之前的结果入栈，防止丢失</span><br>                stack.append((res, k))<br>                res = <span class="hljs-string">&quot;&quot;</span><br>                k = <span class="hljs-number">0</span>   <span class="hljs-comment"># 因此在else处不用k = 0，因为最深的[]没有数字出现</span><br>            <span class="hljs-keyword">else</span>:   <span class="hljs-comment"># 递归结束，出栈进行拼接、</span><br>                pre_res, pre_k = stack.pop()<br>                res = pre_res + res * pre_k<br><br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure>

<h4 id="柱状图中最大的矩形"><a href="#柱状图中最大的矩形" class="headerlink" title="柱状图中最大的矩形"></a>柱状图中最大的矩形</h4><blockquote>
<p>给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。<br>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">largestRectangleArea</span>(<span class="hljs-params">self, heights: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-comment"># 该单调栈从栈顶到栈底单调递减</span><br>        heights.append(-<span class="hljs-number">1</span>)  <span class="hljs-comment"># 从而保证到最后时，栈中元素都出来进行计算</span><br>        stack = [-<span class="hljs-number">1</span>]    <span class="hljs-comment"># 保证栈空时入栈</span><br>        res = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> right <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(heights)):<br>            <span class="hljs-comment"># left和right之间的所有柱子中，mid是最矮的那个，故高计算正确</span><br>            <span class="hljs-comment"># 因为mid左边的柱子中，第一个比它矮的依然在栈中，即left</span><br>            <span class="hljs-comment"># 而mid右边如果有比它矮的柱子，则mid会提前出栈</span><br>            <span class="hljs-comment"># 而left和right都比mid矮，因此宽是最大的</span><br>            <span class="hljs-keyword">while</span> heights[stack[-<span class="hljs-number">1</span>]] &gt; heights[right]:<br>                mid = stack.pop()<br>                left = stack[-<span class="hljs-number">1</span>]<br>                h = heights[mid]<br>                w = right - left - <span class="hljs-number">1</span><br>                res = <span class="hljs-built_in">max</span>(res, h * w)<br>            stack.append(right)<br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure>

<h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><h4 id="数组中的第K个最大元素"><a href="#数组中的第K个最大元素" class="headerlink" title="数组中的第K个最大元素"></a>数组中的第K个最大元素</h4><blockquote>
<p>给定整数数组 nums 和整数 k，请返回数组中第 k 个最大的元素。<br>请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。<br>你必须设计并实现时间复杂度为 O(n) 的算法解决此问题。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">findKthLargest</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">quick_select</span>(<span class="hljs-params">nums, k</span>) -&gt; <span class="hljs-built_in">int</span>:<br>            pivot = random.choice(nums) <span class="hljs-comment"># 随机选择基准数</span><br>            big, equal, small = [], [], []<br>            <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> nums:<br>                <span class="hljs-keyword">if</span> num &gt; pivot:<br>                    big.append(num)<br>                <span class="hljs-keyword">elif</span> num &lt; pivot:<br>                    small.append(num)<br>                <span class="hljs-keyword">else</span>:<br>                    equal.append(num)<br>            <span class="hljs-keyword">if</span> k &lt;= <span class="hljs-built_in">len</span>(big):<br>                <span class="hljs-keyword">return</span> quick_select(big, k)<br>            <span class="hljs-keyword">elif</span> <span class="hljs-built_in">len</span>(nums) - <span class="hljs-built_in">len</span>(small) &lt; k:<br>                <span class="hljs-keyword">return</span> quick_select(small, k - <span class="hljs-built_in">len</span>(nums) + <span class="hljs-built_in">len</span>(small))<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">return</span> pivot<br>        <span class="hljs-keyword">return</span> quick_select(nums, k)<br></code></pre></td></tr></table></figure>

<h4 id="前-K-个高频元素"><a href="#前-K-个高频元素" class="headerlink" title="前 K 个高频元素"></a>前 K 个高频元素</h4><blockquote>
<p>给你一个整数数组 nums 和一个整数 k ，请你返回其中出现频率前 k 高的元素。你可以按 任意顺序 返回答案。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">topKFrequent</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>        <span class="hljs-comment"># 使用桶排序</span><br>        <span class="hljs-comment"># step1: 使用哈希表统计每个元素出现的次数</span><br>        cnt = Counter(nums)<br>        max_cnt = <span class="hljs-built_in">max</span>(cnt.values())<br><br>        <span class="hljs-comment"># step2: 出现次数相同的元素放在同一个桶中</span><br>        buckets = [[] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(max_cnt + <span class="hljs-number">1</span>)]<br>        <span class="hljs-keyword">for</span> x, c <span class="hljs-keyword">in</span> cnt.items():<br>            buckets[c].append(x)<br>        <br>        <span class="hljs-comment"># step3: 倒序遍历buckets，从而得到答案</span><br>        res = []<br>        <span class="hljs-keyword">for</span> bucket <span class="hljs-keyword">in</span> <span class="hljs-built_in">reversed</span>(buckets):<br>            res += bucket<br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(res) == k:<br>                <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure>

<h4 id="数据流的中位数"><a href="#数据流的中位数" class="headerlink" title="数据流的中位数"></a>数据流的中位数</h4><blockquote>
<p>中位数是有序整数列表中的中间值。如果列表的大小是偶数，则没有中间值，中位数是两个中间值的平均值。<br>例如 arr &#x3D; [2,3,4] 的中位数是 3 。<br>例如 arr &#x3D; [2,3] 的中位数是 (2 + 3) &#x2F; 2 &#x3D; 2.5 。<br>实现 MedianFinder 类:<br>MedianFinder() 初始化 MedianFinder 对象。<br>void addNum(int num) 将数据流中的整数 num 添加到数据结构中。<br>double findMedian() 返回到目前为止所有元素的中位数。与实际答案相差 10-5 以内的答案将被接受。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MedianFinder</span>:<br>    <span class="hljs-comment"># 分为两个堆left和right，保证left的最大值小于right的最小值的同时，维护left - right &lt;= 1</span><br>    <span class="hljs-comment"># 当left == right时，将元素添加到right中，并将right的最小值移到left中</span><br>    <span class="hljs-comment"># 当left - right == 1时，将元素添加到left中，并将left的最大值移到right中</span><br>    <span class="hljs-comment"># 使用left的最大值和right的最小值来计算中位数</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-variable language_">self</span>.left = []<br>        <span class="hljs-variable language_">self</span>.right = []<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">addNum</span>(<span class="hljs-params">self, num: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-literal">None</span>:<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(<span class="hljs-variable language_">self</span>.left) == <span class="hljs-built_in">len</span>(<span class="hljs-variable language_">self</span>.right):<br>            heapq.heappush(<span class="hljs-variable language_">self</span>.right, num)<br>            heapq.heappush(<span class="hljs-variable language_">self</span>.left, -heapq.heappop(<span class="hljs-variable language_">self</span>.right))<br>        <span class="hljs-keyword">else</span>:<br>            heapq.heappush(<span class="hljs-variable language_">self</span>.left, -num)<br>            heapq.heappush(<span class="hljs-variable language_">self</span>.right, -heapq.heappop(<span class="hljs-variable language_">self</span>.left))<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">findMedian</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">float</span>:<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(<span class="hljs-variable language_">self</span>.left) == <span class="hljs-built_in">len</span>(<span class="hljs-variable language_">self</span>.right):<br>            <span class="hljs-keyword">return</span> (-<span class="hljs-variable language_">self</span>.left[<span class="hljs-number">0</span>] + <span class="hljs-variable language_">self</span>.right[<span class="hljs-number">0</span>]) / <span class="hljs-number">2</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> -<span class="hljs-variable language_">self</span>.left[<span class="hljs-number">0</span>]<br></code></pre></td></tr></table></figure>

<h3 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h3><h4 id="跳跃游戏-II"><a href="#跳跃游戏-II" class="headerlink" title="跳跃游戏 II"></a>跳跃游戏 II</h4><blockquote>
<p>给定一个长度为 n 的 0 索引整数数组 nums。初始位置在下标 0。<br>每个元素 nums[i] 表示从索引 i 向后跳转的最大长度。换句话说，如果你在索引 i 处，你可以跳转到任意 (i + j) 处：<br>0 &lt;&#x3D; j &lt;&#x3D; nums[i] 且<br>i + j &lt; n<br>返回到达 n - 1 的最小跳跃次数。测试用例保证可以到达 n - 1。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">jump</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-comment"># 当触及到当前跳跃极限时进行跳跃，并更新覆盖范围</span><br>        <span class="hljs-comment"># 这次跳跃本质上是跳到了能触及下次跳跃极限的位置</span><br>        <span class="hljs-comment"># 这样是正确的，因为迭代器局限在当前覆盖范围之内</span><br>        curJump, nextJump, res, i = <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> i &lt;= curJump <span class="hljs-keyword">and</span> curJump &lt; <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span>:<br>            nextJump = <span class="hljs-built_in">max</span>(nextJump, i + nums[i])<br>            <span class="hljs-keyword">if</span> i == curJump:<br>                curJump = nextJump<br>                res += <span class="hljs-number">1</span><br>            i += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure>

<h4 id="划分字母区间"><a href="#划分字母区间" class="headerlink" title="划分字母区间"></a>划分字母区间</h4><blockquote>
<p>给你一个字符串 s 。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。例如，字符串 “ababcc” 能够被分为 [“abab”, “cc”]，但类似 [“aba”, “bcc”] 或 [“ab”, “ab”, “cc”] 的划分是非法的。<br>注意，划分结果需要满足：将所有划分结果按顺序连接，得到的字符串仍然是 s 。<br>返回一个表示每个字符串片段的长度的列表。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">partitionLabels</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>        <span class="hljs-comment"># 类似于跳跃游戏，遍历字母，找到它们最后出现在哪里，当触及到边缘时，分割出一个区间</span><br>        further = [<span class="hljs-number">0</span>] * <span class="hljs-number">26</span><br>        <span class="hljs-comment"># 记录最后一次出现在哪里</span><br>        <span class="hljs-keyword">for</span> i, c <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(s):<br>            further[<span class="hljs-built_in">ord</span>(c) - <span class="hljs-number">97</span>] = i<br>        most,last = <span class="hljs-number">0</span>, -<span class="hljs-number">1</span><br>        res = []<br>        <span class="hljs-keyword">for</span> i, c <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(s):<br>            most = <span class="hljs-built_in">max</span>(most, further[<span class="hljs-built_in">ord</span>(c) - <span class="hljs-number">97</span>])<br>            <span class="hljs-keyword">if</span> i == most:<br>                res.append(most - last)<br>                last = most<br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure>

<h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><h4 id="完全平方数"><a href="#完全平方数" class="headerlink" title="完全平方数"></a>完全平方数</h4><blockquote>
<p>给你一个整数 n ，返回 和为 n 的完全平方数的最少数量 。<br>完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">numSquares</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        dp = [inf] * (n + <span class="hljs-number">1</span>)<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span><br>        i = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">while</span> i * i &lt;= n:<br>            j = i * i<br>            <span class="hljs-keyword">while</span> j &lt;= n:<br>                dp[j] = <span class="hljs-built_in">min</span>(dp[j], dp[j - i * i] + <span class="hljs-number">1</span>)<br>                j += <span class="hljs-number">1</span><br>            i += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> dp[n]<br></code></pre></td></tr></table></figure>

<h4 id="单词拆分"><a href="#单词拆分" class="headerlink" title="单词拆分"></a>单词拆分</h4><blockquote>
<p>给你一个字符串 s 和一个字符串列表 wordDict 作为字典。如果可以利用字典中出现的一个或多个单词拼接出 s 则返回 true。<br>注意：不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wordBreak</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span>, wordDict: <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]</span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        dp = [<span class="hljs-literal">False</span>] * (<span class="hljs-built_in">len</span>(s) + <span class="hljs-number">1</span>)<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(s) + <span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">for</span> word <span class="hljs-keyword">in</span> wordDict:<br>                <span class="hljs-keyword">if</span> s[i - <span class="hljs-built_in">len</span>(word): i] == word <span class="hljs-keyword">and</span> dp[i - <span class="hljs-built_in">len</span>(word)]:<br>                    dp[i] = <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">return</span> dp[<span class="hljs-built_in">len</span>(s)]<br></code></pre></td></tr></table></figure>

<h4 id="最长递增子序列"><a href="#最长递增子序列" class="headerlink" title="最长递增子序列"></a>最长递增子序列</h4><blockquote>
<p>给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。<br>子序列 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">lengthOfLIS</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-comment"># dp[i]表示以i结尾的最长递增子序列的长度</span><br>        dp = [<span class="hljs-number">1</span>] * <span class="hljs-built_in">len</span>(nums)    <span class="hljs-comment"># 自身构成一个最短的递增子序列</span><br>        res = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(nums)):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, i):<br>                <span class="hljs-keyword">if</span> nums[j] &lt; nums[i]:<br>                    dp[i] = <span class="hljs-built_in">max</span>(dp[i], dp[j] + <span class="hljs-number">1</span>)<br>            res = <span class="hljs-built_in">max</span>(res, dp[i])<br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure>

<h4 id="乘积最大子数组"><a href="#乘积最大子数组" class="headerlink" title="乘积最大子数组"></a>乘积最大子数组</h4><blockquote>
<p>给你一个整数数组 nums ，请你找出数组中乘积最大的非空连续 子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。<br>测试用例的答案是一个 32-位 整数。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maxProduct</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-comment"># dp[0]表示以i结尾的最大值，dp[1]表示最小值，从而包含到正负性</span><br>        dp = [nums[<span class="hljs-number">0</span>]] * <span class="hljs-number">2</span>       <br>        res = nums[<span class="hljs-number">0</span>]<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(nums)):<br>            dp[<span class="hljs-number">0</span>], dp[<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(nums[i], nums[i] * dp[<span class="hljs-number">0</span>], nums[i] * dp[<span class="hljs-number">1</span>]), <span class="hljs-built_in">min</span>(nums[i], nums[i] * dp[<span class="hljs-number">0</span>], nums[i] * dp[<span class="hljs-number">1</span>])<br>            res = <span class="hljs-built_in">max</span>(res, dp[<span class="hljs-number">0</span>])<br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure>

<h4 id="分割等和子集"><a href="#分割等和子集" class="headerlink" title="分割等和子集"></a>分割等和子集</h4><blockquote>
<p>给你一个 只包含正整数 的 非空 数组 nums 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">canPartition</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        <span class="hljs-comment"># 即能否塞满sum / 2的背包</span><br>        <span class="hljs-comment"># dp[i]表示容量为i的最大价值</span><br>        <span class="hljs-comment"># 这里让重量等于价值，防止价值超出target</span><br>        total = <span class="hljs-built_in">sum</span>(nums)<br>        <span class="hljs-keyword">if</span> total % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        target = total // <span class="hljs-number">2</span><br>        dp = [<span class="hljs-number">0</span>] * (target + <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums)):<br>            <span class="hljs-comment"># 倒序遍历，防止提前更新数据</span><br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(target, nums[i] - <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br>                dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j - nums[i]] + nums[i])<br>            <span class="hljs-comment"># 剪枝</span><br>            <span class="hljs-keyword">if</span> dp[target] == target:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">return</span> dp[target] == target<br></code></pre></td></tr></table></figure>

<h4 id="最长有效括号"><a href="#最长有效括号" class="headerlink" title="最长有效括号"></a>最长有效括号</h4><blockquote>
<p>给你一个只包含 ‘(‘ 和 ‘)’ 的字符串，找出最长有效（格式正确且连续）括号 子串 的长度。<br>左右括号匹配，即每个左括号都有对应的右括号将其闭合的字符串是格式正确的，比如 “(()())”。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">longestValidParentheses</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-comment"># dp[i] 表示以i结尾的有效长度</span><br>        res = <span class="hljs-number">0</span><br>        dp = [<span class="hljs-number">0</span>] * <span class="hljs-built_in">len</span>(s)<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(s)):<br>            <span class="hljs-comment"># 有效的括号一定以&#x27;)&#x27;结尾</span><br>            <span class="hljs-keyword">if</span> s[i] == <span class="hljs-string">&#x27;)&#x27;</span>:<br>                <span class="hljs-keyword">if</span> s[i - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;(&#x27;</span>:<br>                    dp[i] = (dp[i - <span class="hljs-number">2</span>] <span class="hljs-keyword">if</span> i - <span class="hljs-number">2</span> &gt;= <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> <span class="hljs-number">0</span>) + <span class="hljs-number">2</span><br>                <span class="hljs-comment"># 跳过中间的有效部分后，如果不是&#x27;(&#x27;，那也就不是有效的了</span><br>                <span class="hljs-keyword">elif</span> i - dp[i - <span class="hljs-number">1</span>] - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> s[i - dp[i - <span class="hljs-number">1</span>] - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;(&#x27;</span>:<br>                    dp[i] = dp[i - <span class="hljs-number">1</span>] + (dp[i - dp[i - <span class="hljs-number">1</span>] - <span class="hljs-number">2</span>] <span class="hljs-keyword">if</span> i - dp[i - <span class="hljs-number">1</span>] - <span class="hljs-number">2</span> &gt;= <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> <span class="hljs-number">0</span>) + <span class="hljs-number">2</span><br>            res = <span class="hljs-built_in">max</span>(res, dp[i])<br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure>

<h3 id="多维动态规划"><a href="#多维动态规划" class="headerlink" title="多维动态规划"></a>多维动态规划</h3><h4 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a>最长回文子串</h4><blockquote>
<p>给你一个字符串 s，找到 s 中最长的 回文 子串。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">longestPalindrome</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">str</span>:<br>        <span class="hljs-comment"># 中心扩散法，枚举中心向两边扩散到最长回文</span><br>        n = <span class="hljs-built_in">len</span>(s)<br>        res_left = res_right = <span class="hljs-number">0</span><br><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span> * n - <span class="hljs-number">1</span>):<br>            <span class="hljs-comment"># 包揽奇数回文串和偶数回文串</span><br>            l, r = i // <span class="hljs-number">2</span>, (i + <span class="hljs-number">1</span>) // <span class="hljs-number">2</span><br>            <span class="hljs-keyword">while</span> l &gt;= <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> r &lt; n <span class="hljs-keyword">and</span> s[l] == s[r]:<br>                l -= <span class="hljs-number">1</span><br>                r += <span class="hljs-number">1</span><br>            <span class="hljs-comment"># 结束时，s[l + 1]到s[r - 1]为回文串</span><br>            <span class="hljs-keyword">if</span> r - l - <span class="hljs-number">1</span> &gt; res_right - res_left:<br>                res_left, res_right = l + <span class="hljs-number">1</span>, r  <span class="hljs-comment"># 左闭右开</span><br>        <span class="hljs-keyword">return</span> s[res_left: res_right]<br></code></pre></td></tr></table></figure>

<h4 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h4><blockquote>
<p>给定两个字符串 text1 和 text2，返回这两个字符串的最长 公共子序列 的长度。如果不存在 公共子序列 ，返回 0 。<br>一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。<br>例如，”ace” 是 “abcde” 的子序列，但 “aec” 不是 “abcde” 的子序列。<br>两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">longestCommonSubsequence</span>(<span class="hljs-params">self, text1: <span class="hljs-built_in">str</span>, text2: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-comment"># 类似于编辑距离，dp[i][j]记录text[:i]和text2[:j]的最长公共子序列</span><br>        <span class="hljs-comment"># 从dp[0][0]开始，即表示两者都为空</span><br>        m, n = <span class="hljs-built_in">len</span>(text1), <span class="hljs-built_in">len</span>(text2)<br>        dp = [[<span class="hljs-number">0</span>] * (n + <span class="hljs-number">1</span>) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m + <span class="hljs-number">1</span>)]<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, m + <span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):<br>                <span class="hljs-keyword">if</span> text1[i - <span class="hljs-number">1</span>] == text2[j - <span class="hljs-number">1</span>]:<br>                    <span class="hljs-comment"># 不用考虑dp[i - 1][j]和dp[i][j - 1]的原因是，这两个只比dp[i - 1][j - 1]多一个字符</span><br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span><br>                <span class="hljs-keyword">else</span>:<br>                    dp[i][j] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>])<br>        <span class="hljs-keyword">return</span> dp[m][n]<br></code></pre></td></tr></table></figure>

<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><h4 id="回文链表"><a href="#回文链表" class="headerlink" title="回文链表"></a>回文链表</h4><blockquote>
<p>给你一个单链表的头节点 head ，请你判断该链表是否为回文链表。如果是，返回 true ；否则，返回 false 。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Definition for singly-linked list.</span><br><span class="hljs-comment"># class ListNode:</span><br><span class="hljs-comment">#     def __init__(self, val=0, next=None):</span><br><span class="hljs-comment">#         self.val = val</span><br><span class="hljs-comment">#         self.next = next</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-comment"># 从中间节点开始反转链表</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">findMid</span>(<span class="hljs-params">self, head: <span class="hljs-type">Optional</span>[ListNode]</span>) -&gt; <span class="hljs-type">Optional</span>[ListNode]:<br>        fast, slow = head, head<br>        <span class="hljs-keyword">while</span> fast <span class="hljs-keyword">and</span> fast.<span class="hljs-built_in">next</span>:<br>            fast, slow = fast.<span class="hljs-built_in">next</span>.<span class="hljs-built_in">next</span>, slow.<span class="hljs-built_in">next</span><br>        <span class="hljs-keyword">return</span> slow<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">reverseList</span>(<span class="hljs-params">self, head: <span class="hljs-type">Optional</span>[ListNode]</span>) -&gt; <span class="hljs-type">Optional</span>[ListNode]:<br>        cur, prev = head, <span class="hljs-literal">None</span><br>        <span class="hljs-keyword">while</span> cur:<br>            cur.<span class="hljs-built_in">next</span>, cur, prev = prev, cur.<span class="hljs-built_in">next</span>, cur<br>        <span class="hljs-keyword">return</span> prev<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">isPalindrome</span>(<span class="hljs-params">self, head: <span class="hljs-type">Optional</span>[ListNode]</span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        mid = <span class="hljs-variable language_">self</span>.findMid(head)<br>        head2 = <span class="hljs-variable language_">self</span>.reverseList(mid)<br>        <span class="hljs-keyword">while</span> head2:<br>            <span class="hljs-keyword">if</span> head.val != head2.val:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>            head, head2 = head.<span class="hljs-built_in">next</span>, head2.<span class="hljs-built_in">next</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure>

<h4 id="删除链表的倒数第-N-个结点"><a href="#删除链表的倒数第-N-个结点" class="headerlink" title="删除链表的倒数第 N 个结点"></a>删除链表的倒数第 N 个结点</h4><blockquote>
<p>给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Definition for singly-linked list.</span><br><span class="hljs-comment"># class ListNode:</span><br><span class="hljs-comment">#     def __init__(self, val=0, next=None):</span><br><span class="hljs-comment">#         self.val = val</span><br><span class="hljs-comment">#         self.next = next</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">removeNthFromEnd</span>(<span class="hljs-params">self, head: <span class="hljs-type">Optional</span>[ListNode], n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">Optional</span>[ListNode]:<br>        <span class="hljs-comment"># 让fast先走n步</span><br>        fast, slow = head, ListNode(-<span class="hljs-number">1</span>, head)   <span class="hljs-comment"># 规避删除节点是head</span><br>        res = slow<br>        <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            fast = fast.<span class="hljs-built_in">next</span><br>        <span class="hljs-keyword">while</span> fast:<br>            fast, slow = fast.<span class="hljs-built_in">next</span>, slow.<span class="hljs-built_in">next</span><br>        slow.<span class="hljs-built_in">next</span> = slow.<span class="hljs-built_in">next</span>.<span class="hljs-built_in">next</span><br>        <span class="hljs-keyword">return</span> res.<span class="hljs-built_in">next</span><br></code></pre></td></tr></table></figure>

<h4 id="两两交换链表中的节点"><a href="#两两交换链表中的节点" class="headerlink" title="两两交换链表中的节点"></a>两两交换链表中的节点</h4><blockquote>
<p>给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Definition for singly-linked list.</span><br><span class="hljs-comment"># class ListNode:</span><br><span class="hljs-comment">#     def __init__(self, val=0, next=None):</span><br><span class="hljs-comment">#         self.val = val</span><br><span class="hljs-comment">#         self.next = next</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">swapPairs</span>(<span class="hljs-params">self, head: <span class="hljs-type">Optional</span>[ListNode]</span>) -&gt; <span class="hljs-type">Optional</span>[ListNode]:<br>        <span class="hljs-comment"># 递归</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> head <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> head.<span class="hljs-built_in">next</span>:<br>            <span class="hljs-keyword">return</span> head<br>        cur = head.<span class="hljs-built_in">next</span><br>        head.<span class="hljs-built_in">next</span> = <span class="hljs-variable language_">self</span>.swapPairs(cur.<span class="hljs-built_in">next</span>)<br>        cur.<span class="hljs-built_in">next</span> = head<br>        <span class="hljs-keyword">return</span> cur<br></code></pre></td></tr></table></figure>

<h4 id="K-个一组翻转链表"><a href="#K-个一组翻转链表" class="headerlink" title="K 个一组翻转链表"></a>K 个一组翻转链表</h4><blockquote>
<p>给你链表的头节点 head ，每 k 个节点一组进行翻转，请你返回修改后的链表。<br>k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。<br>你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Definition for singly-linked list.</span><br><span class="hljs-comment"># class ListNode:</span><br><span class="hljs-comment">#     def __init__(self, val=0, next=None):</span><br><span class="hljs-comment">#         self.val = val</span><br><span class="hljs-comment">#         self.next = next</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">reverseKGroup</span>(<span class="hljs-params">self, head: <span class="hljs-type">Optional</span>[ListNode], k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">Optional</span>[ListNode]:<br>        n = <span class="hljs-number">0</span>   <span class="hljs-comment"># 获取长度</span><br>        cur = head<br>        <span class="hljs-keyword">while</span> cur:<br>            cur = cur.<span class="hljs-built_in">next</span><br>            n += <span class="hljs-number">1</span><br>        prev, cur = <span class="hljs-literal">None</span>, head<br>        dum = ListNode(-<span class="hljs-number">1</span>, head)<br>        start = dum<br>        <span class="hljs-keyword">while</span> n &gt;= k:<br>            n -= k<br>            <span class="hljs-comment"># k个一组进行链表反转</span><br>            <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(k):<br>                cur.<span class="hljs-built_in">next</span>, cur, prev = prev, cur.<span class="hljs-built_in">next</span>, cur<br>            <span class="hljs-comment"># start为反转链表的前一节点，cur此时落在下一个反转链表的开头，prev为本次反转链表的开头难</span><br>            start.<span class="hljs-built_in">next</span>.<span class="hljs-built_in">next</span>, start.<span class="hljs-built_in">next</span>, start = cur, prev, start.<span class="hljs-built_in">next</span><br>        <span class="hljs-keyword">return</span> dum.<span class="hljs-built_in">next</span><br></code></pre></td></tr></table></figure>

<h4 id="随机链表的复制"><a href="#随机链表的复制" class="headerlink" title="随机链表的复制"></a>随机链表的复制</h4><blockquote>
<p>给你一个长度为 n 的链表，每个节点包含一个额外增加的随机指针 random ，该指针可以指向链表中的任何节点或空节点。<br>构造这个链表的 深拷贝。 深拷贝应该正好由 n 个 全新 节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的 next 指针和 random 指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。复制链表中的指针都不应指向原链表中的节点 。<br>例如，如果原链表中有 X 和 Y 两个节点，其中 X.random –&gt; Y 。那么在复制链表中对应的两个节点 x 和 y ，同样有 x.random –&gt; y 。<br>返回复制链表的头节点。<br>用一个由 n 个节点组成的链表来表示输入&#x2F;输出中的链表。每个节点用一个 [val, random_index] 表示：<br>val：一个表示 Node.val 的整数。<br>random_index：随机指针指向的节点索引（范围从 0 到 n-1）；如果不指向任何节点，则为  null 。<br>你的代码 只 接受原链表的头节点 head 作为传入参数。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string"># Definition for a Node.</span><br><span class="hljs-string">class Node:</span><br><span class="hljs-string">    def __init__(self, x: int, next: &#x27;Node&#x27; = None, random: &#x27;Node&#x27; = None):</span><br><span class="hljs-string">        self.val = int(x)</span><br><span class="hljs-string">        self.next = next</span><br><span class="hljs-string">        self.random = random</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">copyRandomList</span>(<span class="hljs-params">self, head: <span class="hljs-string">&#x27;Optional[Node]&#x27;</span></span>) -&gt; <span class="hljs-string">&#x27;Optional[Node]&#x27;</span>:<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> head:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>            <br>        <span class="hljs-comment"># step1: 将原链表和新链表交错在一起</span><br>        cur = head<br>        <span class="hljs-keyword">while</span> cur:<br>            cur.<span class="hljs-built_in">next</span>, cur = Node(cur.val, cur.<span class="hljs-built_in">next</span>), cur.<span class="hljs-built_in">next</span><br>        <br>        <span class="hljs-comment"># step2: 遍历链表找到random，利用交错的特性来完成random的拷贝</span><br>        cur = head<br>        <span class="hljs-keyword">while</span> cur:<br>            <span class="hljs-keyword">if</span> cur.random:<br>                <span class="hljs-comment"># 进行拷贝</span><br>                cur.<span class="hljs-built_in">next</span>.random = cur.random.<span class="hljs-built_in">next</span><br>            cur = cur.<span class="hljs-built_in">next</span>.<span class="hljs-built_in">next</span><br>        <br>        <span class="hljs-comment"># step3: 分离出新链表</span><br>        cur = head.<span class="hljs-built_in">next</span><br>        <span class="hljs-keyword">while</span> cur.<span class="hljs-built_in">next</span>:<br>            cur.<span class="hljs-built_in">next</span>, cur = cur.<span class="hljs-built_in">next</span>.<span class="hljs-built_in">next</span>, cur.<span class="hljs-built_in">next</span>.<span class="hljs-built_in">next</span><br>        <span class="hljs-keyword">return</span> head.<span class="hljs-built_in">next</span><br></code></pre></td></tr></table></figure>

<h4 id="排序链表"><a href="#排序链表" class="headerlink" title="排序链表"></a>排序链表</h4><blockquote>
<p>给你链表的头结点 head ，请将其按 升序 排列并返回 排序后的链表 。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Definition for singly-linked list.</span><br><span class="hljs-comment"># class ListNode:</span><br><span class="hljs-comment">#     def __init__(self, val=0, next=None):</span><br><span class="hljs-comment">#         self.val = val</span><br><span class="hljs-comment">#         self.next = next</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-comment"># 使用分治来反复平分链表，再归并排序</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">middleNode</span>(<span class="hljs-params">self, head: <span class="hljs-type">Optional</span>[ListNode]</span>) -&gt; <span class="hljs-type">Optional</span>[ListNode]:<br>        slow, fast, prev = head, head, <span class="hljs-literal">None</span><br>        <span class="hljs-keyword">while</span> fast <span class="hljs-keyword">and</span> fast.<span class="hljs-built_in">next</span>:<br>            prev, slow, fast = slow, slow.<span class="hljs-built_in">next</span>, fast.<span class="hljs-built_in">next</span>.<span class="hljs-built_in">next</span><br>        prev.<span class="hljs-built_in">next</span> = <span class="hljs-literal">None</span>    <span class="hljs-comment"># 断开两个链表的连接</span><br>        <span class="hljs-keyword">return</span> slow<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">mergeTwoLists</span>(<span class="hljs-params">self, head1: <span class="hljs-type">Optional</span>[ListNode], head2: <span class="hljs-type">Optional</span>[ListNode]</span>) -&gt; <span class="hljs-type">Optional</span>[ListNode]:<br>        dum = ListNode(-<span class="hljs-number">1</span>)<br>        cur = dum<br>        <span class="hljs-keyword">while</span> head1 <span class="hljs-keyword">and</span> head2:<br>            <span class="hljs-keyword">if</span> head1.val &lt; head2.val:<br>                cur.<span class="hljs-built_in">next</span> = head1<br>                head1 = head1.<span class="hljs-built_in">next</span><br>            <span class="hljs-keyword">else</span>:<br>                cur.<span class="hljs-built_in">next</span> = head2<br>                head2 = head2.<span class="hljs-built_in">next</span><br>            cur = cur.<span class="hljs-built_in">next</span><br>        cur.<span class="hljs-built_in">next</span> = head1 <span class="hljs-keyword">if</span> head1 <span class="hljs-keyword">else</span> head2<br>        <span class="hljs-keyword">return</span> dum.<span class="hljs-built_in">next</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">sortList</span>(<span class="hljs-params">self, head: <span class="hljs-type">Optional</span>[ListNode]</span>) -&gt; <span class="hljs-type">Optional</span>[ListNode]:<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> head <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> head.<span class="hljs-built_in">next</span>:<br>            <span class="hljs-keyword">return</span> head<br>        <br>        head2 = <span class="hljs-variable language_">self</span>.middleNode(head)<br><br>        <span class="hljs-comment"># 保证两个子链表排好序</span><br>        head = <span class="hljs-variable language_">self</span>.sortList(head)<br>        head2 = <span class="hljs-variable language_">self</span>.sortList(head2)<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.mergeTwoLists(head, head2)<br></code></pre></td></tr></table></figure>

<h4 id="合并-K-个升序链表"><a href="#合并-K-个升序链表" class="headerlink" title="合并 K 个升序链表"></a>合并 K 个升序链表</h4><blockquote>
<p>给你一个链表数组，每个链表都已经按升序排列。<br>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Definition for singly-linked list.</span><br><span class="hljs-comment"># class ListNode:</span><br><span class="hljs-comment">#     def __init__(self, val=0, next=None):</span><br><span class="hljs-comment">#         self.val = val</span><br><span class="hljs-comment">#         self.next = next</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-comment"># 两两一组，四四一组，以此类推进行自底向上的合并</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">mergeTwoLists</span>(<span class="hljs-params">self, list1: <span class="hljs-type">Optional</span>[ListNode], list2: <span class="hljs-type">Optional</span>[ListNode]</span>) -&gt; <span class="hljs-type">Optional</span>[ListNode]:<br>        dum = ListNode(-<span class="hljs-number">1</span>)<br>        cur = dum<br>        <span class="hljs-keyword">while</span> list1 <span class="hljs-keyword">and</span> list2:<br>            <span class="hljs-keyword">if</span> list1.val &lt; list2.val:<br>                cur.<span class="hljs-built_in">next</span> = list1<br>                list1 = list1.<span class="hljs-built_in">next</span><br>            <span class="hljs-keyword">else</span>:<br>                cur.<span class="hljs-built_in">next</span> = list2<br>                list2 = list2.<span class="hljs-built_in">next</span><br>            cur = cur.<span class="hljs-built_in">next</span><br>        cur.<span class="hljs-built_in">next</span> = list1 <span class="hljs-keyword">if</span> list1 <span class="hljs-keyword">else</span> list2<br>        <span class="hljs-keyword">return</span> dum.<span class="hljs-built_in">next</span><br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">mergeKLists</span>(<span class="hljs-params">self, lists: <span class="hljs-type">List</span>[<span class="hljs-type">Optional</span>[ListNode]]</span>) -&gt; <span class="hljs-type">Optional</span>[ListNode]:<br>        m = <span class="hljs-built_in">len</span>(lists)<br>        <span class="hljs-keyword">if</span> m == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>        step = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">while</span> step &lt; m:<br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, m - step, step * <span class="hljs-number">2</span>):<br>                lists[i] = <span class="hljs-variable language_">self</span>.mergeTwoLists(lists[i], lists[i + step])<br>            step *= <span class="hljs-number">2</span><br>        <span class="hljs-keyword">return</span> lists[<span class="hljs-number">0</span>]<br></code></pre></td></tr></table></figure>

<h4 id="LRU缓存"><a href="#LRU缓存" class="headerlink" title="LRU缓存"></a>LRU缓存</h4><blockquote>
<p>请你设计并实现一个满足  LRU (最近最少使用) 缓存 约束的数据结构。<br>实现 LRUCache 类：<br>LRUCache(int capacity) 以 正整数 作为容量 capacity 初始化 LRU 缓存<br>int get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。<br>void put(int key, int value) 如果关键字 key 已经存在，则变更其数据值 value ；如果不存在，则向缓存中插入该组 key-value 。如果插入操作导致关键字数量超过 capacity ，则应该 逐出 最久未使用的关键字。<br>函数 get 和 put 必须以 O(1) 的平均时间复杂度运行。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, key = <span class="hljs-number">0</span>, value = <span class="hljs-number">0</span></span>):<br>        <span class="hljs-variable language_">self</span>.key = key<br>        <span class="hljs-variable language_">self</span>.value = value<br>        <span class="hljs-variable language_">self</span>.prev = <span class="hljs-literal">None</span><br>        <span class="hljs-variable language_">self</span>.<span class="hljs-built_in">next</span> = <span class="hljs-literal">None</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LRUCache</span>:<br>    <span class="hljs-comment"># 双向环形链表+字典快速查找</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, capacity: <span class="hljs-built_in">int</span></span>):<br>        <span class="hljs-variable language_">self</span>.capacity = capacity<br>        <span class="hljs-variable language_">self</span>.dum = Node()<br>        <span class="hljs-variable language_">self</span>.dum.prev = <span class="hljs-variable language_">self</span>.dum    <span class="hljs-comment"># 为最后一个，即即将过期的那个</span><br>        <span class="hljs-variable language_">self</span>.dum.<span class="hljs-built_in">next</span> = <span class="hljs-variable language_">self</span>.dum    <span class="hljs-comment"># 为第一个，即才访问的那个</span><br>        <span class="hljs-variable language_">self</span>.diction = &#123;&#125;<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get</span>(<span class="hljs-params">self, key: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        node = <span class="hljs-variable language_">self</span>.getNode(key)<br>        <span class="hljs-keyword">return</span> node.value <span class="hljs-keyword">if</span> node <span class="hljs-keyword">else</span> -<span class="hljs-number">1</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">put</span>(<span class="hljs-params">self, key: <span class="hljs-built_in">int</span>, value: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-literal">None</span>:<br>        node = <span class="hljs-variable language_">self</span>.getNode(key)<br>        <span class="hljs-keyword">if</span> node:<br>            <span class="hljs-comment"># 更新value</span><br>            node.value = value<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-variable language_">self</span>.diction[key] = node = Node(key, value)<br>            <span class="hljs-variable language_">self</span>.push_front(node)<br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(<span class="hljs-variable language_">self</span>.diction) &gt; <span class="hljs-variable language_">self</span>.capacity:<br>                last_node = <span class="hljs-variable language_">self</span>.dum.prev<br>                <span class="hljs-keyword">del</span> <span class="hljs-variable language_">self</span>.diction[last_node.key]<br>                <span class="hljs-variable language_">self</span>.remove(last_node)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">getNode</span>(<span class="hljs-params">self, key: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">Optional</span>[Node]:<br>        <span class="hljs-keyword">if</span> key <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> <span class="hljs-variable language_">self</span>.diction:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>        node = <span class="hljs-variable language_">self</span>.diction[key]<br>        <span class="hljs-comment"># 使用过，放在最前面</span><br>        <span class="hljs-variable language_">self</span>.remove(node)<br>        <span class="hljs-variable language_">self</span>.push_front(node)<br>        <span class="hljs-keyword">return</span> node<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">remove</span>(<span class="hljs-params">self, node: Node</span>) -&gt; <span class="hljs-literal">None</span>:<br>        node.prev.<span class="hljs-built_in">next</span>, node.<span class="hljs-built_in">next</span>.prev = node.<span class="hljs-built_in">next</span>, node.prev<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">push_front</span>(<span class="hljs-params">self, node: Node</span>) -&gt; <span class="hljs-literal">None</span>:<br>        node.prev, node.<span class="hljs-built_in">next</span>, <span class="hljs-variable language_">self</span>.dum.<span class="hljs-built_in">next</span>.prev, <span class="hljs-variable language_">self</span>.dum.<span class="hljs-built_in">next</span> = <span class="hljs-variable language_">self</span>.dum, <span class="hljs-variable language_">self</span>.dum.<span class="hljs-built_in">next</span>, node, node   <span class="hljs-comment"># 注意从左到右依次赋值</span><br>        <br><br><br><span class="hljs-comment"># Your LRUCache object will be instantiated and called as such:</span><br><span class="hljs-comment"># obj = LRUCache(capacity)</span><br><span class="hljs-comment"># param_1 = obj.get(key)</span><br><span class="hljs-comment"># obj.put(key,value)</span><br></code></pre></td></tr></table></figure>

<h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><h4 id="对称二叉树"><a href="#对称二叉树" class="headerlink" title="对称二叉树"></a>对称二叉树</h4><blockquote>
<p>给你一个二叉树的根节点 root ， 检查它是否轴对称。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Definition for a binary tree node.</span><br><span class="hljs-comment"># class TreeNode:</span><br><span class="hljs-comment">#     def __init__(self, val=0, left=None, right=None):</span><br><span class="hljs-comment">#         self.val = val</span><br><span class="hljs-comment">#         self.left = left</span><br><span class="hljs-comment">#         self.right = right</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">isSymmetric</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">check</span>(<span class="hljs-params">left: <span class="hljs-type">Optional</span>[TreeNode], right: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-built_in">bool</span>:<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> left <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> right:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>            <span class="hljs-keyword">elif</span> left <span class="hljs-keyword">and</span> right:<br>                <span class="hljs-keyword">if</span> left.val != right.val:<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>                outside = check(left.left, right.right)<br>                inside = check(left.right, right.left)<br>                <span class="hljs-keyword">return</span> outside <span class="hljs-keyword">and</span> inside<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">return</span> check(root.left, root.right)<br></code></pre></td></tr></table></figure>

<h4 id="二叉树的直径"><a href="#二叉树的直径" class="headerlink" title="二叉树的直径"></a>二叉树的直径</h4><blockquote>
<p>给你一棵二叉树的根节点，返回该树的 直径 。<br>二叉树的 直径 是指树中任意两个节点之间最长路径的 长度 。这条路径可能经过也可能不经过根节点 root 。<br>两节点之间路径的 长度 由它们之间边数表示。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Definition for a binary tree node.</span><br><span class="hljs-comment"># class TreeNode:</span><br><span class="hljs-comment">#     def __init__(self, val=0, left=None, right=None):</span><br><span class="hljs-comment">#         self.val = val</span><br><span class="hljs-comment">#         self.left = left</span><br><span class="hljs-comment">#         self.right = right</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">diameterOfBinaryTree</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-comment"># 链为叶子节点到当前节点之间的长度，直径为左右两子树的最长链之和</span><br>        res = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">computeChain</span>(<span class="hljs-params">root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:<br>                <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br>            leftChain = computeChain(root.left) + <span class="hljs-number">1</span><br>            rightChain = computeChain(root.right) + <span class="hljs-number">1</span><br>            <span class="hljs-keyword">nonlocal</span> res<br>            res = <span class="hljs-built_in">max</span>(res, leftChain + rightChain)<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(leftChain, rightChain)<br>        computeChain(root)<br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure>

<h4 id="二叉树的层序遍历"><a href="#二叉树的层序遍历" class="headerlink" title="二叉树的层序遍历"></a>二叉树的层序遍历</h4><blockquote>
<p>给你二叉树的根节点 root ，返回其节点值的 层序遍历 。 （即逐层地，从左到右访问所有节点）。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Definition for a binary tree node.</span><br><span class="hljs-comment"># class TreeNode:</span><br><span class="hljs-comment">#     def __init__(self, val=0, left=None, right=None):</span><br><span class="hljs-comment">#         self.val = val</span><br><span class="hljs-comment">#         self.left = left</span><br><span class="hljs-comment">#         self.right = right</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">levelOrder</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:<br>        res = []<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:<br>            <span class="hljs-keyword">return</span> res<br>        q = deque()<br>        q.append(root)<br>        <span class="hljs-comment"># 使用队列辅助</span><br>        <span class="hljs-keyword">while</span> q:<br>            path = []<br>            <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(q)): <span class="hljs-comment"># 当前层的节点数</span><br>                node = q.popleft()<br>                path.append(node.val)<br>                <span class="hljs-keyword">if</span> node.left:<br>                    q.append(node.left)<br>                <span class="hljs-keyword">if</span> node.right:<br>                    q.append(node.right)<br>            res.append(path)<br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure>

<h4 id="二叉树展开为链表"><a href="#二叉树展开为链表" class="headerlink" title="二叉树展开为链表"></a>二叉树展开为链表</h4><blockquote>
<p>给你二叉树的根结点 root ，请你将它展开为一个单链表：<br>展开后的单链表应该同样使用 TreeNode ，其中 right 子指针指向链表中下一个结点，而左子指针始终为 null 。<br>展开后的单链表应该与二叉树 先序遍历 顺序相同。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Definition for a binary tree node.</span><br><span class="hljs-comment"># class TreeNode:</span><br><span class="hljs-comment">#     def __init__(self, val=0, left=None, right=None):</span><br><span class="hljs-comment">#         self.val = val</span><br><span class="hljs-comment">#         self.left = left</span><br><span class="hljs-comment">#         self.right = right</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    head = <span class="hljs-literal">None</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">flatten</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-literal">None</span>:<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        Do not return anything, modify root in-place instead.</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment"># 将先序遍历倒过来，从而倒着将树整理成链表</span><br>        <span class="hljs-comment"># 每次使用头插法即可</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:<br>            <span class="hljs-keyword">return</span> root<br>        <span class="hljs-variable language_">self</span>.flatten(root.right)<br>        <span class="hljs-variable language_">self</span>.flatten(root.left)<br>        root.left = <span class="hljs-literal">None</span><br>        root.right = <span class="hljs-variable language_">self</span>.head<br>        <span class="hljs-variable language_">self</span>.head = root<br></code></pre></td></tr></table></figure>

<h4 id="从前序与中序遍历序列构造二叉树"><a href="#从前序与中序遍历序列构造二叉树" class="headerlink" title="从前序与中序遍历序列构造二叉树"></a>从前序与中序遍历序列构造二叉树</h4><blockquote>
<p>给定两个整数数组 preorder 和 inorder ，其中 preorder 是二叉树的先序遍历， inorder 是同一棵树的中序遍历，请构造二叉树并返回其根节点。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Definition for a binary tree node.</span><br><span class="hljs-comment"># class TreeNode:</span><br><span class="hljs-comment">#     def __init__(self, val=0, left=None, right=None):</span><br><span class="hljs-comment">#         self.val = val</span><br><span class="hljs-comment">#         self.left = left</span><br><span class="hljs-comment">#         self.right = right</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">buildTree</span>(<span class="hljs-params">self, preorder: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], inorder: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">Optional</span>[TreeNode]:<br>        <span class="hljs-comment"># 使用哈希表预处理中序遍历，便于快速查找位置，节约时间</span><br>        index = &#123;x: i <span class="hljs-keyword">for</span> i, x <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(inorder)&#125;<br><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">findNode</span>(<span class="hljs-params">pre_l: <span class="hljs-built_in">int</span>, pre_r: <span class="hljs-built_in">int</span>, in_l: <span class="hljs-built_in">int</span>, in_r: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">Optional</span>[TreeNode]:<br>            <span class="hljs-keyword">if</span> pre_l &gt; pre_r:  <span class="hljs-comment"># 空节点</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>            start = preorder[pre_l]<br>            root = TreeNode(start)<br>            mid = index[start]<br>            left_len, right_len = mid - in_l, in_r - mid<br>            root.left = findNode(pre_l + <span class="hljs-number">1</span>, pre_l + left_len, in_l, mid - <span class="hljs-number">1</span>)<br>            root.right = findNode(pre_r - right_len + <span class="hljs-number">1</span>, pre_r, mid + <span class="hljs-number">1</span>, in_r)<br>            <span class="hljs-keyword">return</span> root<br>        <br>        <span class="hljs-keyword">return</span> findNode(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(preorder) - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(inorder) - <span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure>

<h4 id="路径总和-III"><a href="#路径总和-III" class="headerlink" title="路径总和 III"></a>路径总和 III</h4><blockquote>
<p>给定一个二叉树的根节点 root ，和一个整数 targetSum ，求该二叉树里节点值之和等于 targetSum 的 路径 的数目。<br>路径 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Definition for a binary tree node.</span><br><span class="hljs-comment"># class TreeNode:</span><br><span class="hljs-comment">#     def __init__(self, val=0, left=None, right=None):</span><br><span class="hljs-comment">#         self.val = val</span><br><span class="hljs-comment">#         self.left = left</span><br><span class="hljs-comment">#         self.right = right</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">pathSum</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode], targetSum: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-comment"># 类比和为K的子数组，使用哈希表，键为前缀和，值为个数</span><br>        res = <span class="hljs-number">0</span><br>        cnt = defaultdict(<span class="hljs-built_in">int</span>)<br>        cnt[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">recursive</span>(<span class="hljs-params">node: <span class="hljs-type">Optional</span>[TreeNode], s: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> node:<br>                <span class="hljs-keyword">return</span><br><br>            <span class="hljs-keyword">nonlocal</span> res<br>            s += node.val   <span class="hljs-comment"># 以该节点结尾的当前前缀和</span><br>            res += cnt[s - targetSum]<br>            cnt[s] += <span class="hljs-number">1</span><br><br>            recursive(node.left, s)<br>            recursive(node.right, s)<br>            cnt[s] -= <span class="hljs-number">1</span> <span class="hljs-comment"># 回溯，因此数量减一</span><br>        <br>        recursive(root, <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure>

<h4 id="二叉树的最近公共祖先"><a href="#二叉树的最近公共祖先" class="headerlink" title="二叉树的最近公共祖先"></a>二叉树的最近公共祖先</h4><blockquote>
<p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。<br>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Definition for a binary tree node.</span><br><span class="hljs-comment"># class TreeNode:</span><br><span class="hljs-comment">#     def __init__(self, x):</span><br><span class="hljs-comment">#         self.val = x</span><br><span class="hljs-comment">#         self.left = None</span><br><span class="hljs-comment">#         self.right = None</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">lowestCommonAncestor</span>(<span class="hljs-params">self, root: <span class="hljs-string">&#x27;TreeNode&#x27;</span>, p: <span class="hljs-string">&#x27;TreeNode&#x27;</span>, q: <span class="hljs-string">&#x27;TreeNode&#x27;</span></span>) -&gt; <span class="hljs-string">&#x27;TreeNode&#x27;</span>:<br>        <span class="hljs-comment"># 后序遍历自底向上</span><br>        <span class="hljs-comment"># 只返回p, q, None, 或者它们共同的祖先</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root <span class="hljs-keyword">or</span> root == p <span class="hljs-keyword">or</span> root == q:<br>            <span class="hljs-keyword">return</span> root<br>        left, right = <span class="hljs-variable language_">self</span>.lowestCommonAncestor(root.left, p, q), <span class="hljs-variable language_">self</span>.lowestCommonAncestor(root.right, p, q)<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> left <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> right:  <span class="hljs-comment"># 都为空，说明p,q都没出现</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>        <span class="hljs-keyword">if</span> left <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> right:  <span class="hljs-comment"># 其中一个不为空，说明已经找到或者只找到一个</span><br>            <span class="hljs-keyword">return</span> left<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> left <span class="hljs-keyword">and</span> right:<br>            <span class="hljs-keyword">return</span> right<br>        <span class="hljs-keyword">if</span> left <span class="hljs-keyword">and</span> right:  <span class="hljs-comment"># 左右各一个，说明当前节点为公共祖先</span><br>            <span class="hljs-keyword">return</span> root<br></code></pre></td></tr></table></figure>

<h4 id="二叉树中的最大路径和"><a href="#二叉树中的最大路径和" class="headerlink" title="二叉树中的最大路径和"></a>二叉树中的最大路径和</h4><blockquote>
<p>二叉树中的 路径 被定义为一条节点序列，序列中每对相邻节点之间都存在一条边。同一个节点在一条路径序列中 至多出现一次 。该路径 至少包含一个 节点，且不一定经过根节点。<br>路径和 是路径中各节点值的总和。<br>给你一个二叉树的根节点 root ，返回其 最大路径和 。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Definition for a binary tree node.</span><br><span class="hljs-comment"># class TreeNode:</span><br><span class="hljs-comment">#     def __init__(self, val=0, left=None, right=None):</span><br><span class="hljs-comment">#         self.val = val</span><br><span class="hljs-comment">#         self.left = left</span><br><span class="hljs-comment">#         self.right = right</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maxPathSum</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-comment"># 同样是只算链的和</span><br>        res = -inf<br><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">computeChain</span>(<span class="hljs-params">node: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> node:<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>            left_chain = computeChain(node.left)<br>            right_chain = computeChain(node.right)<br>            <span class="hljs-keyword">nonlocal</span> res<br>            res = <span class="hljs-built_in">max</span>(res, left_chain + right_chain + node.val)<br>            <span class="hljs-comment"># 链可以没有元素，res计算时保证了node.val，从而保证路径中至少有一个节点，而链不用，因此和0比较</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(<span class="hljs-built_in">max</span>(left_chain, right_chain) + node.val, <span class="hljs-number">0</span>)<br>        <br>        computeChain(root)<br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure>

<h3 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h3><h4 id="多数元素"><a href="#多数元素" class="headerlink" title="多数元素"></a>多数元素</h4><blockquote>
<p>给定一个大小为 n 的数组 nums ，返回其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n&#x2F;2 ⌋ 的元素。<br>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">majorityElement</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-comment"># 使用擂台比较，考虑到严格众数比其他数加起来都多，它一定会留到最后</span><br>        res = hp = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> nums:<br>            <span class="hljs-comment"># 每次hp = 0将该数字作为擂主，直到出现次数抵消，开启新擂主</span><br>            <span class="hljs-keyword">if</span> hp == <span class="hljs-number">0</span>:<br>                res, hp = x, <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                hp += <span class="hljs-number">1</span> <span class="hljs-keyword">if</span> x == res <span class="hljs-keyword">else</span> -<span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure>

<h4 id="颜色分类"><a href="#颜色分类" class="headerlink" title="颜色分类"></a>颜色分类</h4><blockquote>
<p>给定一个包含红色、白色和蓝色、共 n 个元素的数组 nums ，原地 对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。<br>我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。<br>必须在不使用库内置的 sort 函数的情况下解决这个问题。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">sortColors</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-literal">None</span>:<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        Do not return anything, modify nums in-place instead.</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment"># 使用插入排序，将nums[i]插入到nums[:i]的序列中去</span><br>        <span class="hljs-comment"># 只用将0,1,2结尾的三个数字向后移动，因此维护它们的位置</span><br>        p0 = p1 = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i, x <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(nums):<br>            <span class="hljs-comment"># 倒着插入，从而保证覆盖</span><br>            nums[i] = <span class="hljs-number">2</span><br>            <span class="hljs-keyword">if</span> x &lt;= <span class="hljs-number">1</span>:<br>                nums[p1] = <span class="hljs-number">1</span><br>                p1 += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> x == <span class="hljs-number">0</span>:<br>                nums[p0] = <span class="hljs-number">0</span><br>                p0 += <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>

<h4 id="下一个排列"><a href="#下一个排列" class="headerlink" title="下一个排列"></a>下一个排列</h4><blockquote>
<p>整数数组的一个 排列  就是将其所有成员以序列或线性顺序排列。<br>例如，arr &#x3D; [1,2,3] ，以下这些都可以视作 arr 的排列：[1,2,3]、[1,3,2]、[3,1,2]、[2,3,1] 。<br>整数数组的 下一个排列 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 下一个排列 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。<br>例如，arr &#x3D; [1,2,3] 的下一个排列是 [1,3,2] 。<br>类似地，arr &#x3D; [2,3,1] 的下一个排列是 [3,1,2] 。<br>而 arr &#x3D; [3,2,1] 的下一个排列是 [1,2,3] ，因为 [3,2,1] 不存在一个字典序更大的排列。<br>给你一个整数数组 nums ，找出 nums 的下一个排列。<br>必须 原地 修改，只允许使用额外常数空间。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">nextPermutation</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-literal">None</span>:<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        Do not return anything, modify nums in-place instead.</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        n = <span class="hljs-built_in">len</span>(nums)<br>        <span class="hljs-comment"># step1: 从右向左找到第一个小于右侧相邻数字的数x，此时x右边单调递减</span><br>        i = n - <span class="hljs-number">2</span><br>        <span class="hljs-keyword">while</span> i &gt;= <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> nums[i] &gt;= nums[i + <span class="hljs-number">1</span>]:<br>            i -= <span class="hljs-number">1</span><br><br>        <span class="hljs-comment"># step2: 找到x右边最小的大于x的数字y，进行交换，此时单调递减不变</span><br>        <span class="hljs-comment"># 注意如果step1没找到，说明已经是最大排列</span><br>        <span class="hljs-keyword">if</span> i &gt;= <span class="hljs-number">0</span>:<br>            j = n - <span class="hljs-number">1</span><br>            <span class="hljs-keyword">while</span> nums[j] &lt;= nums[i]:<br>                j -= <span class="hljs-number">1</span><br>            nums[i], nums[j] = nums[j], nums[i]<br><br>        <span class="hljs-comment"># step3: 反转y右边的数，变成最小排列</span><br>        left, right = i + <span class="hljs-number">1</span>, n - <span class="hljs-number">1</span><br>        <span class="hljs-keyword">while</span> left &lt; right:<br>            nums[left], nums[right] = nums[right], nums[left]<br>            left += <span class="hljs-number">1</span><br>            right -= <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>

<h4 id="寻找重复数"><a href="#寻找重复数" class="headerlink" title="寻找重复数"></a>寻找重复数</h4><blockquote>
<p>给定一个包含 n + 1 个整数的数组 nums ，其数字都在 [1, n] 范围内（包括 1 和 n），可知至少存在一个重复的整数。<br>假设 nums 只有 一个重复的整数 ，返回 这个重复的数 。<br>你设计的解决方案必须 不修改 数组 nums 且只用常量级 O(1) 的额外空间。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">findDuplicate</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-comment"># 使用环形链表，假设当前元素为i，则其指向nums[i]</span><br>        <span class="hljs-comment"># 环的入口的下标就是重复元素，因为进入环需要有元素指向该下标，而环内也有元素指向该下标</span><br>        <span class="hljs-comment"># 而nums[0] != 0，因此不用担心自环</span><br>        slow, fast = <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>            fast = nums[fast]<br>            fast = nums[fast]<br>            slow = nums[slow]<br>            <span class="hljs-keyword">if</span> fast == slow:<br>                <span class="hljs-keyword">break</span><br>        slow = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> fast != slow:<br>            fast = nums[fast]<br>            slow = nums[slow]<br>        <span class="hljs-keyword">return</span> slow<br></code></pre></td></tr></table></figure>

<h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><h4 id="在排序数组中查找元素的第一个和最后一个位置"><a href="#在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="在排序数组中查找元素的第一个和最后一个位置"></a>在排序数组中查找元素的第一个和最后一个位置</h4><blockquote>
<p>给你一个按照非递减顺序排列的整数数组 nums，和一个目标值 target。请你找出给定目标值在数组中的开始位置和结束位置。<br>如果数组中不存在目标值 target，返回 [-1, -1]。<br>你必须设计并实现时间复杂度为 O(log n) 的算法解决此问题。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">searchRange</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], target: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>        <span class="hljs-comment"># 寻找最小的满足nums[i] &gt;= target的下标，因此可能溢出len，也可能不存在target，后续用此进行判断</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">lower_bound</span>(<span class="hljs-params">t: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>            left, right = <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span><br>            <span class="hljs-keyword">while</span> left &lt;= right:<br>                mid = (left + right) // <span class="hljs-number">2</span><br>                <span class="hljs-keyword">if</span> nums[mid] &gt;= t:<br>                    right = mid - <span class="hljs-number">1</span><br>                <span class="hljs-keyword">else</span>:<br>                    left = mid + <span class="hljs-number">1</span><br>            <span class="hljs-keyword">return</span> left <span class="hljs-comment"># 此时left = right + 1，因此返回left</span><br>        <br>        start = lower_bound(target)<br>        <span class="hljs-comment"># 借lower_bound函数的漏洞判断存在与否</span><br>        <span class="hljs-keyword">if</span> start == <span class="hljs-built_in">len</span>(nums) <span class="hljs-keyword">or</span> nums[start] != target:<br>            <span class="hljs-keyword">return</span> [-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>]<br>        <span class="hljs-comment"># 因为都是整数，故+1找下一位</span><br>        end = lower_bound(target + <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> [start, end - <span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure>

<h4 id="搜索旋转排序数组"><a href="#搜索旋转排序数组" class="headerlink" title="搜索旋转排序数组"></a>搜索旋转排序数组</h4><blockquote>
<p>整数数组 nums 按升序排列，数组中的值 互不相同 。<br>在传递给函数之前，nums 在预先未知的某个下标 k（0 &lt;&#x3D; k &lt; nums.length）上进行了 向左旋转，使数组变为 [nums[k], nums[k+1], …, nums[n-1], nums[0], nums[1], …, nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 下标 3 上向左旋转后可能变为 [4,5,6,7,0,1,2] 。<br>给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。<br>你必须设计一个时间复杂度为 O(log n) 的算法解决此问题。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">search</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], target: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-comment"># 通过比较x与nums[-1]来判断x在第一段还是第二段</span><br>        <span class="hljs-comment"># check函数用以判断target是否在mid的左边（或者相等）</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">check</span>(<span class="hljs-params">i: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">bool</span>:<br>            x = nums[i]<br>            <span class="hljs-keyword">if</span> x &gt; nums[-<span class="hljs-number">1</span>]:    <span class="hljs-comment"># 在第一段，此时target也必须在第一段</span><br>                <span class="hljs-keyword">return</span> target &gt; nums[-<span class="hljs-number">1</span>] <span class="hljs-keyword">and</span> x &gt;= target<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">return</span> target &gt; nums[-<span class="hljs-number">1</span>] <span class="hljs-keyword">or</span> x &gt;= target<br>        <br>        left, right = <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span><br>        <span class="hljs-keyword">while</span> left &lt; right:<br>            mid = (left + right) // <span class="hljs-number">2</span><br>            <span class="hljs-keyword">if</span> check(mid):<br>                right = mid<br>            <span class="hljs-keyword">else</span>:<br>                left = mid + <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> right <span class="hljs-keyword">if</span> nums[right] == target <span class="hljs-keyword">else</span> -<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>

<h4 id="寻找两个正序数组的中位数"><a href="#寻找两个正序数组的中位数" class="headerlink" title="寻找两个正序数组的中位数"></a>寻找两个正序数组的中位数</h4><blockquote>
<p>给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。<br>算法的时间复杂度应该为 O(log (m+n)) 。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">findMedianSortedArrays</span>(<span class="hljs-params">self, nums1: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], nums2: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">float</span>:<br>        <span class="hljs-comment"># 均分两个数组合并在一起的数组，从而利用前数组的最大值和后数组的最小值求得中位数</span><br>        <span class="hljs-comment"># 从枚举nums1中有多少元素在前数组中，到二分查找</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums1) &gt; <span class="hljs-built_in">len</span>(nums2):<br>            nums1, nums2 = nums2, nums1<br>        m, n = <span class="hljs-built_in">len</span>(nums1), <span class="hljs-built_in">len</span>(nums2)<br>        <span class="hljs-comment"># 计算有多少元素在前数组中</span><br>        left, right = <span class="hljs-number">0</span>, m<br>        <span class="hljs-keyword">while</span> left &lt;= right:<br>            i = (left + right) // <span class="hljs-number">2</span> <span class="hljs-comment"># nums1中有多少元素在前数组中</span><br>            j = (m + n + <span class="hljs-number">1</span>) // <span class="hljs-number">2</span> - i    <span class="hljs-comment"># 规定奇数时前数组比后数组多一个元素</span><br>            nums1_left = nums1[i - <span class="hljs-number">1</span>] <span class="hljs-keyword">if</span> i &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> <span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;-inf&#x27;</span>)<br>            nums1_right = nums1[i] <span class="hljs-keyword">if</span> i &lt; m <span class="hljs-keyword">else</span> <span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;inf&#x27;</span>)<br>            nums2_left = nums2[j - <span class="hljs-number">1</span>] <span class="hljs-keyword">if</span> j &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> <span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;-inf&#x27;</span>)<br>            nums2_right = nums2[j] <span class="hljs-keyword">if</span> j &lt; n <span class="hljs-keyword">else</span> <span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;inf&#x27;</span>)<br>            <span class="hljs-keyword">if</span> nums1_left &lt;= nums2_right <span class="hljs-keyword">and</span> nums2_left &lt;= nums1_right:<br>                left_max = <span class="hljs-built_in">max</span>(nums1_left, nums2_left)<br>                right_min = <span class="hljs-built_in">min</span>(nums1_right, nums2_right)<br>                <span class="hljs-keyword">if</span> (m + n) % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>:<br>                    <span class="hljs-keyword">return</span> (left_max + right_min) / <span class="hljs-number">2</span><br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-keyword">return</span> left_max<br>            <span class="hljs-keyword">elif</span> nums1_left &lt; nums2_right:   <span class="hljs-comment"># 太小，多选</span><br>                left = i + <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:   <span class="hljs-comment"># 太大，少选</span><br>                right = i - <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E5%8A%9B%E6%89%A3/" class="category-chain-item">力扣</a>
  
  
    <span>></span>
    
  <a href="/categories/%E5%8A%9B%E6%89%A3/hot100/" class="category-chain-item">hot100</a>
  
  

  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/leetcode/" class="print-no-link">#leetcode</a>
      
        <a href="/tags/hot100/" class="print-no-link">#hot100</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>hot100整理之python版</div>
      <div>http://example.com/2025/09/14/hot100整理之python版/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>jietiDdd</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2025年9月14日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2025/09/21/CSE-lecture2-File-System-1/" title="CSE_lecture2:File System 1">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">CSE_lecture2:File System 1</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/09/14/leetcode%E6%89%80%E9%9C%80python%E7%9B%B8%E5%85%B3api%E6%95%B4%E7%90%86/" title="leetcode所需python相关api整理">
                        <span class="hidden-mobile">leetcode所需python相关api整理</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments" lazyload>
      
  <script type="text/javascript">
    Fluid.utils.loadComments('#comments', function() {
      var light = 'github-light';
      var dark = 'github-dark';
      var schema = document.documentElement.getAttribute('data-user-color-scheme');
      if (schema === 'dark') {
        schema = dark;
      } else {
        schema = light;
      }
      window.UtterancesThemeLight = light;
      window.UtterancesThemeDark = dark;
      var s = document.createElement('script');
      s.setAttribute('src', 'https://utteranc.es/client.js');
      s.setAttribute('repo', 'jietiDdd/jietiDdd.github.io');
      s.setAttribute('issue-term', 'pathname');
      
      s.setAttribute('label', 'utterances');
      
      s.setAttribute('theme', schema);
      s.setAttribute('crossorigin', 'anonymous');
      document.getElementById('comments').appendChild(s);
    })
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
